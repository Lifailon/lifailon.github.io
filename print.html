<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PowerShell Commands</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PowerShell Commands</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>+++
title = "PowerShell Syntax"
[extra]
toc = true
toc_sidebar = true
go_to_top = true
+++</p>
<p align="center">
    <a href="https://github.com/Lifailon/PS-Commands"><img title="PS-Commands Logo"src="PowerShell/PS-Commands-Logo.png"></a>
</p>
<p align="center">
    Синтаксис и работа с модулями в <b>PowerShell</b>.
</p>
<hr />
<p align="center">
<a href="https://github.com/Lifailon/PS-Commands"><img title="PowerShell Cheat Sheet RU"src="PowerShell/PowerShell-Cheat-Sheet-RU.jpg"></a>
</p>
<hr />
<h1 id="help"><a class="header" href="#help">Help</a></h1>
<p><code>Get-Verb</code> действия/глаголы, утвержденные для использования в командлетах <br />
<code>Get-Command *Language*</code> поиск команды по имени <br />
<code>(Get-Command Get-Language).Module</code> узнать к какому модулю принадлежит команда <br />
<code>Get-Command Get-Content | fl Module,DLL</code> узнать принадлежность команды к модулю и dll <br />
<code>Get-Command -Module LanguagePackManagement</code> отобразить список команд указанного модуля <br />
<code>(Get-Module LanguagePackManagement).ExportedCommands.Values</code> отобразить список команд указанного модуля <br />
<code>Get-Language | Get-Member</code> отобразить список методов команды (действия), объекты вывода и Event (события объектов: Click) <br />
<code>(Get-Help Get-Service).Aliases</code> узнать псевдонимом команды <br />
<code>Get-Alias gsv</code> узнать имя команды по псевдониму <br />
<code>Get-Help Get-Service</code> синтаксис <br />
<code>Get-Help Get-Service -Parameter *</code> описание всех параметров <br />
<code>Get-Help Get-Service -Online</code> <br />
<code>Get-Help Get-Service -ShowWindow</code> описание параметров в GUI с фильтрацией <br />
<code>Show-Command</code> вывести список команд в GUI <br />
<code>Show-Command Get-Service</code> список параметров команды в GUI <br />
<code>Invoke-Expression</code> iex принимает текст для выполнения в консоли как команды <br />
<code>$PSVersionTable</code> текущая версия PowerShell <br />
<code>Set-ExecutionPolicy Unrestricted</code> <br />
<code>Get-ExecutionPolicy</code> <br />
<code>$Metadata = New-Object System.Management.Automation.CommandMetaData (Get-Command Get-Service)</code> получить информацию о командлете <br />
<code>[System.Management.Automation.ProxyCommand]::Create($Metadata)</code> исходный код функции</p>
<h1 id="object"><a class="header" href="#object">Object</a></h1>
<h3 id="variable"><a class="header" href="#variable">Variable</a></h3>
<p><code>$var = Read-Host "Enter"</code> ручной ввод <br />
<code>$pass = Read-Host "Enter Password" -AsSecureString</code> скрывать набор <br />
<code>$global:path = "\\path"</code> задать глобальную переменную, например в функции <br />
<code>$using:srv</code> использовать переменную текущей сесси в Invoke-сессии <br />
<code>Get-Variable</code> отобразить все переменные <br />
<code>ls variable:/</code> отобразить все переменные <br />
<code>Get-Variable *srv*</code> найти переменную по имени <br />
<code>Get-Variable -Scope Global</code> отобразить все глобальные переменные <br />
<code>Get-Variable Error</code> последняя команда с ошибкой <br />
<code>Remove-Variable -Name *</code> очистить все переменные <br />
<code>$LASTEXITCODE</code> содержит код вывода последней запущенной программы, например ping. Если код возврата положительный (True), то $LastExitCode = 0</p>
<h3 id="env"><a class="header" href="#env">ENV</a></h3>
<p><code>Get-ChildItem Env:</code> отобразить все переменные окружения <br />
<code>$env:PSModulePath</code> директории импорта модулей <br />
<code>$env:userprofile</code> <br />
<code>$env:computername</code> <br />
<code>$env:username</code> <br />
<code>$env:userdnsdomain</code> <br />
<code>$env:logonserver</code> <br />
<code>([DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()).Name</code> <br />
<code>[Environment]::GetFolderPath('ApplicationData')</code></p>
<h3 id="history"><a class="header" href="#history">History</a></h3>
<p><code>Get-History</code> история команд текущей сессии <br />
<code>(Get-History)[-1].Duration.TotalSeconds</code> время выполнения последней команды <br />
<code>(Get-PSReadLineOption).HistorySavePath</code> путь к сохраненному файлу с 4096 последних команд (из модуля PSReadLine) <br />
<code>Get-Content (Get-PSReadlineOption).HistorySavePath | Select-String Get</code> поиск по содержимому файла (GREP) <br />
<code>Set-PSReadlineOption -MaximumHistoryCount 10000</code> изменить количество сохраняемых команд в файл <br />
<code>Get-PSReadLineOption | select MaximumHistoryCount</code> <br />
<code>Set-PSReadlineOption -HistorySaveStyle SaveNothing</code> отключить ведение журнала <br />
<code>F2</code> переключиться с InlineView на ListView</p>
<h3 id="clipboard"><a class="header" href="#clipboard">Clipboard</a></h3>
<p><code>Set-Clipboard $srv</code> скопировать в буфер обмена <br />
<code>Get-Clipboard</code> вставить</p>
<h3 id="write-host"><a class="header" href="#write-host">Write-Host</a></h3>
<pre><code class="language-PowerShell">Write-Host -BackgroundColor Green "Test:" -NoNewline # изменить цвет фона и запретить перенос строки
Write-Host " True" -ForegroundColor Green # данная строка будет печататься продолжая предыдущую с новыми параметрами цвета (фон по умолчанию, изменяем цвет текста)
</code></pre>
<p><code>Write-Error "False"</code> <br />
<code>Write-Warning "False"</code></p>
<h3 id="write-progress"><a class="header" href="#write-progress">Write-Progress</a></h3>
<pre><code class="language-PowerShell">foreach ($n in 1..100) {
    Write-Progress -Activity "Test Progress" -PercentComplete $n
    Start-Sleep -Milliseconds 100
}
</code></pre>
<h3 id="for"><a class="header" href="#for">for</a></h3>
<pre><code class="language-PowerShell">for ($i = 0; $i -le 100; $i+=10) {
    Write-Progress -Activity "Test Progress" -PercentComplete $i
    Start-Sleep -Seconds 1
}
</code></pre>
<h3 id="array"><a class="header" href="#array">Array</a></h3>
<p><code>$srv = @("server-01", "server-02")</code>  создать массив <br />
<code>$srv += @("server-03")</code> добавить в массив новый элемент <br />
<code>$srv.Count</code> отобразить кол-во элементов в массиве <br />
<code>Out-String</code> построчный вывод</p>
<h3 id="index"><a class="header" href="#index">Index</a></h3>
<p><code>$srv[0]</code> вывести первое значение элемента массива <br />
<code>$srv[0] = Name</code> замена элемента в массиве <br />
<code>$srv[0].Length</code> узнать кол-во символов первого значения в массиве <br />
<code>$srv[10..100]</code> срез</p>
<pre><code class="language-PowerShell">$array = "a","b","c","d"
$num = 0
foreach ($a in $array) {
    $num += 1
    $index = [array]::IndexOf($array, $a) # узнать номер индекса по зачению
    $array[$index] = $num # пересобрать исходный массив
}
</code></pre>
<h3 id="hashtable"><a class="header" href="#hashtable">HashTable</a></h3>
<pre><code class="language-PowerShell">$hashtable = @{ # Создать (инициализировать)
    "User" = $env:USERNAME; 
    "Server" = $env:COMPUTERNAME
}

$hashtable += @{ # Добавить ключи
    "Profile" = $PROFILE;
    "PowerShell_Home_Dir" = $PSHOME
}
</code></pre>
<p><code>$hashtable.Keys</code> список всех ключей <br />
<code>$hashtable["User"]</code> получить значение (Values) по ключу <br />
<code>$hashtable["User"] = "Test"</code> изменить <br />
<code>$hashtable.Remove("User")</code> удалить ключ</p>
<h3 id="collections"><a class="header" href="#collections">Collections</a></h3>
<pre><code class="language-PowerShell">$Collections = New-Object System.Collections.Generic.List[System.Object]
$Collections.Add([PSCustomObject]@{
    User = $env:username;
    Server = $env:computername
})
</code></pre>
<h3 id="pscustomobject"><a class="header" href="#pscustomobject">PSCustomObject</a></h3>
<pre><code class="language-PowerShell">$CustomObject = [PSCustomObject][ordered]@{
    User = $env:username;
    Server = $env:computername
}
</code></pre>
<h3 id="add-and-remove-property"><a class="header" href="#add-and-remove-property">Add and Remove Property</a></h3>
<p><code>$CustomObject | Add-Member –MemberType NoteProperty –Name Arr –Value @(1,2,3)</code> добавить свойство/стобец <br />
<code>$CustomObject.Arr = @(1,3,5)</code> изменить содержимое <br />
<code>$CustomObject.PsObject.Properties.Remove('User')</code> удалить Property</p>
<h3 id="add-method"><a class="header" href="#add-method">Add Method</a></h3>
<pre><code class="language-PowerShell">$ScriptBlock = {Get-Service}
$CustomObject | Add-Member -Name "TestMethod" -MemberType ScriptMethod -Value $ScriptBlock
$CustomObject | Get-Member
$CustomObject.TestMethod()
</code></pre>
<h3 id="class"><a class="header" href="#class">Class</a></h3>
<pre><code class="language-PowerShell">Class CustomClass {
    [string]$User
    [string]$Server
    Start([bool]$Param1) {
        If ($Param1) {
        Write-Host "Start Function"
        }
    }
}
</code></pre>
<p><code>$Class = New-Object -TypeName CustomClass</code> <br />
<code>$Class.User = $env:username</code> <br />
<code>$Class.Server = $env:computername</code> <br />
<code>$Class.Start(1)</code></p>
<h3 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h3>
<p><code>$CustomObject | Add-Member -MemberType NoteProperty -Name "Type" -Value "user" -Force</code> добавление объкта вывода NoteProperty <br />
<code>$CustomObject | Add-Member -MemberType NoteProperty -Name "User" -Value "admin" -Force</code> изменеие содержимого для сущности объекта User <br />
<code>ping $srv | Out-Null</code> перенаправить результат вывода в Out-Null</p>
<h3 id="select-object"><a class="header" href="#select-object">Select-Object</a></h3>
<p><code>Get-Process | Select-Object -Property *</code> отобразить все доступные объекты вывода <br />
<code>Get-Process | select -Unique "Name"</code> удалить повторяющиеся значения в массиве <br />
<code>Get-Process | select -ExpandProperty ProcessName</code> преобразовать из объекта-коллекции в массив (вывести содержимое без наименовая столбца) <br />
<code>(Get-Process | ? Name -match iperf).Modules</code> список используемых модулей процессом</p>
<h3 id="expression"><a class="header" href="#expression">Expression</a></h3>
<pre><code class="language-PowerShell">Get-Process | Sort-Object -Descending CPU | select -first 10 ProcessName, # сортировка по CPU, вывести первых 10 значений (-first)
@{Name="ProcessorTime";
    Expression={$_.TotalProcessorTime -replace "\.\d+$"} # затрачено процессорного времени в минутах
},
@{Name="Memory"; 
    Expression={[string]([int]($_.WS / 1024kb))+"MB"} # делим байты на КБ (1mb)
},
@{Label="RunTime"; 
    Expression={((Get-Date) - $_.StartTime) -replace "\.\d+$"} # вычесть из текущего времени - время запуска, и удалить milisec
}
</code></pre>
<h3 id="select-string"><a class="header" href="#select-string">Select-String</a></h3>
<p><code>$(ipconfig | Select-String IPv4) -replace ".+: " | Where-Object {$_ -match "^172."}</code> узнать только IP <br />
<code>$Current_IP = Get-Content $RDCMan_RDG_PATH | Select-String $RDCMan_Display_Name -Context 0,1</code> получить две строки <br />
<code>$Current_IP = $Current_IP.Context.DisplayPostContext[0] -replace ".+&lt;name&gt;|&lt;\/name&gt;"</code> забрать только вторую строку и удалить тэги</p>
<h3 id="format"><a class="header" href="#format">Format</a></h3>
<p><code>Get-Process | fl ProcessName, StartTime</code> <br />
<code>Get-Process | ft ProcessName, StartTime -Autosize</code> автоматическая группировка размера столбцов</p>
<h3 id="measure-object"><a class="header" href="#measure-object">Measure-Object</a></h3>
<p><code>Get-Process | Measure | select Count</code> кол-во объектов <br />
<code>Get-Process | Measure -Line -Word -Character</code> кол-во строк, слов и Char объектов <br />
<code>Get-Process | Measure-Object PM -sum | Select-Object Count,@{Name="MEM_MB"; Expression={[int]($_.Sum/1mb)}}</code> кол-во процессов и общий объем занятой памяти в МБайт</p>
<h3 id="compare-object"><a class="header" href="#compare-object">Compare-Object</a></h3>
<p><code>Compare-Object -ReferenceObject (Get-Content -Path .\file1.txt) -DifferenceObject (Get-Content -Path .\file2.txt)</code> сравнение двух файлов <br />
<code>$group1 = Get-ADGroupMember -Identity "Domain Admins"</code> <br />
<code>$group2 = Get-ADGroupMember -Identity "Enterprise Admins"</code> <br />
<code>Compare-Object -ReferenceObject $group1 -DifferenceObject $group2 -IncludeEqual</code> сравнение друх объектов
<code>==</code> нет изменений <br />
<code>&lt;=</code> есть изменения в $group1 <br />
<code>=&gt;</code> есть изменения в $group2</p>
<h3 id="where-object"><a class="header" href="#where-object">Where-Object</a></h3>
<p><code>Get-Process | Where-Object {$_.ProcessName -match "zabbix"}</code> фильтрация/поиск процессов по имени свойства объекта <br />
<code>Get-Process | where CPU -gt 10 | Sort-Object -Descending CPU</code> вывести объекты, где значения CPU больше 10 <br />
<code>Get-Process | where WS -gt 200MB</code> отобразить процессы где WS выше 200МБ <br />
<code>Get-Service | where Name -match "zabbix"</code> поиск службы <br />
<code>Get-Service -ComputerName $srv | Where {$_.Name -match "WinRM"} | Restart-Service</code> перезапустить службу на удаленном компьютере <br />
<code>(Get-Service).DisplayName</code> вывести значения свойства массива <br />
<code>netstat -an | where {$_ -match 443}</code> <br />
<code>netstat -an | ?{$_ -match 443}</code> <br />
<code>(netstat -an) -match 443</code></p>
<h3 id="sort-object"><a class="header" href="#sort-object">Sort-Object</a></h3>
<p><code>Get-Process | Sort-Object -Descending CPU | ft</code> обратная (-Descending) сортировка по CPU <br />
<code>Get-Process | Sort-Object -Descending cpu,ws</code> сортировка по двум свойствам <br />
<code>$path[-1..-10]</code> обратная сборка массива без сортировки <br />
<code>$arr = @(1..20); $arr[$($arr.Count - 1)..0]</code> пересобрать массив с конца</p>
<h3 id="last-and-first"><a class="header" href="#last-and-first">Last and First</a></h3>
<p><code>Get-Process | Sort-Object -Descending CPU | select -First 10</code> вывести первых 10 объектов <br />
<code>Get-Process | Sort-Object -Descending CPU | select -Last 10</code> вывести последних 10 объектов</p>
<h3 id="group-object"><a class="header" href="#group-object">Group-Object</a></h3>
<pre><code class="language-PowerShell">$Groups = Get-CimInstance -Class Win32_PnPSignedDriver |
Select-Object DriverProviderName, FriendlyName, Description, DriverVersion, DriverDate |
Group-Object DriverProviderName, FriendlyName, Description, DriverVersion, DriverDate
$(foreach ($Group in $Groups) {
    $Group.Group[0]
}) | Format-Table
</code></pre>
<h3 id="property"><a class="header" href="#property">Property</a></h3>
<p><code>$srv.Count</code> кол-во элементов в массиве <br />
<code>$srv.Length</code> содержит количество символом строки переменной [string] или количество значений (строк) объекта <br />
<code>$srv.Chars(2)</code> отобразить 3-й символ в строке <br />
<code>$srv[2]</code> отобразить 3-ю строку в массиве</p>
<h3 id="method"><a class="header" href="#method">Method</a></h3>
<p><code>$srv = "127.0.0.1"</code> <br />
<code>$srv.Insert(0,"https://")</code> добавить значение перед первым символом <br />
<code>$srv.Substring(4)</code> удалить (из всего массива) первые 4 символа <br />
<code>$srv.Remove(3)</code> удалить из всего массива все после 3 символа <br />
<code>$string = "123"</code> создать строку <br />
<code>$int = [convert]::ToInt32($string)</code> преобразовать строку в тип данных число <br />
<code>[string]::Concat($text,$num)</code> объеденить переменные в одну строку <br />
<code>[string]::Join(":",$text,$num)</code> объеденить используя разделитель <br />
<code>[string]::Compare($text,$num,$true)</code> выдает 0 при совпадении или 1/-1 при несовпадении, $true (без учета регистра) или $false (с учетом регистра) <br />
<code>[string]::Equals($text,$num)</code> производит сравнение двух строк и выдает $true при их совпадении или $false при несовпадении <br />
<code>[string]::IsNullOrEmpty($text)</code> проверяет наличие строки, если строка пуста $true, если нет $false <br />
<code>[string]::IsNullOrWhiteSpace($text2)</code> проверяет на наличие только символов пробел, табуляция или символ новой строки</p>
<h1 id="error"><a class="header" href="#error">Error</a></h1>
<p><code>$Error</code> выводит все ошибки текущего сеанса <br />
<code>$Error[0].InvocationInfo</code> развернутый отчет об ошибке <br />
<code>$Error.clear()</code> <br />
<code>$LASTEXITCODE</code> результат выполнения последней команды (0 - успех) <br />
<code>exit 1</code> код завершения, который возвращается $LASTEXITCODE</p>
<h3 id="executionstatus"><a class="header" href="#executionstatus">ExecutionStatus</a></h3>
<pre><code class="language-PowerShell">$(Get-History)[-1] | Select-Object @{
    Name="RunTime"; Expression={$_.EndExecutionTime - $_.StartExecutionTime}
},ExecutionStatus,CommandLine # посчитать время работы последней [-1] (или Select-Object -Last 1) выполненной команды и ее узнать статус
</code></pre>
<h3 id="measure-command"><a class="header" href="#measure-command">Measure-Command</a></h3>
<p><code>$(Measure-Command {ping ya.ru}).TotalSeconds</code> получить время выполнения в секундах</p>
<h1 id="datetime"><a class="header" href="#datetime">DateTime</a></h1>
<p><code>[DateTime]::UtcNow</code> время в формате UTC 0 <br />
<code>$(Get-Date).AddHours(-3)</code> вычесть три часа из текущего времени <br />
<code>$Date = $(Get-Date -Format "dd/MM/yyyy HH:mm:ss")</code> изменить формат отображения времени <br />
<code>$Date = Get-Date -f "dd/MM/yyyy"</code> получаем тип данных [string] $($Date.GetType().Name) <br />
<code>$Date = "19.05.2024"</code> <br />
<code>[DateTime]$Date = Get-Date "$Date"</code> преобразовать строку подходящую под формат даты в тип данных [DateTime] <br />
<code>$BeforeDate = Get-Date "12.05.2024"</code> <br />
<code>[int32]$days=$($Date - $BeforeDate).Days</code> посчитать разницу в днях <br />
<code>"5/7/07" -as [DateTime]</code> преобразовать входные данные в тип данных [DateTime]</p>
<h1 id="timespan"><a class="header" href="#timespan">TimeSpan</a></h1>
<p><code>New-TimeSpan -Start $(Get-Date) -End $($(Get-Date).AddMinutes(+1))</code> получить разницу во времени <br />
<code>$TimeZone = (Get-TimeZone).BaseUtcOffset.TotalMinutes</code> получить разницу в минутах от текущего часового пояса относительно UTC 0 <br />
<code>$UnixTime  = (New-TimeSpan -Start (Get-Date "01/01/1970") -End ((Get-Date).AddMinutes(-$tz))).TotalSeconds</code> вычесть минуты для получения UTC 0 <br />
<code>$TimeStamp = ([string]$UnixTime -replace "\..+") + "000000000"</code> получить текущий TimeStamp</p>
<h3 id="format-1"><a class="header" href="#format-1">Format</a></h3>
<pre><code>HH   # Часы в 24-часовом формате (00 до 23)
hh   # Часы в 12-часовом формате (01 до 12)
mm   # Минуты (00 до 59)
ss   # Секунды (00 до 59)
tt   # Десигнатор (AM/PM)
fff  # Миллисекунды (000 до 999)
d    # День месяца без ведущего нуля (1-31)
dd   # День месяца с ведущим нулём (01-31)
ddd  # Сокращённое название дня недели (например, "Пн")
dddd # Полное название дня недели (например, "Понедельник")
M    # Номер месяца без ведущего нуля (1-12)
MM   # Номер месяца с ведущим нулём (01-12)
MMM  # Сокращённое название месяца (например, "Янв")
MMMM # Полное название месяца (например, "Январь")
y    # Год без века (0-99)
yy   # Год без века с ведущим нулём (00-99)
yyyy # Год с веком (например, 2024)
g    # Период или эра (например, "н.э.")
</code></pre>
<h3 id="timer"><a class="header" href="#timer">Timer</a></h3>
<p><code>$start_time = Get-Date</code> зафиксировать время до выполнения команды <br />
<code>$end_time = Get-Date</code> зафиксировать время по завершению <br />
<code>$time = $end_time - $start_time</code> высчитать время работы скрипта <br />
<code>$min = $time.minutes</code> <br />
<code>$sec = $time.seconds</code> <br />
<code>Write-Host "$min минут $sec секунд"</code></p>
<p><code>$timer = [System.Diagnostics.Stopwatch]::StartNew()</code> запустить таймер <br />
<code>$timer.IsRunning</code> статус работы таймера <br />
<code>$timer.Elapsed.TotalSeconds</code> отобразить время с момента запуска (в секундах) <br />
<code>$timer.Stop()</code> остановить таймер</p>
<h1 id="regex"><a class="header" href="#regex">Regex</a></h1>
<pre><code>.       # Обозначает любой символ, кроме новой строки
\       # Экранирует любой специальный символ (метасимвол). Используется, если нужно указать конкретный символ, вместо специального ({ } [ ] / \ + * . $ ^ | ?)
\A (^)  # Начало строки
\Z ($)  # Конец строки
\n      # Новая строка
\s      # Пробел (эквивалент " "), табуляция, перенос строки
\S      # Не пробел
\d      # Число от 0 до 9 (20-07-2022 эквивалент: "\d\d-\d\d-\d\d\d\d")
\D      # Обозначает любой символ, кроме числа (цифры). Удаления всех символов, кроме цифр: [int]$("123 test" -replace "\D")
\w      # Любая буква латиницы, цифра, или знак подчёркивания (от "a" до "z" и от "A" до "Z" или число от 0 до 9)
\W      # Не латиница, не цифра, не подчёркивание
\b      # Граница слова. Применяется когда нужно выделить, что искомые символы являются словом, а не частью другого слова
\B      # Не граница слова
\A      # Начало текста
\Z      # Конец текста
+       # Повторяется 1 и более раз (\s+)
|       # Или. Соединяет несколько вариантов
()      # В круглые скобки заключаются все комбинации с "или" и поиск начала и конца строк
[]      # поиск совпадения любой буквы, например, [A-z0-9] от A до z и цифры от 0 до 9 ("192.168.1.1" -match "192.1[6-7][0-9]")
[^ ]    # Исключает из поиска символы указанные в квадратных скобках
{ }     # Квантификатор в фигурных скобках, указывает количество повторений символа слева на право (от 1 до 25 раз)
\d{2}   # Найти две цифры
\d{2,4} # Найти две или четыре
{4,}    # Найти четыре и более
</code></pre>
<ul>
<li>Якори</li>
</ul>
<p><code>^</code> или <code>\A</code> определяет начало строки. $url -replace '^','https:'<code>добавить в начало; \ </code>$<code>или</code>\Z<code>обозначают конец строки. $ip -replace "\d{1,3}$","0" \ </code>(?=text)<code>поиск слова слева. Пишем слева на право от искомого (ищет только целые словосочетания) "Server:\s(.{1,30})\s(?=$username)" \ </code>(?&lt;=text)<code> поиск слова справа. $in_time -replace ".+(?&lt;=Last)"</code> удалить все до слова Last <br />
<code>(?!text)</code> не совпадает со словом слева <br />
<code>(?&lt;!text)</code> не совпадает со словом справа</p>
<p><code>$test = "string"</code> <br />
<code>$test -replace ".{1}$"</code> удалить любое кол-во символов в конце строки <br />
<code>$test -replace "^.{1}"</code> удалить любое кол-во символов в начале строки \</p>
<ul>
<li>Группы захвата</li>
</ul>
<p><code>$date = '12.31.2021'</code> <br />
<code>$date -replace '^(\d{2}).(\d{2})','$2.$1'</code> поменять местами <br />
<code>$1</code> содержимое первой группы в скобках <br />
<code>$2</code> содержимое второй группы</p>
<p><code>-replace "1","2"</code> замена элементов в индексах массива (везде где присутствует 1, заменить на 2), для удаления используется только первое значение <br />
<code>-split " "</code> преобразовать строку в массив, разделителем указан пробел, которой удаляется ($url.Split("/")[-1]) <br />
<code>-join " "</code> преобразовать массив (коллекцию) в единую строку (string), добавить разделителем пробел</p>
<p><code>@(1,2,3) -contains 3</code> проверить, что элемент справа содержится в массиве слева <br />
<code>@(1,2) -notcontains 3</code> проверить, что элемент справа не содержится в массиве слева</p>
<p><code>-like *txt*</code> поиск по маскам wildcard, выводит значение на экран <br />
<code>-match txt</code> поиска по шаблонам, проверка на соответствие содержимого текста <br />
<code>-match "zabbix|rpc"</code> условия, для поиска по нескольким словам <br />
<code>-NotMatch</code> проверка на отсутствие вхождения \</p>
<ul>
<li>Matches</li>
</ul>
<p><code>"num: 777" -match "num: ([0-9]+)" | Out-Null</code> <br />
<code>$Matches[1]</code> выводим только номер</p>
<p><code>$ip = "192.168.10.1"</code> <br />
<code>$ip -match "(\.\d{1,3})\.\d{1,2}"</code> True <br />
<code>$Matches</code> отобразить все подходящие переменные последнего поиска, которые входят и не входят в группы ()</p>
<p><code>$String = "09/14/2017 12:00:27 - mtbill_post_201709141058.txt 7577_Delivered: OK"</code> <br />
<code>$String -Match ".*(?=\.txt)" | Out-Null</code> <br />
<code>$Matches[0][-4..-1] -Join ""</code></p>
<p><code>$string.Substring($string.IndexOf(".txt")-4, 4)</code> 2-й вариант (IndexOf)</p>
<ul>
<li>Форматирование (.NET method format)</li>
</ul>
<p><code>[string]::Format("{1} {0}","Index0","Index1")</code> <br />
<code>"{1} {0}" -f "Index0","Index1"</code> <br />
<code>"{0:###-##-##}" -f 1234567</code> записать число в другом формате (#) <br />
<code>"{0:0000}" -f 123</code> вывести число в формате не меньше 4 знаков (0123) <br />
<code>"{0:P0}" -f (220/1000)</code> посчитать в процентах (P) <br />
<code>"{0:P}" -f (512MB/1GB)</code> сколько % составляет 512Мб от 1Гб <br />
<code>"{0:0.0%}" -f 0.123</code> умножить на 100%</p>
<pre><code class="language-PowerShell">$gp = Get-Process | sort cpu -Descending | select -First 10
foreach ($p in $gp) {
    "{0} - {1:N2}" -f $p.processname, $p.cpu # округлить
}
</code></pre>
<ul>
<li>Условный оператор</li>
</ul>
<pre><code class="language-PowerShell">$rh = Read-Host
if ($rh -eq 1) {
    ipconfig
} elseif (
    $rh -eq 2
) {
    getmac
} else {
    hostname
}
</code></pre>
<p>Если условие if () является истенным ($True), выполнить действие в {} <br />
Если условие if () является ложным ($False), выполнить действие не обязательного оператора else <br />
Условие Elseif идёт после условия if для проверки дополнительных условий перед выполнение оператора else. Оператор, который первый вернет $True, отменит выполнение следующих дополнительных условий <br />
Если передать переменную в условие без оператора, то будет проверяться наличие значения у переменной на $True/$False \</p>
<pre><code class="language-PowerShell">if ($(Test-NetConnection $srv -Port 80).TcpTestSucceeded) {
    "Opened port"
} else {
    "Closed port"
}
</code></pre>
<ul>
<li>Логические операторы сравнения</li>
</ul>
<p><code>-eq</code> равно (equal) <br />
<code>-ceq</code> учитывать регистр <br />
<code>-ne</code> не равно (not equal) <br />
<code>-cne</code> не равно учитывая регистр <br />
<code>-gt</code> больше (greater) <br />
<code>-ge</code> больше или равно <br />
<code>-lt</code> меньше (less) <br />
<code>-le</code> меньше или равно <br />
<code>-in</code> проверить на наличие (5 -in @(1,2,3,4,5)) <br />
<code>-NOT</code> логическое НЕТ !(Test-Path $path) <br />
<code>-and</code> логическое И <br />
<code>-or</code> логическое ИЛИ \</p>
<pre><code class="language-PowerShell">if ((($1 -eq 1) -and ($2 -eq 2)) -or ($1 -ne 3)) {
    $true
} else {
    $false
} # два условия: (если $1 = 1 И $2 = 2) ИЛИ $1 не равно 3 вернуть $true
</code></pre>
<ul>
<li>Pipeline Operators</li>
</ul>
<p><code>Write-Output "First" &amp;&amp; Write-Output "Second"</code> две успешные команды выполняются <br />
<code>Write-Error "Bad" &amp;&amp; Write-Output "Second"</code> первая команда завершается ошибкой, из-за чего вторая команда не выполняется <br />
<code>Write-Error "Bad" || Write-Output "Second"</code> первая команда завершается ошибкой, поэтому выполняется вторая команда <br />
<code>Write-Output "First" || Write-Output "Second"</code> первая команда выполнена успешно, поэтому вторая команда не выполняется</p>
<ul>
<li>Invocation Operator</li>
</ul>
<p><code>$addr = "8.8.8.8"</code> <br />
<code>$ping = "ping"</code> <br />
<code>&amp; $ping $addr</code> запускает текст как команду</p>
<p><code>&amp; $ping $addr &amp;</code> запустить команду в фоне <br />
<code>(Get-Job)[-1] | Receive-Job -Keep</code></p>
<h1 id="datatype"><a class="header" href="#datatype">DataType</a></h1>
<p><code>$srv.GetType()</code> узнать тип данных <br />
<code>$srv -is [string]</code> проверка на соответствие типа данных <br />
<code>$srv -isnot [System.Object]</code> проверка на несоответствие <br />
<code>[Object]</code> массив (BaseType:System.Array) <br />
<code>[DateTime]</code> формат времени (BaseType:System.ValueType) <br />
<code>[Bool]/[Boolean]</code> логическое значение ($True/$False) или 1/0 (1 бит) наличие/отсуствие напряжения <br />
<code>[Byte]</code> 8-битное (1 байт) целое число без знака (0..255) <br />
<code>[Int16]</code> 16-битное знаковое целое число от -32767 до 32767 (тип данных WORD 0..65535) <br />
<code>[Int]</code> 32-битное (4 байта) знаковое целое число от –2147483648 до 2147483647 (DWORD) <br />
<code>[Int64]</code> 64-битное от -9223372036854775808 до 9223372036854775808 (LWORD) <br />
<code>[Decimal]</code> 128-битное десятичное значение от –79228162514264337593543950335 до 79228162514264337593543950335 <br />
<code>[Single]</code> число с плавающей запятой (32-разрядное) <br />
<code>[Double]</code> число с плавающей запятой с двойной точностью (64-разрядное) <br />
<code>[String]</code> неизменяемая строка символов Юникода фиксированной длины (BaseType:System.Object)</p>
<h3 id="math"><a class="header" href="#math">Math</a></h3>
<p><code>[math] | Get-Member -Static</code> <br />
<code>[math]::Pow(2,4)</code> 2 в 4 степени <br />
<code>[math]::Truncate(1.8)</code> грубое округление, удаляет дробную часть <br />
<code>[math]::Ceiling(1.8)</code> округляет число в большую сторону до ближайшего целого значения <br />
<code>[math]::Floor(-1.8)</code> округляет число в меньшую сторону <br />
<code>[math]::Min(33,22)</code> возвращает наименьшее значение двух значений <br />
<code>[math]::Max(33,22)</code> возвращает наибольшее значение двух значений</p>
<h3 id="round"><a class="header" href="#round">Round</a></h3>
<p><code>[double]::Round(87.5, 0)</code> 88 (нечетное), в .NET по умолчанию используется округление в средней точке ToEven, где *.5 значения округляются до ближайшего четного целого числа <br />
<code>[double]::Round(88.5, 0)</code> 88 (четное) <br />
<code>[double]::Round(88.5, 0, 1)</code> 89 (округлять в большую сторону) <br />
<code>[double]::Round(1234.56789, 2)</code> округлить до 2 символов после запятой</p>
<h3 id="tostring"><a class="header" href="#tostring">ToString</a></h3>
<p><code>(4164539/1MB).ToString("0.00")</code> разделить на дважды на 1024/1024 и округлить до 3,97</p>
<h3 id="char"><a class="header" href="#char">Char</a></h3>
<p><code>[Char]</code> cимвол Юникода (16-разрядный) <br />
<code>$char = $srv.ToCharArray()</code> разбить строку [string] на массив [System.Array] из букв</p>
<h1 id="function"><a class="header" href="#function">Function</a></h1>
<h3 id="switch-function"><a class="header" href="#switch-function">Switch function</a></h3>
<pre><code class="language-PowerShell">$MMM = Get-Date -UFormat "%m"
switch($MMM) {
    "01" {$Month = 'Jan'}
    "02" {$Month = 'Feb'}
    "03" {$Month = 'Mar'}
    "04" {$Month = 'Apr'}
    "05" {$Month = 'May'}
    "06" {$Month = 'Jun'}
    "07" {$Month = 'Jul'}
    "08" {$Month = 'Aug'}
    "09" {$Month = 'Sep'}
    "10" {$Month = 'Oct'}
    "11" {$Month = 'Nov'}
    "12" {$Month = 'Dec'}
}
</code></pre>
<h3 id="switch-param"><a class="header" href="#switch-param">Switch param</a></h3>
<pre><code class="language-PowerShell">Function fun-switch (
    [switch]$param
) {
    If ($param) {"yes"} else {"no"}
}
</code></pre>
<p><code>fun-switch -param</code></p>
<h3 id="psm1-module-file-and-parameters"><a class="header" href="#psm1-module-file-and-parameters">psm1 (module file and parameters)</a></h3>
<pre><code class="language-PowerShell">function Get-Function {
    &lt;#
    .SYNOPSIS
    Описание
    .DESCRIPTION
    Описание
    .LINK
    https://github.com/Lifailon/PS-Commands
    #&gt;
    param (
        [Parameter(Mandatory,ValueFromPipeline)][string]$Text,
        [ValidateSet("Test1","Test2")][string]$Provider = "Test1",
        [ValidateRange(1,3)][int]$Number = 2
    )
    Write-Host Param Text: $Text
    Write-Host Param Provider: $Provider
    Write-Host Param Number: $Number
}
</code></pre>
<p><code>Get-Function -Text Text1</code> <br />
<code>Get-Function -Text Text2 -Provider Test2 -Number 3</code></p>
<h3 id="psd1-module-description-file"><a class="header" href="#psd1-module-description-file">psd1 (module description file)</a></h3>
<pre><code class="language-PowerShell">@{
    RootModule        = "Get-Function.psm1"
    ModuleVersion     = "0.1"
    Author            = "Lifailon"
    CompanyName       = "Open Source Community"
    Copyright         = "Apache-2.0"
    Description       = "Function example"
    PowerShellVersion = "7.2"
    PrivateData       = @{
        PSData = @{
            Tags         = @("Function","Example")
            ProjectUri   = "https://github.com/Lifailon/PS-Commands"
            LicenseUri   = "https://github.com/Lifailon/Console-Translate/blob/rsa/LICENSE"
            ReleaseNotes = "Second release"
        }
    }
}
</code></pre>
<h1 id="bit"><a class="header" href="#bit">Bit</a></h1>
<pre><code>Двоичное    Десятичное
1           1
10          2
11          3
100         4
101         5
110         6
111         7
1000        8
1001        9
1010        10
1011        11
1100        12
1101        13
1110        14
1111        15
1 0000      16

Двоичное    Десятичное  Номер разряда
1           1           0
10          2           1
100         4           2
1000        8           3
1 0000      16          4
10 0000     32          5
100 0000    64          6
1000 0000   128         7
1 0000 0000 256         8

Из двоичного =&gt; десятичное (1-й вариант по таблице)
1001 0011 = 1000 0000 + 1 0000 + 10 + 1 = 128 + 16 + 2 + 1 = 147

2-й вариант
7654 3210 (разряды двоичного выражения) = (1*2^7)+(0*2^6)+(0*2^5)+(1*2^4)+(0*2^3)+(0*2^2)+(1*2^1)+(1*2^0) = 147
[math]::Pow(2,7) + [math]::Pow(2,4) + [math]::Pow(2,1) + [math]::Pow(2,0) = 147` исключить 0 и сложить степень

Из десятичного =&gt; двоичное (1-й вариант по таблице)
347 вычесть ближайшие 256 = 91 (+ 1 0000 0000 забрать двоичный остаток)
91  - 64  = 27 ближайшее 16 (+ 100 0000)
27  - 16  = 11 ближайшее 8 (+ 1 0000)
11  - 8   = 3  ближайшее 2 (+ 1000)
3   - 2   = 1 (+ 10)
1   - 1   = 0 (+ 1)
1 0101 1011

2-й вариант
Последовательное деления числа на 2, предворительно забирая остаток для получения четного числа в меньшую сторону
347 - 346 = остаток 1, (347-1)/2 = 173
173 - 172 = остаток 1, (172-1)/2 = 86
86  - 86  = остаток 0, 86/2 = 43
43  - 42  = остаток 1, (43-1)/2 = 21
21  - 20  = остаток 1, (21-1)/2 = 10
10  - 10  = остаток 0, 10/2 = 5
5   - 4   = остаток 1, (5-1)/2 = 2
2   - 2   = остаток 0, 2/2 = 1
1   - 2   = остаток 1, (1-1)/2 = 0
Результат деления записывается снизу вверх
</code></pre>
<h3 id="bit-convertor"><a class="header" href="#bit-convertor">Bit Convertor</a></h3>
<pre><code class="language-PowerShell">function ConvertTo-Bit {
    param (
        [Int]$int
    )
    [array]$bits = @()
    $test = $true
    while ($test -eq $true) {
        if (($int/2).GetType() -match [double]) {
            $int = ($int-1)/2
            [array]$bits += 1
        }
        elseif (($int/2).GetType() -match [int]) {
            $int = $int/2
            [array]$bits += 0
        }
        if ($int -eq 0) {
            $test = $false
        }
    }
    $bits =  $bits[-1..-999]
    ([string]($bits)) -replace "\s"
}
</code></pre>
<p><code>ConvertTo-Bit 347</code></p>
<pre><code class="language-PowerShell">function ConvertFrom-Bit {
    param (
        $bit
    )
    [int]$int = 0
    $bits = $bit.ToString().ToCharArray()
    $index = ($bits.Count)-1
    foreach ($b in $bits) {
        if ($b -notlike 0) {
            $int += [math]::Pow(2,$index)
        }
    $index -= 1
    }
    $int
}
</code></pre>
<p><code>ConvertFrom-Bit 10010011</code></p>
<p><code>Get-Process pwsh | fl ProcessorAffinity</code> привязка процесса к ядрам, представляет из себя битовую маску (bitmask), где каждому биту соответствует ядро процессора. Если для ядра отмечено сходство (affinity), то бит выставляется в 1, если нет — то в 0. Например, если выбраны все 16 ядер, то это 1111 1111 1111 1111 или 65535. <br />
<code>$(Get-Process pwsh).ProcessorAffinity = 15</code> 0000000000001111 присвоить 4 первых ядра <br />
<code>$(Get-Process pwsh).ProcessorAffinity = 61440</code> 1111000000000000 присвоить 4 последних ядра <br />
<code>$(Get-Process pwsh).ProcessorAffinity = (ConvertFrom-Bit 1111000000000000)</code></p>
<h1 id="cycle"><a class="header" href="#cycle">Cycle</a></h1>
<h3 id="foreach"><a class="header" href="#foreach">Foreach</a></h3>
<p><code>$list = 100..110</code> создать массив из цифр от 100 до 110 <br />
<code>foreach ($srv in $list) {ping 192.168.3.$srv -n 1 -w 50}</code> $srv хранит текущий элемент из $list и повторяет команду до последнего элемента в массиве <br />
<code>$foreach.Current</code> текущий элемент в цикле <br />
<code>$foreach.Reset()</code> обнуляет итерацию, перебор начнется заново, что приводит к бесконечному циклу <br />
<code>$foreach.MoveNext()</code> переход к следующему элементу в цикле</p>
<h3 id="foreach-object"><a class="header" href="#foreach-object">ForEach-Object</a></h3>
<pre><code class="language-PowerShell">100..110 | %{
    ping -n 1 -w 50 192.168.3.$_ &gt; $null
    if ($LastExitCode -eq 0) {
        Write-Host "192.168.3.$_" -ForegroundColor green
    } else {
    Write-Host "192.168.3.$_"-ForegroundColor Red
    }
}
</code></pre>
<p><code>% </code> передать цикл через конвеер (ForEach-Object) <br />
<code>$_</code> переменная цикла и конвеера ($PSItem) <br />
<code>gwmi Win32_QuickFixEngineering | where {$_.InstalledOn.ToString() -match "2022"} | %{($_.HotFixID.Substring(2))}</code> gwmi создает массив, вывод команды передается where для поиска подходящих под критерии объектов. По конвееру передается в цикл для удаления первых (2) символов методом Substring из всех объектов HotFixID.</p>
<h3 id="while"><a class="header" href="#while">While</a></h3>
<pre><code class="language-PowerShell">$srv = "yandex.ru"
$out2 = "Есть пинг"
$out3 = "Нет пинга"
$out = $false # предварительно сбросить переменную, While проверяет условие до запуска цикла
While ($out -eq $false) { # пока условие является $true, цикл будет повторяться
    $out = ping -n 1 -w 50 $srv
    if ($out -match "ttl") {$out = $true; $out2} else {$out = $false; $out3; sleep 1}
}

while ($True) { # запустить бесконечный цикл
    $result = ping yandex.ru -n 1 -w 50
    if ($result -match "TTL") { # условие, при котором будет выполнен break
        Write-Host "Сайт доступен"
        break # остановит цикл
    } else {
        Write-Host "Сайт недоступен"; sleep 1
    }
}
</code></pre>
<h3 id="try-catch-finally"><a class="header" href="#try-catch-finally">Try-Catch-Finally</a></h3>
<pre><code class="language-PowerShell">Try {$out = pping 192.168.3.1}
Catch {Write-Warning "$($error[0])"} # выводит в случае ошибки (вместо ошибки)
finally {$out = "End"} # выполняется в конце в любом случае
</code></pre>
<h1 id="files"><a class="header" href="#files">Files</a></h1>
<p><code>Get-Content $home/desktop\test.txt -Wait</code> аналог tail <br />
<code>Test-Path $path</code> проверить доступность пути <br />
<code>Get-FileHash -Algorithm SHA256 "$path"</code> узнать хэш файла по алгоритму sha256 <br />
<code>Get-ChildItem $path -Filter *.txt -Recurse</code> отобразить содержимое каталога (Alias: ls/gci/dir) и дочерних каталогов (-Recurse) и отфильтровать вывод <br />
<code>Get-Location</code> отобразить текущие месторасположение (Alias: pwd/gl) <br />
<code>Set-Location $path</code> перемещение по каталогам (Alias: cd/sl) <br />
<code>Invoke-Item $path</code> открыть файл (Alias: ii/start) <br />
<code>Get-ItemProperty $env:userprofile\Documents\dns-list.txt | select FullName,Directory,Name,BaseName,Extension</code> свойтсва файла <br />
<code>Get-ItemProperty -Path $path\* | select FullName,CreationTime,LastWriteTime</code> свойства файлов содержимого директории, дата их создания и последнего изменения <br />
<code>New-Item -Path "C:\test\" -ItemType "Directory"</code> создать директорию (Alias: mkdir/md) <br />
<code>New-Item -Path "C:\test\file.txt" -ItemType "File" -Value "Добавить текст в файл"</code> создать файл <br />
<code>"test" &gt; "C:\test\file.txt"</code> заменить содержимое <br />
<code>"test" &gt;&gt; "C:\test\file.txt"</code> добавить строку в файл <br />
<code>New-Item -Path "C:\test\test\file.txt" -Force</code> ключ используется для создания отсутствующих в пути директорий или перезаписи файла если он уже существует <br />
<code>Move-Item</code> перемещение объектов (Alias: mv/move) <br />
<code>Remove-Item "$path\" -Recurse</code> удаление всех файлов внутри каталога, без запроса подверждения (Alias: rm/del) <br />
<code>Remove-Item $path -Recurse -Include "*.txt","*.temp" -Exclude "log.txt"</code> удалить все файлы с расширением txt и temp ([Array]), кроме log.txt <br />
<code>Rename-Item "C:\test\*.*" "*.jpg"</code> переименовать файлы по маске (Alias: ren) <br />
<code>Copy-Item</code> копирование файлов и каталогов (Alias: cp/copy) <br />
<code>Copy-Item -Path "\\server-01\test" -Destination "C:\" -Recurse</code> копировать директорию с ее содержимым (-Recurse) <br />
<code>Copy-Item -Path "C:\*.txt" -Destination "C:\test\"</code> знак '' в конце Destination используется для переноса папки внутрь указанной, отсутствие, что это новое имя директории <br />
<code>Copy-Item -Path "C:\*" -Destination "C:\test\" -Include '*.txt','*.jpg'</code> копировать объекты с указанным расширением (Include) <br />
<code>Copy-Item -Path "C:\*" -Destination "C:\test\" -Exclude '*.jpeg'</code> копировать объекты, за исключением файлов с расширением (Exclude) <br />
<code>$log = Copy-Item "C:\*.txt" "C:\test\" -PassThru</code> вывести результат копирования (логирование) в переменную, можно забирать строки с помощью индексов $log[0].FullName <br />
<code>Unblock-File "script.ps1"</code> разблокирует файлы скриптов PowerShell скачанных из Интернета, чтобы их можно было запустить, даже если политика выполнения PowerShell в режиме RemoteSigned</p>
<h3 id="clear-env-temp-14-days"><a class="header" href="#clear-env-temp-14-days">Clear-env-Temp-14-days</a></h3>
<pre><code class="language-PowerShell">$ls = Get-Item $env:TEMP\*.tmp # считать все файлы с указанным расширением
$date = (Get-Date).AddDays(-14)
foreach ($l in $ls) {
    if ($l.LastWriteTime -le $date) {
        $l.FullName
        Remove-Item $l.FullName -Recurse
    }
}
</code></pre>
<h3 id="system-io-file"><a class="header" href="#system-io-file">System IO File</a></h3>
<p><code>$file = [System.IO.File]::Create("$home\desktop\test.txt")</code> создать файл <br />
<code>$file.Close()</code> закрыть файл <br />
<code>[System.IO.File]::ReadAllLines("$home\desktop\test.txt")</code> прочитать файл <br />
<code>$file = New-Object System.IO.StreamReader("$home\desktop\test.txt")</code> файл будет занят процессом PowerShell <br />
<code>$file | Get-Member</code> <br />
<code>$file.ReadLine()</code> построчный вывод <br />
<code>$file.ReadToEnd()</code> прочитать файл целиком</p>
<h3 id="read-and-write-bytes"><a class="header" href="#read-and-write-bytes">Read and Write Bytes</a></h3>
<p><code>$file = [io.file]::ReadAllBytes("$home\desktop\powershell.jpg")</code> метод открывает двоичный файл, считывает его в массив байт и закрывает файл <br />
<code>[io.file]::WriteAllBytes("$home\desktop\tloztotk-2.jpg",$file)</code> сохранить байты в файл (можно использовать для выгрузки двоичных файлов из БД)</p>
<h1 id="archive"><a class="header" href="#archive">Archive</a></h1>
<h3 id="microsoft-powershell-archive"><a class="header" href="#microsoft-powershell-archive">Microsoft PowerShell Archive</a></h3>
<p><code>Compress-Archive -Path $srcPath -DestinationPath "$($srcPath).zip" -CompressionLevel Optimal</code> архивировать (по исходному пути и названию с добавлением расширения) <br />
<code>Expand-Archive -Path $zip</code> разархивировать <br />
<code>Expand-Archive -Path $zip -DestinationPath $dstPath</code> указать путь извлечения <br />
<code>Expand-Archive -Path $zip -OutputPath $dstPath</code></p>
<h3 id="system-io-compression-filesystem"><a class="header" href="#system-io-compression-filesystem">System IO Compression FileSystem</a></h3>
<pre><code class="language-PowerShell">function Expand-ArchiveFile {
    param (
        # Путь к архиву
        $Path,
        # Путь, куда извлечь файл
        $DestinationPath,
        # Имя файла, который нужно извлечь
        $FileName
    )
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    try {
        # Открыть архив для чтения
        $zipArchive = [System.IO.Compression.ZipFile]::OpenRead($Path)
        # Найти файл в архиве
        $fileEntry = $zipArchive.Entries | Where-Object { $_.FullName -eq $fileName }
        if ($fileEntry) {
            # Создание потока для чтения содержимого файла
            $stream = $fileEntry.Open()
            # Создание файла и запись в него данных из потока
            $DestinationPathFileName = "$DestinationPath\$FileName"
            $fileStream = [System.IO.File]::Create($DestinationPathFileName)
            $stream.CopyTo($fileStream)
            # Закрытие потоков
            $stream.Close()
            $fileStream.Close()
        } else {
            Write-Output "Файл $fileName не найден в архиве"
        }
    } catch {
        Write-Error "Ошибка при извлечении файла из архива"
    } finally {
        # Закрыть архив
        $zipArchive.Dispose()
    }
}
</code></pre>
<h3 id="winrar"><a class="header" href="#winrar">WinRAR</a></h3>
<pre><code class="language-PowerShell">function Expand-ArchivePassword {
    param (
        $Path,
        $Password
    )
    $winrar =  "C:\Program Files\WinRAR\WinRAR.exe"
    &amp; $winrar x -p"$Password" $Path
}
</code></pre>
<p><code>cd "$home\Downloads"</code> <br />
<code>Expand-ArchivePassword archive.rar qwe123</code></p>
<h1 id="handles"><a class="header" href="#handles">Handles</a></h1>
<p><code>$url = "https://download.sysinternals.com/files/Handle.zip"</code> <br />
<code>Invoke-RestMethod $url -OutFile "$env:TEMP\handle.zip"</code> <br />
<code>Expand-ArchiveFile -Path "$env:TEMP\handle.zip" -DestinationPath "$home\Documents" -FileName "handle.exe"</code> извлекаем выбранный файл из архива <br />
<code>Remove-Item "$env:TEMP\handle.zip"</code> <br />
<code>$handle = "$home\Documents\handle.exe"</code> <br />
<code>$test = New-Object System.IO.StreamReader("$home\desktop\test.txt")</code> занять файл текущим процессом pwsh ($pid) <br />
<code>$SearchProcess = &amp; $handle "C:\Users\Lifailon\Desktop\test.txt" -nobanner -u -v | ConvertFrom-Csv</code> вывести список дескрипторов по пути к файлу (имя процесса, его PID и пользователь который запустил) <br />
<code>Stop-Process $SearchProcess.PID</code> завершить процесс, который удерживал файл</p>
<h1 id="console-menu"><a class="header" href="#console-menu">Console-Menu</a></h1>
<pre><code class="language-PowerShell"># Импортируем модуль PS-Menu в текущую сессию из репозитория GitHub
$module = "https://raw.githubusercontent.com/chrisseroka/ps-menu/master/ps-menu.psm1"
Invoke-Expression $(Invoke-RestMethod $module)
</code></pre>
<p>Пример навигации по директориям в системе используя меню:</p>
<pre><code class="language-PowerShell">function ls-menu {
  param (
    $startDir = "C:\"
  )
  clear
  # Проверяем, что мы не находимся в root директории (исключить возврат назад)
  if ([System.IO.Path]::GetPathRoot($startDir) -eq $startDir) {
    $select = menu @(
      @($(Get-ChildItem $startDir).name)
    )
  }
  else {
    $select = menu @(
      @("..")+@($(Get-ChildItem $startDir).name)
    )
  }
  # Если выбрали возврат назад, то забираем только путь у стартовой директории
  if ($select -eq "..") {
    $backPath = [System.IO.Path]::GetDirectoryName($startDir)
    ls-menu $backPath
  }
  else {
    # Проверяем, что выбрали директорию
    if ($(Test-Path "$startDir\$select" -PathType Container)) {
      # Если выбрали директорию, к стартовому пути добавляем выбранное имя директории
      ls-menu "$startDir\$select"
    }
    else {
      ls-menu $startDir
    }
  }
}
</code></pre>
<p><code>ls-menu</code> <br />
<code>ls-menu $home</code> <br />
<code>ls-menu "D:\"</code></p>
<h1 id="credential"><a class="header" href="#credential">Credential</a></h1>
<p><code>$Cred = Get-Credential</code> сохраняет креды в переменные <code>$Cred.Username</code> и <code>$Cred.Password</code> <br />
<code>$Cred.GetNetworkCredential().password</code> извлечь пароль <br />
<code>cmdkey /generic:"TERMSRV/$srv" /user:"$username" /pass:"$password"</code> добавить указанные креды аудентификации на на терминальный сервер для подключения без пароля <br />
<code>mstsc /admin /v:$srv</code> авторизоваться <br />
<code>cmdkey /delete:"TERMSRV/$srv"</code> удалить добавленные креды аудентификации из системы <br />
<code>rundll32.exe keymgr.dll,KRShowKeyMgr</code> хранилище Stored User Names and Password <br />
<code>Get-Service VaultSvc</code> служба для работы Credential Manager <br />
<code>Install-Module CredentialManager</code> установить модуль управления Credential Manager к хранилищу PasswordVault из PowerShell <br />
<code>[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]'Tls11,Tls12'</code> для устаноки модуля <br />
<code>Get-StoredCredential</code> получить учетные данные из хранилища Windows Vault <br />
<code>Get-StrongPassword</code> генератор пароля <br />
<code>New-StoredCredential -UserName test -Password "123456"</code> добавить учетную запись <br />
<code>Remove-StoredCredential</code> удалить учетную запись <br />
<code>$Cred = Get-StoredCredential | where {$_.username -match "admin"}</code> <br />
<code>$pass = $cred.password</code> <br />
<code>$BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($pass)</code> <br />
<code>[System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)</code></p>
<h3 id="out-gridview"><a class="header" href="#out-gridview">Out-Gridview</a></h3>
<p><code>Get-Service -cn $srv | Out-GridView -Title "Service $srv" -OutputMode Single –PassThru | Restart-Service</code> перезапустить выбранную службу</p>
<h3 id="out-file"><a class="header" href="#out-file">Out-File</a></h3>
<p><code>Read-Host –AsSecureString | ConvertFrom-SecureString | Out-File "$env:userprofile\desktop\password.txt"</code> писать в файл. Преобразовать пароль в формат SecureString с использованием шифрования Windows Data Protection API (DPAPI)</p>
<h3 id="get-content"><a class="header" href="#get-content">Get-Content</a></h3>
<p><code>$password = gc "$env:userprofile\desktop\password.txt" | ConvertTo-SecureString</code> читать хэш пароля из файла с помощью ключей, хранящихся в профиле текущего пользователя, который невозможно прочитать на другом копьютере</p>
<h3 id="aes-key"><a class="header" href="#aes-key">AES Key</a></h3>
<p><code>$AESKey = New-Object Byte[] 32</code> <br />
<code>[Security.Cryptography.RNGCryptoServiceProvider]::Create().GetBytes($AESKey)</code> <br />
<code>$AESKey | Out-File "C:\password.key"</code> <br />
<code>$Cred.Password | ConvertFrom-SecureString -Key (Get-Content "C:\password.key") | Set-Content "C:\password.txt"</code> сохранить пароль в файл используя внешний ключ <br />
<code>$pass = Get-Content "C:\password.txt" | ConvertTo-SecureString -Key (Get-Content "\\Server\Share\password.key")</code> расшифровать пароль на втором компьютере</p>
<h1 id="winevent"><a class="header" href="#winevent">WinEvent</a></h1>
<p><code>Get-WinEvent -ListLog *</code> отобразить все доступные журналы логов <br />
<code>Get-WinEvent -ListLog * | where RecordCount -ne 0 | where RecordCount -ne $null | sort -Descending RecordCount</code> отобразить не пустые журналы с сортировкой по кол-ву записей <br />
<code>Get-WinEvent -ListProvider * | ft</code> отобразить всех провайдеров приложений <br />
<code>Get-WinEvent -ListProvider GroupPolicy</code> найти в какой журнал LogLinks {Application} пишутся логи приложения <br />
<code>Get-WinEvent -ListProvider *smb*</code> <br />
<code>Get-WinEvent -ListLog * | where logname -match SMB | sort -Descending RecordCount</code> найти все журналы по имени <br />
<code>Get-WinEvent -LogName "Microsoft-Windows-SmbClient/Connectivity"</code> <br />
<code>Get-WinEvent -ListProvider *firewall*</code></p>
<h3 id="xpath"><a class="header" href="#xpath">XPath</a></h3>
<p><code>Get-WinEvent -FilterHashtable @{LogName="Security";ID=4624}</code> найти логи по ID в журнале Security <br />
<code>Get-WinEvent -FilterHashtable @{LogName="System";Level=2}</code> найти все записи ошибки (1 - критический, 3 - предупреждение, 4 - сведения) <br />
<code>Get-WinEvent -FilterHashtable @{LogName="System";Level=2;ProviderName="Service Control Manager"}</code> отфильтровать по имени провайдера</p>
<p><code>([xml](Get-WinEvent -FilterHashtable @{LogName="Security";ID=4688} -MaxEvents 1).ToXml()).Event.EventData.Data</code> отобразить все свойства, хранимые в EventData (Message) <br />
<code>Get-WinEvent -FilterHashtable @{logname="security";ID=4688} -MaxEvents 1 | select timecreated,{$_.Properties[5].value}</code> отфильтровать время события и имя запущенного процесса</p>
<pre><code>$query = '
&lt;QueryList&gt;
    &lt;Query Id="0" Path="Security"&gt;
        &lt;Select Path="Security"&gt;
        *[System[EventID=4688]] and 
            *[EventData[Data[@Name="NewProcessName"]="C:\Windows\System32\autochk.exe" or Data[@Name="NewProcessName"]="C:\Windows\System32\services.exe"]]
        &lt;/Select&gt;
    &lt;/Query&gt;
&lt;/QueryList&gt;
'

Get-WinEvent -LogName Security -FilterXPath $query
</code></pre>
<h3 id="reboot"><a class="header" href="#reboot">Reboot</a></h3>
<pre><code>$query = '
&lt;QueryList&gt;
    &lt;Query Id="0" Path="System"&gt;
        &lt;Select Path="System"&gt;
        *[
      System[
      EventID=41 or
      EventID=1074 or
      EventID=1076 or
      EventID=6005 or
      EventID=6006 or
      EventID=6008 or
      EventID=6009 or
      EventID=6013
      ]
      ]
        &lt;/Select&gt;
    &lt;/Query&gt;
&lt;/QueryList&gt;
'
Get-WinEvent -LogName System -FilterXPath $query

41  ` Система была перезагружена без корректного завершения работы.
1074` Система была корректного выключена пользователем или процессом.
1076` Следует за Event ID 6008 и означает, что первый пользователь (с правом выключения системы) подключившийся к серверу после неожиданной перезагрузки или выключения, указал причину этого события.
6005` Запуск "Журнала событий Windows" (Event Log). Указывает на включение системы.
6006` Остановка «Журнала событий Windows». Указывает на выключение системы.
6008` Предыдущее выключение системы было неожиданным.
6009` Версия операционной системы, зафиксированная при загрузке системы.
6013` Время работы системы (system uptime) в секундах.
</code></pre>
<h3 id="logon"><a class="header" href="#logon">Logon</a></h3>
<pre><code class="language-PowerShell">$srv = "localhost"
$FilterXPath = '&lt;QueryList&gt;&lt;Query Id="0"&gt;&lt;Select&gt;*[System[EventID=21]]&lt;/Select&gt;&lt;/Query&gt;&lt;/QueryList&gt;'
$RDPAuths = Get-WinEvent -ComputerName $srv -LogName "Microsoft-Windows-TerminalServices-LocalSessionManager/Operational" -FilterXPath $FilterXPath
[xml[]]$xml = $RDPAuths | Foreach {$_.ToXml()}
$EventData = Foreach ($event in $xml.Event) {
    New-Object PSObject -Property @{
        "Connection Time" = (Get-Date ($event.System.TimeCreated.SystemTime) -Format 'yyyy-MM-dd hh:mm K')
        "User Name" = $event.UserData.EventXML.User
        "User ID" = $event.UserData.EventXML.SessionID
        "User Address" = $event.UserData.EventXML.Address
        "Event ID" = $event.System.EventID
    }
}
$EventData | ft
</code></pre>
<h3 id="eventlog"><a class="header" href="#eventlog">EventLog</a></h3>
<p><code>Get-EventLog -List</code> отобразить все корневые журналы логов и их размер <br />
<code>Clear-EventLog Application</code> очистить логи указанного журнала <br />
<code>Get-EventLog -LogName Security -InstanceId 4624</code> найти логи по ID в журнале Security</p>
<h1 id="firewall"><a class="header" href="#firewall">Firewall</a></h1>
<pre><code class="language-PowerShell">$days = 5
$obj = @()
$fw = Get-WinEvent "Microsoft-Windows-Windows Firewall With Advanced Security/Firewall"
foreach ($temp_fw in $fw) {
if ($temp_fw.id -eq 2097) { # 2004
    $type = "Added Rule"
}
elseif ($temp_fw.id -eq 2006) {
    $type = "Deleted Rule"
}
$port = $temp_fw.Properties[7] | select -ExpandProperty value
$name = $temp_fw.Properties[1] | select -ExpandProperty value
$obj += [PSCustomObject]@{
    Time = $temp_fw.TimeCreated;
    Type = $type;
    Port = $port;
    Name = $name}
}
$obj | Where-Object time -gt (Get-Date).AddDays(-$days)
</code></pre>
<p><code>New-NetFirewallRule -Profile Any -DisplayName "Open Port 135 RPC" -Direction Inbound -Protocol TCP -LocalPort 135</code> открыть in-порт <br />
<code>Get-NetFirewallRule | where DisplayName -match kms | select *</code> найти правило по имени <br />
<code>Get-NetFirewallPortFilter | where LocalPort -like 80</code> найти действующие правило по номеру порта</p>
<pre><code class="language-PowerShell">Get-NetFirewallRule -Enabled True -Direction Inbound | select -Property DisplayName,
@{Name='Protocol';Expression={($_ | Get-NetFirewallPortFilter).Protocol}},
@{Name='LocalPort';Expression={($_ | Get-NetFirewallPortFilter).LocalPort}},
@{Name='RemotePort';Expression={($_ | Get-NetFirewallPortFilter).RemotePort}},
@{Name='RemoteAddress';Expression={($_ | Get-NetFirewallAddressFilter).RemoteAddress}},
Enabled,Profile
</code></pre>
<h3 id="firewall-manager"><a class="header" href="#firewall-manager">Firewall-Manager</a></h3>
<p><code>Install-Module Firewall-Manager</code> <br />
<code>Export-FirewallRules -Name * -CSVFile $home\documents\fw.csv</code> -Inbound -Outbound -Enabled -Disabled -Allow -Block (фильтр правил для экспорта) <br />
<code>Import-FirewallRules -CSVFile $home\documents\fw.csv</code></p>
<h1 id="defender"><a class="header" href="#defender">Defender</a></h1>
<p><code>Import-Module Defender</code> <br />
<code>Get-Command -Module Defender</code> <br />
<code>Get-MpComputerStatus</code> <br />
<code>(Get-MpComputerStatus).AntivirusEnabled</code> статус работы антивируса</p>
<p><code>$session = NewCimSession -ComputerName hostname</code> подключиться к удаленному компьютеру, используется WinRM <br />
<code>Get-MpComputerStatus -CimSession $session | fl fullscan*</code> узнать дату последнего сканирования на удаленном компьютере</p>
<p><code>Get-MpPreference</code> настройки <br />
<code>(Get-MpPreference).ScanPurgeItemsAfterDelay</code> время хранения записей журнала защитника в днях <br />
<code>Set-MpPreference -ScanPurgeItemsAfterDelay 30</code> изменить время хранения <br />
<code>ls "C:\ProgramData\Microsoft\Windows Defender\Scans\History"</code> <br />
<code>Get-MpPreference | select disable*</code> отобразить статус всех видов проверок/сканирований <br />
<code>Set-MpPreference -DisableRealtimeMonitoring $true</code> отключить защиту Defender в реальном времени (использовать только ручное сканирование) <br />
<code>Set-MpPreference -DisableRemovableDriveScanning $false</code> включить сканирование USB накопителей <br />
<code>Get-MpPreference | select excl*</code> отобразить список всех исключений <br />
<code>(Get-MpPreference).ExclusionPath</code> <br />
<code>Add-MpPreference -ExclusionPath C:\install</code> добавить директорию в исключение <br />
<code>Remove-MpPreference -ExclusionPath C:\install</code> удалить из исключения <br />
<code>New-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender" -Name DisableAntiSpyware -Value 1 -PropertyType DWORD -Force</code> полностью отключить Windows Defender</p>
<p><code>Set-MpPreference -SignatureDefinitionUpdateFileSharesSources \\FileShare1\Updates</code> для обновления из сетевой папки нужно предварительно скачать файлы с сигнатурами баз с сайта https://www.microsoft.com/security/portal/definitions/adl.aspx и поместить в сетевой каталог
<code>Update-MpSignature -UpdateSource FileShares</code> изменить источник обновлений (MicrosoftUpdateServer – сервера обновлений MS в интернете, InternalDefinitionUpdateServer — внутренний WSUS сервер) <br />
<code>Update-MpSignature</code> обновить сигнатуры</p>
<p><code>Start-MpScan -ScanType QuickScan</code> быстрая проверка или FullScan <br />
<code>Start-MpScan -ScanType FullScan -AsJob</code> <br />
<code>Set-MpPreference -RemediationScheduleDay 1-7</code> выбрать дни, начиная с воскресенья или 0 каждый день, 8 - сбросить <br />
<code>Set-MpPreference -ScanScheduleQuickScanTime 14:00:00</code> <br />
<code>Start-MpScan -ScanType CustomScan -ScanPath "C:\Program Files"</code> сканировать выбранную директорию</p>
<p><code>Get-MpThreat</code> история угроз и тип угрозы (ThreatName: HackTool/Trojan) <br />
<code>Get-MpThreatCatalog</code> список известных видов угроз <br />
<code>Get-MpThreatDetection</code> история защиты (активных и прошлые) и ID угрозы <br />
<code>Get-MpThreat -ThreatID 2147760253</code></p>
<p><code>ls "C:\ProgramData\Microsoft\Windows Defender\Quarantine\"</code> директория хранения файлов в карантине <br />
<code>cd "C:\Program Files\Windows Defender\"</code> <br />
<code>.\MpCmdRun.exe -restore -name $ThreatName</code> восстановить файл из карантина <br />
<code>.\MpCmdRun.exe -restore -filepath $path_file</code></p>
<h1 id="dism"><a class="header" href="#dism">DISM</a></h1>
<p><code>Get-Command -Module Dism -Name *Driver*</code> <br />
<code>Export-WindowsDriver -Online -Destination C:\Users\Lifailon\Documents\Drivers\</code> извлечение драйверов из текущей системы (C:\Windows\System32\DriverStore\FileRepository), выгружает список файлов, которые необходимы для установки драйвера (dll,sys,exe) в соответствии со списком файлов, указанных в секции [CopyFiles] inf-файла драйвера. <br />
<code>Export-WindowsDriver -Path C:\win_image -Destination C:\drivers</code> извлечь драйвера из офлайн образа Windows, смонтированного в каталог c:\win_image <br />
<code>$BackupDrivers = Export-WindowsDriver -Online -Destination C:\Drivers</code> <br />
<code>$BackupDrivers | ft Driver,ClassName,ProviderName,Date,Version,ClassDescription</code> список драйверов в объектном представлении <br />
<code>$BackupDrivers | where classname -match printer</code> <br />
<code>pnputil.exe /add-driver C:\drivers\*.inf /subdirs /install</code> установить все (параметр subdirs) драйвера из указанной папки (включая вложенные)</p>
<p><code>sfc /scannow</code> проверить целостность системных файлов с помощью утилиты SFC (System File Checker), в случае поиска ошибок, попробует восстановить их оригинальные копии из хранилища системных компонентов Windows (каталог C:\Windows\WinSxS). Вывод работы логируется в C:\Windows\Logs\CBS с тегом SR <br />
<code>Get-ComputerInfo | select *</code> подробная информация о системе (WindowsVersion,WindowsEditionId,<em>Bios</em>) <br />
<code>Get-WindowsImage -ImagePath E:\sources\install.wim</code> список доступных версий в образе <br />
<code>Repair-WindowsImage -Online –ScanHealth</code> <br />
<code>Repair-WindowsImage -Online -RestoreHealth</code> восстановление хранилища системных компонентов <br />
<code>Repair-WindowsImage -Online -RestoreHealth -Source E:\sources\install.wim:3 –LimitAccess</code> восстановление в оффлайн режиме из образа по номеру индекса</p>
<h1 id="scheduled"><a class="header" href="#scheduled">Scheduled</a></h1>
<p><code>$Trigger = New-ScheduledTaskTrigger -At 01:00am -Daily</code> 1:00 ночи <br />
<code>$Trigger = New-ScheduledTaskTrigger –AtLogon</code> запуск при входе пользователя в систему <br />
<code>$Trigger = New-ScheduledTaskTrigger -AtStartup</code> при запуске системы <br />
<code>$User = "NT AUTHORITY\SYSTEM"</code> <br />
<code>$Action = New-ScheduledTaskAction -Execute "PowerShell.exe" -Argument "$home\Documents\DNS-Change-Tray-1.3.ps1"</code> <br />
<code>$Action = New-ScheduledTaskAction -Execute "PowerShell.exe" -Argument "-NoProfile -NoLogo -NonInteractive -ExecutionPolicy Unrestricted -WindowStyle Hidden -File $home\Documents\DNS-Change-Tray-1.3.ps1"</code> <br />
<code>Register-ScheduledTask -TaskName "DNS-Change-Tray-Startup" -Trigger $Trigger -User $User -Action $Action -RunLevel Highest –Force</code></p>
<p><code>Get-ScheduledTask | ? state -ne Disabled</code> список всех активных заданий <br />
<code>Start-ScheduledTask DNS-Change-Tray-Startup</code> запустить задание немедленно <br />
<code>Get-ScheduledTask DNS-Change-Tray-Startup | Disable-ScheduledTask</code> отключить задание <br />
<code>Get-ScheduledTask DNS-Change-Tray-Startup | Enable-ScheduledTask</code> включить задание <br />
<code>Unregister-ScheduledTask DNS-Change-Tray-Startup</code> удалить задание <br />
<code>Export-ScheduledTask DNS-Change-Tray-Startup | Out-File $home\Desktop\Task-Export-Startup.xml</code> экспортировать задание в xml <br />
<code>Register-ScheduledTask -Xml (Get-Content $home\Desktop\Task-Export-Startup.xml | Out-String) -TaskName "DNS-Change-Tray-Startup"</code></p>
<h1 id="shutdown"><a class="header" href="#shutdown">shutdown</a></h1>
<p><code>shutdown /r /o</code> перезагрузка в безопасный режим <br />
<code>shutdown /s /t 600 /c "Power off after 10 minutes"</code> выключение <br />
<code>shutdown /s /f</code> принудительное закрытие приложений <br />
<code>shutdown /a</code> отмена <br />
<code>shutdown /r /t 0 /m \\192.168.3.100</code> <br />
<code>Restart-Computer -ComputerName 192.168.3.100 -Protocol WSMan</code> через WinRM <br />
<code>Restart-Computer –ComputerName 192.168.3.100 –Force</code> через WMI <br />
<code>Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\PolicyManager\default\Start\HideShutDown" -Name "value" -Value 1</code> скрыть кнопку выключения <br />
<code>Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\PolicyManager\default\Start\HideRestart" -Name "value" -Value 1</code> скрыть кнопку перезагрузки</p>
<pre><code class="language-PowerShell">function Start-Shutdown {
    &lt;#
    .SYNOPSIS
    Module for shutdown and restart the computer at a specified time
    .DESCRIPTION
    Example:
    # Start-Shutdown -Time "18:00"
    # Start-Shutdown -Restart -Time "18:00"
    # Start-Shutdown -Cancel
    .LINK
    https://github.com/Lifailon/PS-Commands
    #&gt;
    param(
        [string]$Time,
        [switch]$Restart,
        [switch]$Cancel
    )
    if ($Time) {
        $currentDateTime = Get-Date
        $shutdownTime = Get-Date $Time
        if ($shutdownTime -lt $currentDateTime) {
            $shutdownTime = $shutdownTime.AddDays(1)
        }
        $timeUntilShutdown = $shutdownTime - $currentDateTime
        $secondsUntilShutdown = [math]::Round($timeUntilShutdown.TotalSeconds)
    }
    if ($Cancel) {
        Start-Process -FilePath "shutdown.exe" -ArgumentList "/a"
    } elseif ($Restart) {
        Write-Host "The computer will restart after $($timeUntilShutdown.Hours) hours and $($timeUntilShutdown.Minutes) minutes."
        Start-Process -FilePath "shutdown.exe" -ArgumentList "/r", "/f", "/t", "$secondsUntilShutdown"
    } else {
        Write-Host "The computer will shutdown after $($timeUntilShutdown.Hours) hours and $($timeUntilShutdown.Minutes) minutes."
        Start-Process -FilePath "shutdown.exe" -ArgumentList "/s", "/f", "/t", "$secondsUntilShutdown"
    }
}
</code></pre>
<h1 id="localaccounts"><a class="header" href="#localaccounts">LocalAccounts</a></h1>
<p><code>Get-Command -Module Microsoft.PowerShell.LocalAccounts</code> <br />
<code>Get-LocalUser</code> список пользователей <br />
<code>Get-LocalGroup</code> список групп <br />
<code>New-LocalUser "1C" -Password $Password -FullName "1C Domain"</code> создать пользователя <br />
<code>Set-LocalUser -Password $Password 1C</code> изменить пароль <br />
<code>Add-LocalGroupMember -Group "Administrators" -Member "1C"</code> добавить в группу Администраторов <br />
<code>Get-LocalGroupMember "Administrators"</code> члены группы</p>
<pre><code class="language-PowerShell">@("vproxy-01","vproxy-02","vproxy-03") | %{
    icm $_ {Add-LocalGroupMember -Group "Administrators" -Member "support4"}
    icm $_ {Get-LocalGroupMember "Administrators"}
}
</code></pre>
<h1 id="ps2exe"><a class="header" href="#ps2exe">PS2EXE</a></h1>
<p><code>Install-Module ps2exe -Repository PSGallery</code> <br />
<code>Get-Module -ListAvailable</code> список всех модулей <br />
<code>-noConsole</code> использовать GUI, без окна консоли powershell <br />
<code>-noOutput</code> выполнение в фоне <br />
<code>-noError</code> без вывода ошибок <br />
<code>-requireAdmin</code> при запуске запросить права администратора <br />
<code>-credentialGUI</code> вывод диалогового окна для ввода учетных данных <br />
<code>Invoke-ps2exe -inputFile "$home\Desktop\WinEvent-Viewer-1.1.ps1" -outputFile "$home\Desktop\WEV-1.1.exe" -iconFile "$home\Desktop\log_48px.ico" -title "WinEvent-Viewer" -noConsole -noOutput -noError</code></p>
<h1 id="nssm"><a class="header" href="#nssm">NSSM</a></h1>
<p><code>$powershell_Path = (Get-Command powershell).Source</code> <br />
<code>$NSSM_Path = (Get-Command "C:\WinPerf-Agent\NSSM-2.24.exe").Source</code> <br />
<code>$Script_Path = "C:\WinPerf-Agent\WinPerf-Agent-1.1.ps1"</code> <br />
<code>$Service_Name = "WinPerf-Agent"</code> <br />
<code>&amp; $NSSM_Path install $Service_Name $powershell_Path -ExecutionPolicy Bypass -NoProfile -f $Script_Path</code> создать Service <br />
<code>&amp; $NSSM_Path start $Service_Name</code> запустить <br />
<code>&amp; $NSSM_Path status $Service_Name</code> статус <br />
<code>$Service_Name | Restart-Service</code> перезапустить <br />
<code>$Service_Name | Get-Service</code> статус <br />
<code>$Service_Name | Stop-Service</code> остановить <br />
<code>&amp; $NSSM_Path set $Service_Name description "Check performance CPU and report email"</code> изменить описание <br />
<code>&amp; $NSSM_Path remove $Service_Name</code> удалить</p>
<h1 id="jobs"><a class="header" href="#jobs">Jobs</a></h1>
<p><code>Get-Job</code> получение списка задач <br />
<code>Start-Job</code> запуск процесса <br />
<code>Stop-Job</code> остановка процесса <br />
<code>Suspend-Job</code> приостановка работы процесса <br />
<code>Resume-Job</code> восстановление работы процесса <br />
<code>Wait-Job</code> ожидание вывода команды <br />
<code>Receive-Job</code> получение результатов выполненного процесса <br />
<code>Remove-Job</code> удалить задачу</p>
<pre><code class="language-PowerShell">function Start-PingJob ($Network) {
    $RNetwork = $Network -replace "\.\d{1,3}$","."
    foreach ($4 in 1..254) {
        $ip = $RNetwork+$4
        # Создаем задания, забираем 3-ю строку вывода и добавляем к выводу ip-адрес
        (Start-Job {"$using:ip : "+(ping -n 1 -w 50 $using:ip)[2]}) | Out-Null
    }
    while ($True) {
        $status_job = $(Get-Job).State[-1] # забираем статус последнего задания (задания выполняются по очереди сверху вниз)
        if ($status_job -like "Completed") { # проверяем задание на выполнение
            $ping_out = Get-Job | Receive-Job # если выполнено, забираем вывод всех заданий
            Get-Job | Remove-Job -Force # удаляем задания
            break # завершаем цикл
        }
    }
    $ping_out
}
</code></pre>
<p><code>Start-PingJob -Network 192.168.3.0</code> <br />
<code>$(Measure-Command {Start-PingJob -Network 192.168.3.0}).TotalSeconds</code> 60 Seconds</p>
<h3 id="threadjob"><a class="header" href="#threadjob">ThreadJob</a></h3>
<p><code>Install-Module -Name ThreadJob</code> <br />
<code>Get-Module ThreadJob -list</code> <br />
<code>Start-ThreadJob {ping ya.ru} | Out-Null</code> создать фоновую задачу <br />
<code>Get-Job | Receive-Job -Keep</code> отобразить и не удалять вывод <br />
<code>(Get-Job).HasMoreData</code> если False, то вывод команы удален <br />
<code>(Get-Job)[-1].Output</code> отобразить вывод последней задачи</p>
<pre><code class="language-PowerShell">function Start-PingThreadJob ($Network) {
    $RNetwork = $Network -replace "\.\d{1,3}$","."
    foreach ($4 in 1..254) {
        $ip = $RNetwork+$4
        $(Start-ThreadJob {
            "$using:ip : " + $(ping -n 1 -w 50 $using:ip)[2]
        }) | Out-Null
    }
    while ($True) {
        $status_job = $(Get-Job).State[-1]
        if ($status_job -like "Completed") {
            $ping_out = Get-Job | Receive-Job
            Get-Job | Remove-Job -Force
            break
        }
    }
    $ping_out
}
</code></pre>
<p><code>Start-PingThreadJob -Network 192.168.3.0</code> <br />
<code>$(Measure-Command {Start-PingThread -Network 192.168.3.0}).TotalSeconds</code> 24 Seconds</p>
<h3 id="poshrsjob"><a class="header" href="#poshrsjob">PoshRSJob</a></h3>
<p>Install-Module -Name PoshRSJob</p>
<pre><code class="language-PowerShell">function Start-PingRSJob ($Network) {
    $RNetwork = $Network -replace "\.\d{1,3}$","."
    foreach ($4 in 1..254) {
        $ip = $RNetwork+$4
        $(Start-RSJob {
            "$using:ip : " + $(ping -n 1 -w 50 $using:ip)[2]
        }) | Out-Null
    }
    while ($True) {
        $status_job = $(Get-RSJob).State -notcontains "Running" # проверяем, что массив не содержит активных заданий
        if ($status_job) {
            $ping_out = Get-RSJob | Receive-RSJob
            Get-RSJob | Remove-RSJob
            break
        }
    }
    $ping_out
}
</code></pre>
<p><code>Start-PingRSJob -Network 192.168.3.0</code> <br />
<code>$(Measure-Command {Start-PingRSJob -Network 192.168.3.0}).TotalSeconds</code> 10 Seconds</p>
<h3 id="invoke-parallel"><a class="header" href="#invoke-parallel">Invoke-Parallel</a></h3>
<pre><code class="language-PowerShell"># Import function from GitHub to current session
$module = "https://raw.githubusercontent.com/RamblingCookieMonster/Invoke-Parallel/master/Invoke-Parallel/Invoke-Parallel.ps1"
Invoke-Expression $(Invoke-RestMethod $module)
</code></pre>
<p>Get-Help Invoke-Parallel -Full</p>
<pre><code class="language-PowerShell">function Start-PingInvokeParallel ($Network) {
    $RNetwork = $Network -replace "\.\d{1,3}$","."
    1..254 | ForEach-Object {$srvList += @($RNetwork+$_)}
    Invoke-Parallel -InputObject $srvList -ScriptBlock {
        "$_ : " + $(ping -n 1 -w 50 $_)[2]
    }
}
</code></pre>
<p><code>Start-PingInvokeParallel -Network 192.168.3.0</code> <br />
<code>$(Get-History)[-1].Duration.TotalSeconds</code> 7 seconds</p>
<pre><code class="language-PowerShell">$array_main  = 1..10 | ForEach-Object {"192.168.3.$_"}
Invoke-Parallel -InputObject $(0..$($array_main.Count-1)) -ScriptBlock {
    Foreach ($n in 1..100) {
        Start-Sleep -Milliseconds 100
        Write-Progress -Activity $($array_main[$_]) -PercentComplete $n -id $_
    }
} -ImportVariables
</code></pre>
<h3 id="foreach-object-parallel"><a class="header" href="#foreach-object-parallel">ForEach-Object-Parallel</a></h3>
<pre><code class="language-PowerShell">function Start-PingParallel ($Network) {
    $RNetwork = $Network -replace "\.\d{1,3}$","."
    1..254 | ForEach-Object -Parallel {
        "$using:RNetwork.$_ : " + $(ping -n 1 -w 50 "$using:RNetwork$_")[2]
    } -ThrottleLimit 254
}
</code></pre>
<p><code>Start-PingParallel -Network 192.168.3.0</code> <br />
<code>$(Get-History)[-1].Duration.TotalSeconds</code> 2 seconds</p>
<pre><code class="language-PowerShell">function Start-TestConnectParallel (
        $Network,
        [switch]$Csv
    ) {
    $RNetwork = $Network -replace "\.\d{1,3}$","."
    if ($csv) {
        "Address,Status,Latency"
    }
    1..254 | ForEach-Object -Parallel {
        $test = Test-Connection "$using:RNetwork$_" -Count 1 -TimeoutSeconds 1
        if ($using:csv) {
            "$($using:RNetwork)$_,$($test.Status),$($test.Latency)"
        } else {
            $test
        }
    } -ThrottleLimit 254
}
</code></pre>
<p><code>Start-TestConnectParallel -Network 192.168.3.0 -Csv | ConvertFrom-Csv</code> <br />
<code>$(Get-History)[-1].Duration.TotalSeconds</code> 3 seconds</p>
<pre><code class="language-PowerShell">$array_main  = 1..10 | ForEach-Object {"192.168.3.$_"}
$(0..$($array_main.Count-1)) | ForEach-Object -Parallel {
    Foreach ($n in 1..100) {
        Start-Sleep -Milliseconds 100
        $array_temp = $using:array_main
        Write-Progress -Activity $($array_temp[$_]) -PercentComplete $n -id $_
    }
} -ThrottleLimit $($array_main.Count)
</code></pre>
<h1 id="com"><a class="header" href="#com">COM</a></h1>
<p><code>$wshell = New-Object -ComObject Wscript.Shell</code> <br />
<code>$wshell | Get-Member</code> <br />
<code>$link = $wshell.CreateShortcut("$Home\Desktop\Yandex.lnk")</code> создать ярлык <br />
<code>$link | Get-Member</code> <br />
<code>$link.TargetPath = "https://yandex.ru"</code> куда ссылается (метод TargetPath объекта $link где хранится объект CreateShortcut) <br />
<code>$link.Save()</code> сохранить</p>
<p><code>Set-WinUserLanguageList -LanguageList en-us,ru -Force</code> изменить языковую раскладку клавиатуры</p>
<h3 id="wscript-shell-sendkeys"><a class="header" href="#wscript-shell-sendkeys">Wscript Shell SendKeys</a></h3>
<p><code>(New-Object -ComObject Wscript.shell).SendKeys([char]173)</code> включить/выключить звук <br />
<code>$wshell.Exec("notepad.exe")</code> запустить приложение <br />
<code>$wshell.AppActivate("Блокнот")</code> развернуть запущенное приложение</p>
<p><code>$wshell.SendKeys("Login")</code> текст <br />
<code>$wshell.SendKeys("{A 5}")</code> напечатать букву 5 раз подряд <br />
<code>$wshell.SendKeys("%{TAB}")</code> ALT+TAB <br />
<code>$wshell.SendKeys("^")</code> CTRL <br />
<code>$wshell.SendKeys("%")</code> ALT <br />
<code>$wshell.SendKeys("+")</code> SHIFT <br />
<code>$wshell.SendKeys("{DOWN}")</code> вниз <br />
<code>$wshell.SendKeys("{UP}")</code> вверх <br />
<code>$wshell.SendKeys("{LEFT}")</code> влево <br />
<code>$wshell.SendKeys("{RIGHT}")</code> вправо <br />
<code>$wshell.SendKeys("{PGUP}")</code> PAGE UP <br />
<code>$wshell.SendKeys("{PGDN}")</code> PAGE DOWN <br />
<code>$wshell.SendKeys("{BACKSPACE}")</code> BACKSPACE/BKSP/BS <br />
<code>$wshell.SendKeys("{DEL}")</code> DEL/DELETE <br />
<code>$wshell.SendKeys("{INS}")</code> INS/INSERT <br />
<code>$wshell.SendKeys("{PRTSC}")</code> PRINT SCREEN <br />
<code>$wshell.SendKeys("{ENTER}")</code> <br />
<code>$wshell.SendKeys("{ESC}")</code> <br />
<code>$wshell.SendKeys("{TAB}")</code> <br />
<code>$wshell.SendKeys("{END}")</code> <br />
<code>$wshell.SendKeys("{HOME}")</code> <br />
<code>$wshell.SendKeys("{BREAK}")</code> <br />
<code>$wshell.SendKeys("{SCROLLLOCK}")</code> <br />
<code>$wshell.SendKeys("{CAPSLOCK}")</code> <br />
<code>$wshell.SendKeys("{NUMLOCK}")</code> <br />
<code>$wshell.SendKeys("{F1}")</code> <br />
<code>$wshell.SendKeys("{F12}")</code> <br />
<code>$wshell.SendKeys("{+}{^}{%}{~}{(}{)}{[}{]}{{}{}}")</code></p>
<pre><code class="language-PowerShell">function Get-AltTab {
    (New-Object -ComObject wscript.shell).SendKeys("%{Tab}")
    Start-Sleep $(Get-Random -Minimum 30 -Maximum 180)
    Get-AltTab
}
</code></pre>
<p><code>Get-AltTab</code></p>
<h3 id="wscript-shell-popup"><a class="header" href="#wscript-shell-popup">Wscript Shell Popup</a></h3>
<p><code>$wshell = New-Object -ComObject Wscript.Shell</code> <br />
<code>$output = $wshell.Popup("Выберите действие?",0,"Заголовок",4)</code> <br />
<code>if ($output -eq 6) {"yes"} elseif ($output -eq 7) {"no"} else {"no good"}</code></p>
<pre><code>Type:
0 ОК
1 ОК и Отмена
2 Стоп, Повтор, Пропустить
3 Да, Нет, Отмена
4 Да и Нет
5 Повтор и Отмена
16 Stop
32 Question
48 Exclamation
64 Information

Output:
-1 Timeout
1 ОК
2 Отмена
3 Стоп
4 Повтор
5 Пропустить
6 Да
7 Нет
</code></pre>
<h3 id="wscript-network"><a class="header" href="#wscript-network">WScript Network</a></h3>
<p><code>$wshell = New-Object -ComObject WScript.Network</code> <br />
<code>$wshell | Get-Member</code> <br />
<code>$wshell.UserName</code> <br />
<code>$wshell.ComputerName</code> <br />
<code>$wshell.UserDomain</code></p>
<h3 id="shell-application"><a class="header" href="#shell-application">Shell Application</a></h3>
<p><code>$wshell = New-Object -ComObject Shell.Application</code> <br />
<code>$wshell | Get-Member</code> <br />
<code>$wshell.Explore("C:\")</code> <br />
<code>$wshell.Windows() | Get-Member</code> получить доступ к открытым в проводнике или браузере Internet Explorer окон</p>
<p><code>$shell = New-Object -Com Shell.Application</code> <br />
<code>$RecycleBin = $shell.Namespace(10)</code> <br />
<code>$RecycleBin.Items()</code></p>
<h3 id="outlook"><a class="header" href="#outlook">Outlook</a></h3>
<p><code>$Outlook = New-Object -ComObject Outlook.Application</code> <br />
<code>$Outlook | Get-Member</code> <br />
<code>$Outlook.Version</code></p>
<pre><code class="language-PowerShell">$Outlook = New-Object -ComObject Outlook.Application
$Namespace = $Outlook.GetNamespace("MAPI")
$Folder = $namespace.GetDefaultFolder(4)` исходящие
$Folder = $namespace.GetDefaultFolder(6)` входящие
$Explorer = $Folder.GetExplorer()
$Explorer.Display()	
$Outlook.Quit()
</code></pre>
<h3 id="microsoft-update"><a class="header" href="#microsoft-update">Microsoft Update</a></h3>
<p><code>(New-Object -com 'Microsoft.Update.AutoUpdate').Settings</code> <br />
<code>(New-Object -com 'Microsoft.Update.AutoUpdate').Results</code> <br />
<code>(New-Timespan -Start ((New-Object -com 'Microsoft.Update.AutoUpdate').Results|Select -ExpandProperty LastInstallationSuccessDate) -End (Get-Date)).hours</code> кол-во часов, прошедших с последней даты установки обновления безопасности в Windows.</p>
<h1 id="dotnet"><a class="header" href="#dotnet">dotNET</a></h1>
<p><code>[System.Diagnostics.EventLog] | select Assembly,Module</code> <br />
<code>$EventLog = [System.Diagnostics.EventLog]::new("Application")</code> <br />
<code>$EventLog = New-Object -TypeName System.Diagnostics.EventLog -ArgumentList Application,192.168.3.100</code> <br />
<code>$EventLog | Get-Member -MemberType Method</code> <br />
<code>$EventLog.MaximumKilobytes</code> максимальный размер журнала <br />
<code>$EventLog.Entries</code> просмотреть журнал <br />
<code>$EventLog.Clear()</code> очистить журнал</p>
<p><code>Join-Path C: Install Test</code> <br />
<code>[System.IO.Path]::Combine("C:", "Install", "Test")</code></p>
<h3 id="match"><a class="header" href="#match">Match</a></h3>
<p><code>[System.Math] | Get-Member -Static -MemberType Methods</code> <br />
<code>[System.Math]::Max(2,7)</code> <br />
<code>[System.Math]::Min(2,7)</code> <br />
<code>[System.Math]::Floor(3.9)</code> <br />
<code>[System.Math]::Truncate(3.9)</code></p>
<h3 id="generate-password"><a class="header" href="#generate-password">Generate Password</a></h3>
<p><code>Add-Type -AssemblyName System.Web</code> <br />
<code>[System.Web.Security.Membership]::GeneratePassword(10,2)</code></p>
<h3 id="sound-player"><a class="header" href="#sound-player">Sound Player</a></h3>
<pre><code class="language-PowerShell">$CriticalSound = New-Object System.Media.SoundPlayer
$CriticalSound.SoundLocation = "C:\WINDOWS\Media\Windows Critical Stop.wav"
$CriticalSound.Play()

$GoodSound = New-Object System.Media.SoundPlayer
$GoodSound.SoundLocation = "C:\WINDOWS\Media\tada.wav"
$GoodSound.Play()
</code></pre>
<h3 id="static-class"><a class="header" href="#static-class">Static Class</a></h3>
<p><code>[System.Environment] | Get-Member -Static</code> <br />
<code>[System.Environment]::OSVersion</code> <br />
<code>[System.Environment]::Version</code> <br />
<code>[System.Environment]::MachineName</code> <br />
<code>[System.Environment]::UserName</code></p>
<p><code>[System.Diagnostics.Process] | Get-Member -Static</code> <br />
<code>[System.Diagnostics.Process]::Start('notepad.exe')</code></p>
<h3 id="clicker"><a class="header" href="#clicker">Clicker</a></h3>
<pre><code class="language-PowerShell">$cSource = @'
using System;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;
public class Clicker
{
//https://msdn.microsoft.com/en-us/library/windows/desktop/ms646270(v=vs.85).aspx
[StructLayout(LayoutKind.Sequential)]
struct INPUT
{ 
    public int        type; // 0 = INPUT_MOUSE,
                            // 1 = INPUT_KEYBOARD
                            // 2 = INPUT_HARDWARE
    public MOUSEINPUT mi;
}
//https://msdn.microsoft.com/en-us/library/windows/desktop/ms646273(v=vs.85).aspx
[StructLayout(LayoutKind.Sequential)]
struct MOUSEINPUT
{
    public int    dx ;
    public int    dy ;
    public int    mouseData ;
    public int    dwFlags;
    public int    time;
    public IntPtr dwExtraInfo;
}
//This covers most use cases although complex mice may have additional buttons
//There are additional constants you can use for those cases, see the msdn page
const int MOUSEEVENTF_MOVED      = 0x0001 ;
const int MOUSEEVENTF_LEFTDOWN   = 0x0002 ;
const int MOUSEEVENTF_LEFTUP     = 0x0004 ;
const int MOUSEEVENTF_RIGHTDOWN  = 0x0008 ;
const int MOUSEEVENTF_RIGHTUP    = 0x0010 ;
const int MOUSEEVENTF_MIDDLEDOWN = 0x0020 ;
const int MOUSEEVENTF_MIDDLEUP   = 0x0040 ;
const int MOUSEEVENTF_WHEEL      = 0x0080 ;
const int MOUSEEVENTF_XDOWN      = 0x0100 ;
const int MOUSEEVENTF_XUP        = 0x0200 ;
const int MOUSEEVENTF_ABSOLUTE   = 0x8000 ;
const int screen_length          = 0x10000 ;
//https://msdn.microsoft.com/en-us/library/windows/desktop/ms646310(v=vs.85).aspx
[System.Runtime.InteropServices.DllImport("user32.dll")]
extern static uint SendInput(uint nInputs, INPUT[] pInputs, int cbSize);
public static void LeftClickAtPoint(int x, int y)
{
    //Move the mouse
    INPUT[] input = new INPUT[3];
    input[0].mi.dx = x*(65535/System.Windows.Forms.Screen.PrimaryScreen.Bounds.Width);
    input[0].mi.dy = y*(65535/System.Windows.Forms.Screen.PrimaryScreen.Bounds.Height);
    input[0].mi.dwFlags = MOUSEEVENTF_MOVED | MOUSEEVENTF_ABSOLUTE;
    //Left mouse button down
    input[1].mi.dwFlags = MOUSEEVENTF_LEFTDOWN;
    //Left mouse button up
    input[2].mi.dwFlags = MOUSEEVENTF_LEFTUP;
    SendInput(3, input, Marshal.SizeOf(input[0]));
}
}
'@
</code></pre>
<p><code>Add-Type -TypeDefinition $cSource -ReferencedAssemblies System.Windows.Forms,System.Drawing</code> <br />
<code>[Clicker]::LeftClickAtPoint(1900,1070)</code></p>
<h3 id="audio"><a class="header" href="#audio">Audio</a></h3>
<pre><code class="language-PowerShell">Add-Type -Language CsharpVersion3 -TypeDefinition @"
using System.Runtime.InteropServices;
[Guid("5CDF2C82-841E-4546-9722-0CF74078229A"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
interface IAudioEndpointVolume {
// f(), g(), ... are unused COM method slots. Define these if you care
int f(); int g(); int h(); int i();
int SetMasterVolumeLevelScalar(float fLevel, System.Guid pguidEventContext);
int j();
int GetMasterVolumeLevelScalar(out float pfLevel);
int k(); int l(); int m(); int n();
int SetMute([MarshalAs(UnmanagedType.Bool)] bool bMute, System.Guid pguidEventContext);
int GetMute(out bool pbMute);
}
[Guid("D666063F-1587-4E43-81F1-B948E807363F"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
interface IMMDevice {
int Activate(ref System.Guid id, int clsCtx, int activationParams, out IAudioEndpointVolume aev);
}
[Guid("A95664D2-9614-4F35-A746-DE8DB63617E6"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
interface IMMDeviceEnumerator {
int f(); // Unused
int GetDefaultAudioEndpoint(int dataFlow, int role, out IMMDevice endpoint);
}
[ComImport, Guid("BCDE0395-E52F-467C-8E3D-C4579291692E")] class MMDeviceEnumeratorComObject { }
public class Audio {
static IAudioEndpointVolume Vol() {
var enumerator = new MMDeviceEnumeratorComObject() as IMMDeviceEnumerator;
IMMDevice dev = null;
Marshal.ThrowExceptionForHR(enumerator.GetDefaultAudioEndpoint(/*eRender*/ 0, /*eMultimedia*/ 1, out dev));
IAudioEndpointVolume epv = null;
var epvid = typeof(IAudioEndpointVolume).GUID;
Marshal.ThrowExceptionForHR(dev.Activate(ref epvid, /*CLSCTX_ALL*/ 23, 0, out epv));
return epv;
}
public static float Volume {
get {float v = -1; Marshal.ThrowExceptionForHR(Vol().GetMasterVolumeLevelScalar(out v)); return v;}
set {Marshal.ThrowExceptionForHR(Vol().SetMasterVolumeLevelScalar(value, System.Guid.Empty));}
}
public static bool Mute {
get { bool mute; Marshal.ThrowExceptionForHR(Vol().GetMute(out mute)); return mute; }
set { Marshal.ThrowExceptionForHR(Vol().SetMute(value, System.Guid.Empty)); }
}
}
"@
</code></pre>
<p><code>[Audio]::Volume = 0.50</code> <br />
<code>[Audio]::Mute = $true</code></p>
<h3 id="netsessionenum"><a class="header" href="#netsessionenum">NetSessionEnum</a></h3>
<p><a href="https://learn.microsoft.com/ru-ru/windows/win32/api/lmshare/nf-lmshare-netsessionenum?redirectedfrom=MSDN">Function</a> <br />
<a href="https://fuzzysecurity.com/tutorials/24.html">Source</a></p>
<pre><code class="language-PowerShell">function Invoke-NetSessionEnum {
param (
[Parameter(Mandatory = $True)][string]$HostName
)
Add-Type -TypeDefinition @"
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
[StructLayout(LayoutKind.Sequential)]
public struct SESSION_INFO_10
{
    [MarshalAs(UnmanagedType.LPWStr)]public string OriginatingHost;
    [MarshalAs(UnmanagedType.LPWStr)]public string DomainUser;
    public uint SessionTime;
    public uint IdleTime;
}
public static class Netapi32
{
[DllImport("Netapi32.dll", SetLastError=true)]
    public static extern int NetSessionEnum(
        [In,MarshalAs(UnmanagedType.LPWStr)] string ServerName,
        [In,MarshalAs(UnmanagedType.LPWStr)] string UncClientName,
        [In,MarshalAs(UnmanagedType.LPWStr)] string UserName,
        Int32 Level,
        out IntPtr bufptr,
        int prefmaxlen,
        ref Int32 entriesread,
        ref Int32 totalentries,
        ref Int32 resume_handle);
         
[DllImport("Netapi32.dll", SetLastError=true)]
    public static extern int NetApiBufferFree(
        IntPtr Buffer);
}
"@
# Create SessionInfo10 Struct
$SessionInfo10 = New-Object SESSION_INFO_10
$SessionInfo10StructSize = [System.Runtime.InteropServices.Marshal]::SizeOf($SessionInfo10)` Grab size to loop bufptr
$SessionInfo10 = $SessionInfo10.GetType()` Hacky, but we need this ;))
# NetSessionEnum params
$OutBuffPtr = [IntPtr]::Zero` Struct output buffer
$EntriesRead = $TotalEntries = $ResumeHandle = 0` Counters &amp; ResumeHandle
$CallResult = [Netapi32]::NetSessionEnum($HostName, "", "", 10, [ref]$OutBuffPtr, -1, [ref]$EntriesRead, [ref]$TotalEntries, [ref]$ResumeHandle)
if ($CallResult -ne 0){
echo "Mmm something went wrong!`nError Code: $CallResult"
}
else {
if ([System.IntPtr]::Size -eq 4) {
echo "`nNetapi32::NetSessionEnum Buffer Offset  --&gt; 0x$("{0:X8}" -f $OutBuffPtr.ToInt32())"
}
else {
echo "`nNetapi32::NetSessionEnum Buffer Offset  --&gt; 0x$("{0:X16}" -f $OutBuffPtr.ToInt64())"
}
echo "Result-set contains $EntriesRead session(s)!"
# Change buffer offset to int
$BufferOffset = $OutBuffPtr.ToInt64()
# Loop buffer entries and cast pointers as SessionInfo10
for ($Count = 0; ($Count -lt $EntriesRead); $Count++){
$NewIntPtr = New-Object System.Intptr -ArgumentList $BufferOffset
$Info = [system.runtime.interopservices.marshal]::PtrToStructure($NewIntPtr,[type]$SessionInfo10)
$Info
$BufferOffset = $BufferOffset + $SessionInfo10StructSize
}
echo "`nCalling NetApiBufferFree, no memleaks here!"
[Netapi32]::NetApiBufferFree($OutBuffPtr) |Out-Null
}
}
</code></pre>
<p><code>Invoke-NetSessionEnum localhost</code></p>
<h3 id="copyfile"><a class="header" href="#copyfile">CopyFile</a></h3>
<p><a href="https://learn.microsoft.com/ru-ru/windows/win32/api/winbase/nf-winbase-copyfile">Function</a> <br />
<a href="https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-1/">Source</a></p>
<pre><code class="language-PowerShell">$MethodDefinition = @"
[DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
public static extern bool CopyFile(string lpExistingFileName, string lpNewFileName, bool bFailIfExists);
"@
$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name "Kernel32" -Namespace "Win32" -PassThru
$Kernel32::CopyFile("$($Env:SystemRoot)\System32\calc.exe", "$($Env:USERPROFILE)\Desktop\calc.exe", $False) 
</code></pre>
<h3 id="showwindowasync"><a class="header" href="#showwindowasync">ShowWindowAsync</a></h3>
<p><a href="https://learn.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-showwindowasync">Function</a></p>
<pre><code class="language-PowerShell">$Signature = @"
[DllImport("user32.dll")]public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);
"@
$ShowWindowAsync = Add-Type -MemberDefinition $Signature -Name "Win32ShowWindowAsync" -Namespace Win32Functions -PassThru
$ShowWindowAsync | Get-Member -Static
$ShowWindowAsync::ShowWindowAsync((Get-Process -Id $pid).MainWindowHandle, 2)
$ShowWindowAsync::ShowWindowAsync((Get-Process -Id $Pid).MainWindowHandle, 3)
$ShowWindowAsync::ShowWindowAsync((Get-Process -Id $Pid).MainWindowHandle, 4)
</code></pre>
<h3 id="getasynckeystate"><a class="header" href="#getasynckeystate">GetAsyncKeyState</a></h3>
<p><a href="https://learn.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-getasynckeystate">Function</a></p>
<p><code>Add-Type -AssemblyName System.Windows.Forms</code> <br />
<code>[int][System.Windows.Forms.Keys]::F1</code> определить номер [Int] клавиши по ее названию <br />
<code>65..90 | % {"{0} = {1}" -f $_, [System.Windows.Forms.Keys]$_}</code> порядковый номер букв (A..Z)</p>
<pre><code class="language-PowerShell">function Get-ControlKey {
$key = 112
$Signature = @'
[DllImport("user32.dll", CharSet=CharSet.Auto, ExactSpelling=true)] 
public static extern short GetAsyncKeyState(int virtualKeyCode); 
'@
Add-Type -MemberDefinition $Signature -Name Keyboard -Namespace PsOneApi
[bool]([PsOneApi.Keyboard]::GetAsyncKeyState($key) -eq -32767)
}

Write-Warning 'Press F1 to exit'
while ($true) {
Write-Host '.' -NoNewline
if (Get-ControlKey) {
break
}
Start-Sleep -Seconds 0.5
}
</code></pre>
<h1 id="console-api"><a class="header" href="#console-api">Console API</a></h1>
<p><a href="https://powershell.one/tricks/input-devices/detect-key-press">Source</a></p>
<p><code>[Console] | Get-Member -Static</code> <br />
<code>[Console]::BackgroundColor = "Blue"</code> <br />
<code>[Console]::OutputEncoding</code> используемая кодировка в текущей сессии <br />
<code>[Console]::OutputEncoding = [System.Text.Encoding]::GetEncoding("utf-8")</code> изменить кодировку для отображения кириллицы <br />
<code>[Console]::outputEncoding = [System.Text.Encoding]::GetEncoding("cp866")</code> для ISE <br />
<code>[Console]::OutputEncoding = [System.Text.Encoding]::GetEncoding("windows-1251")</code> для ps2exe <br />
<code>Get-Service | Out-File $home\Desktop\Service.txt -Encoding oem</code> &gt; <br />
<code>Get-Service | Out-File $home\Desktop\Service.txt -Append</code> &gt;&gt;</p>
<pre><code class="language-PowerShell">do {
    if ([Console]::KeyAvailable) {
        $keyInfo = [Console]::ReadKey($true)
        break
    }
    Write-Host "." -NoNewline
    Start-Sleep 1
} while ($true)
Write-Host
$keyInfo

function Get-KeyPress {
    param (
        [Parameter(Mandatory)][ConsoleKey]$Key,
        [System.ConsoleModifiers]$ModifierKey = 0
    )
    if ([Console]::KeyAvailable) {
        $pressedKey = [Console]::ReadKey($true)
        $isPressedKey = $key -eq $pressedKey.Key
        if ($isPressedKey) {
            $pressedKey.Modifiers -eq $ModifierKey
        }
        else {
            [Console]::Beep(1800, 200)
            $false
        }
    }
}

Write-Warning 'Press Ctrl+Shift+Q to exit'
do {
    Write-Host "." -NoNewline
    $pressed = Get-KeyPress -Key Q -ModifierKey 'Control,Shift'
    if ($pressed) { break }
    Start-Sleep 1
} while ($true)
</code></pre>
<h1 id="drawing"><a class="header" href="#drawing">Drawing</a></h1>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.drawing?view=net-7.0&amp;redirectedfrom=MSDN">API</a></p>
<pre><code class="language-PowerShell">Add-Type -AssemblyName System.Drawing
$Width = 800
$Height = 400
$image = New-Object System.Drawing.Bitmap($Width,$Height)
$graphic = [System.Drawing.Graphics]::FromImage($image)
$background_color = [System.Drawing.Brushes]::Blue # задать цвет фона (синий)
$graphic.FillRectangle($background_color, 0, 0, $image.Width, $image.Height)
$text_color = [System.Drawing.Brushes]::White # задать цвет текста (белый)
$font = New-Object System.Drawing.Font("Arial", 20, [System.Drawing.FontStyle]::Bold) # задать шрифт
$text = "PowerShell" # указать текст
$text_position = New-Object System.Drawing.RectangleF(320, 180, 300, 100)  # задать положение текста (x, y, width, height)
$graphic.DrawString($text, $font, $text_color, $text_position) # нанести текст на изображение
$image.Save("$home\desktop\powershell_image.bmp", [System.Drawing.Imaging.ImageFormat]::Bmp) # сохранить изображение
$image.Dispose() # освобождение ресурсов
</code></pre>
<p><code>$path = "$home\desktop\powershell_image.bmp"</code> <br />
<code>Invoke-Item $path</code></p>
<pre><code class="language-PowerShell">$src_image = [System.Drawing.Image]::FromFile($path)
$Width = 400
$Height = 200
$dst_image = New-Object System.Drawing.Bitmap -ArgumentList $src_image, $Width, $Height # изменить размер изображения
$dst_image.Save("$home\desktop\powershell_image_resize.bmp", [System.Drawing.Imaging.ImageFormat]::Bmp)

$rotated_image = $src_image.Clone() # создать копию исходного изображения
$rotated_image.RotateFlip([System.Drawing.RotateFlipType]::Rotate180FlipNone) # перевернуть изображение на 180 градусов
$rotated_image.Save("$home\desktop\powershell_image_rotated.bmp", [System.Drawing.Imaging.ImageFormat]::Bmp)
$src_image.Dispose() # закрыть (отпустить) исходный файл
</code></pre>
<h1 id="objectevent"><a class="header" href="#objectevent">ObjectEvent</a></h1>
<pre><code class="language-PowerShell">$Timer = New-Object System.Timers.Timer
$Timer.Interval = 1000
Register-ObjectEvent -InputObject $Timer -EventName Elapsed -SourceIdentifier Timer.Output -Action {
$Random = Get-Random -Min 0 -Max 100
Write-Host $Random 
}
$Timer.Enabled = $True
</code></pre>
<p><code>$Timer.Enabled = $False</code> остановить <br />
<code>$Timer | Get-Member -MemberType Event</code> отобразить список всех событий объекта <br />
<code>Get-EventSubscriber</code> список зарегистрированных подписок на события в текущей сессии <br />
<code>Unregister-Event -SourceIdentifier Timer.Output</code> удаляет регистрацию подписки на событие по имени события (EventName) или все * <br />
<code>-Forward</code> перенаправляет события из удаленного сеанса (New-PSSession) в локальный сеанс <br />
<code>-SupportEvent</code> не выводит результат регистрации события на экран (и Get-EventSubscriber и Get-Job)</p>
<pre><code>Register-EngineEvent -SourceIdentifier PowerShell.Exiting -Action {
$date = Get-Date -f hh:mm:ss
(New-Object -ComObject Wscript.Shell).Popup("PowerShell Exit: $date",0,"Action",64)
}
</code></pre>
<h1 id="base64"><a class="header" href="#base64">Base64</a></h1>
<h3 id="utf8"><a class="header" href="#utf8">UTF8</a></h3>
<p><code>$loginPassword = "login:password"</code> <br />
<code>$Base64 = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($loginPassword))</code> закодировать логин и пароль в строку Base64 <br />
<code>[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Base64))</code> преобразовать в байты и обратно декодировать в исходную строку с помощью UTF-8 кодировки</p>
<h3 id="unicode"><a class="header" href="#unicode">Unicode</a></h3>
<pre><code class="language-PowerShell">$text = "password"
$byte = [System.Text.Encoding]::Unicode.GetBytes($text) # преобразует строку $text в последовательность байтов, используя кодировку Unicode
$base64 = [System.Convert]::ToBase64String($byte) # байты конвертируются в строку Base64 с помощью метода ToBase64String
$decode_base64 = [System.Convert]::FromBase64String($base64) # декодировать строку Base64 обратно в последовательность байтов с помощью метода FromBase64String
$decode_string = [System.Text.Encoding]::Unicode.GetString($decode_base64) # закодированные байты преобразуются обратно в строку с использованием кодировки Unicode с помощью метода GetString
</code></pre>
<h3 id="image"><a class="header" href="#image">Image</a></h3>
<pre><code class="language-PowerShell">$path_image = "$home\Documents\1200x800.jpg"
$BBase64 = [System.Convert]::ToBase64String((Get-Content $path_image -Encoding Byte))
Add-Type -assembly System.Drawing
$Image = [System.Drawing.Bitmap]::FromStream([IO.MemoryStream][Convert]::FromBase64String($BBase64))
$Image.Save("$home\Desktop\1200x800.jpg")
</code></pre>
<h1 id="excel"><a class="header" href="#excel">Excel</a></h1>
<pre><code class="language-PowerShell">$path = "$home\Desktop\Services-to-Excel.xlsx"
$Excel = New-Object -ComObject Excel.Application
$Excel.Visible = $false` отключить открытие GUI
$ExcelWorkBook = $Excel.Workbooks.Add()` Создать книгу
$ExcelWorkSheet = $ExcelWorkBook.Worksheets.Item(1)` Создать лист
$ExcelWorkSheet.Name = "Services"` задать имя листа
$ExcelWorkSheet.Cells.Item(1,1) = "Name service"
# Задать имена столбцов:
$ExcelWorkSheet.Cells.Item(1,2) = "Description"
$ExcelWorkSheet.Cells.Item(1,3) = "Status"
$ExcelWorkSheet.Cells.Item(1,4) = "Startup type"
$ExcelWorkSheet.Rows.Item(1).Font.Bold = $true` выделить жирным шрифтом
$ExcelWorkSheet.Rows.Item(1).Font.size=14
# Задать ширину колонок:
$ExcelWorkSheet.Columns.Item(1).ColumnWidth=30
$ExcelWorkSheet.Columns.Item(2).ColumnWidth=80
$ExcelWorkSheet.Columns.Item(3).ColumnWidth=15
$ExcelWorkSheet.Columns.Item(4).ColumnWidth=25
$services =  Get-Service
$counter = 2` задать начальный номер строки для записи
foreach ($service in $services) {
    $status = $service.Status
    if ($status -eq 1) {
        $status_type = "Stopped"
    } elseif ($status -eq 4) {
        $status_type = "Running"
    }
    $Start = $service.StartType
    if ($Start -eq 1) {
        $start_type = "Delayed start"
    } elseif ($Start -eq 2) {
        $start_type = "Automatic"
    } elseif ($Start -eq 3) {
        $start_type = "Manually"
    } elseif ($Start -eq 4) {
        $start_type = "Disabled"
    }
    $ExcelWorkSheet.Columns.Item(1).Rows.Item($counter) = $service.Name
    $ExcelWorkSheet.Columns.Item(2).Rows.Item($counter) = $service.DisplayName
    $ExcelWorkSheet.Columns.Item(3).Rows.Item($counter) = $status_type
    $ExcelWorkSheet.Columns.Item(4).Rows.Item($counter) = $start_type
    if ($status_type -eq "Running") {
        $ExcelWorkSheet.Columns.Item(3).Rows.Item($counter).Font.Bold = $true
    }
    # +1 увеличить для счетчика строки Rows
    $counter++
}
$ExcelWorkBook.SaveAs($path)
$ExcelWorkBook.close($true)
$Excel.Quit()
</code></pre>
<h3 id="excel-application-open"><a class="header" href="#excel-application-open">Excel Application Open</a></h3>
<pre><code class="language-PowerShell">$path = "$home\Desktop\Services-to-Excel.xlsx"
$Excel = New-Object -ComObject Excel.Application
$Excel.Visible = $false
$ExcelWorkBook = $excel.Workbooks.Open($path)` открыть xlsx-файл
$ExcelWorkBook.Sheets | select Name,Index` отобразить листы
$ExcelWorkSheet = $ExcelWorkBook.Sheets.Item(1)` открыть лист по номеру Index
1..100 | %{$ExcelWorkSheet.Range("A$_").Text}` прочитать значение из столбца А строки c 1 по 100
$Excel.Quit()
</code></pre>
<h3 id="importexcel"><a class="header" href="#importexcel">ImportExcel</a></h3>
<p><code>Install-Module -Name ImportExcel</code> <br />
<code>$data | Export-Excel .\Data.xlsx</code> <br />
<code>$data = Import-Excel .\Data.xlsx</code></p>
<p><code>$data = ps</code> <br />
<code>$Chart = New-ExcelChartDefinition -XRange CPU -YRange WS -Title "Process" -NoLegend</code> <br />
<code>$data | Export-Excel .\ps.xlsx -AutoNameRange -ExcelChartDefinition $Chart -Show</code></p>
<h1 id="csv"><a class="header" href="#csv">CSV</a></h1>
<p><code>Get-Service | Select Name,DisplayName,Status,StartType | Export-Csv -path "$home\Desktop\Get-Service.csv" -Append -Encoding Default</code> экспортировать в csv (-Encoding UTF8) <br />
<code>Import-Csv "$home\Desktop\Get-Service.csv" -Delimiter ","</code> импортировать массив</p>
<pre><code class="language-PowerShell">$data = ConvertFrom-Csv @"
Region,State,Units,Price
West,Texas,927,923.71
$null,Tennessee,466,770.67
"@
</code></pre>
<p><code>$systeminfo = systeminfo /FO csv | ConvertFrom-Csv</code> вывод работы программы в CSV и конвертация в объект <br />
<code>$systeminfo."Полный объем физической памяти"</code> <br />
<code>$systeminfo."Доступная физическая память"</code></p>
<h3 id="convertfrom-string"><a class="header" href="#convertfrom-string">ConvertFrom-String</a></h3>
<pre><code class="language-PowerShell">'
log = 
{
   level = 4;
};
' | ConvertFrom-String` создает PSCustomObject (разбивает по пробелам, удаляет все пробелы и пустые строки)
</code></pre>
<h3 id="convertfrom-stringdata"><a class="header" href="#convertfrom-stringdata">ConvertFrom-StringData</a></h3>
<pre><code class="language-PowerShell">"
key1 = value1
key2 = value2
" | ConvertFrom-StringData # создает Hashtable
</code></pre>
<h1 id="xml"><a class="header" href="#xml">XML</a></h1>
<pre><code class="language-PowerShell">$xml = [xml](Get-Content $home\desktop\test.rdg)` прочитать содержимое XML-файла
$xml.load("$home\desktop\test.rdg")` открыть файл
$xml.RDCMan.file.group.properties.name` имена групп
$xml.RDCMan.file.group.server.properties` имена всех серверов
$xml.RDCMan.file.group[3].server.properties` список серверов в 4-й группе
($xml.RDCMan.file.group[3].server.properties | ? name -like ADIRK).Name = "New-Name"` изменить значение
$xml.RDCMan.file.group[3].server[0].properties.displayName = "New-displayName" 
$xml.RDCMan.file.group[3].server[1].RemoveAll()` удалить объект (2-й сервер в списке)
$xml.Save($file)` сохранить содержимое объекта в файла
</code></pre>
<p><code>Get-Service | Export-Clixml -path $home\desktop\test.xml</code> экспортировать объект PowerShell в XML <br />
<code>Import-Clixml -Path $home\desktop\test.xml</code> импортировать объект XML в PowerShell <br />
<code>ConvertTo-Xml (Get-Service)</code></p>
<h3 id="get-credtoxml"><a class="header" href="#get-credtoxml">Get-CredToXML</a></h3>
<pre><code class="language-PowerShell">function Get-CredToXML {
    param (
        $CredFile = "$home\Documents\cred.xml"
    )
    if (Test-Path $CredFile) {
        Import-Clixml -path $CredFile
    }
    elseif (!(Test-Path $CredFile)) {
        $Cred = Get-Credential -Message "Enter credential"
        if ($Cred -ne $null) {
        $Cred | Export-CliXml -Path $CredFile
        $Cred
    }
    else {
        return
    }
    }
}
</code></pre>
<p><code>$Cred = Get-CredToXML</code> <br />
<code>$Login = $Cred.UserName</code> <br />
<code>$PasswordText = $Cred.GetNetworkCredential().password</code> получить пароль в текстовом виде</p>
<h3 id="xmlwriter-extensible-markup-language"><a class="header" href="#xmlwriter-extensible-markup-language">XmlWriter (Extensible Markup Language)</a></h3>
<pre><code class="language-PowerShell">$XmlWriterSettings = New-Object System.Xml.XmlWriterSettings
$XmlWriterSettings.Indent = $true` включить отступы
$XmlWriterSettings.IndentChars = "    "` задать отступ

$XmlFilePath = "$home\desktop\test.xml"
$XmlObjectWriter = [System.XML.XmlWriter]::Create($XmlFilePath, $XmlWriterSettings)` создать документ
$XmlObjectWriter.WriteStartDocument()` начать запись в документ

$XmlObjectWriter.WriteComment("Comment")
$XmlObjectWriter.WriteStartElement("Root")` создать стартовый элемент, который содержит дочерние объекты
    $XmlObjectWriter.WriteStartElement("Configuration")` создать первый дочерний элемент для BaseSettings
        $XmlObjectWriter.WriteElementString("Language","RU")
        $XmlObjectWriter.WriteStartElement("Fonts")   		# &lt;Fonts&gt;
            $XmlObjectWriter.WriteElementString("Name","Arial")
            $XmlObjectWriter.WriteElementString("Size","12")
        $XmlObjectWriter.WriteEndElement()               	# &lt;/Fonts&gt;
    $XmlObjectWriter.WriteEndElement()` конечный элемент &lt;/Configuration&gt;
$XmlObjectWriter.WriteEndElement()` конечный элемент &lt;/Root&gt;

$XmlObjectWriter.WriteEndDocument()` завершить запись в документ
$XmlObjectWriter.Flush()
$XmlObjectWriter.Close()
</code></pre>
<h3 id="createelement"><a class="header" href="#createelement">CreateElement</a></h3>
<pre><code class="language-PowerShell">$xml = [xml](gc $home\desktop\test.xml)
$xml.Root.Configuration.Fonts
$NewElement = $xml.CreateElement("Fonts")` выбрать элемент куда добавить
$NewElement.set_InnerXML("&lt;Name&gt;Times New Roman&lt;/Name&gt;&lt;Size&gt;14&lt;/Size&gt;")` Заполнить значениями дочерние элементы Fonts
$xml.Root.Configuration.AppendChild($NewElement)` добавить элемент новой строкой в Configuration (родитель Fonts)
$xml.Save("$home\desktop\test.xml")
</code></pre>
<h1 id="json"><a class="header" href="#json">JSON</a></h1>
<pre><code class="language-PowerShell">$log = '
{
  "log": {
    "level": 7
  }
}
' | ConvertFrom-Json

Get-Service | ConvertTo-Json

$OOKLA  = '
{
"result" : 
{"date":1683534970,"id":"14708271987","connection_icon":"wireless","download":33418,"upload":35442,"latency":15,"distance":50,"country_code":"RU","server_id":2707,"server_name":"Bryansk","sponsor_name":"DOM.RU","sponsor_url":null,"connection_mode":"multi","isp_name":"Resource Link","isp_rating":"4.0","test_rank":63,"test_grade":"B-","test_rating":4,"idle_latency":"17","download_latency":"116","upload_latency":"75","additional_servers":
[{"server_id":8191,"server_name":"Bryansk","sponsor_name":"SectorTelecom.ru"},{"server_id":46278,"server_name":"Fokino","sponsor_name":"Fokks - Promyshlennaya avtomatika Ltd."},{"server_id":18218,"server_name":"Bryansk","sponsor_name":"RIA-link Ltd."}],
"path":"result\u002F14708271987","hasSecondary":true
}
}
' | ConvertFrom-Json
$ookla.result
</code></pre>
<h1 id="yaml"><a class="header" href="#yaml">YAML</a></h1>
<pre><code class="language-PowerShell">Import-Module PSYaml` используется в Docker/Ansible
$netplan = "
network:` словарь по типу - ключ : значение с вложенными словарями
  ethernets:
    ens160:
      dhcp4: yes
      dhcp6: no
      nameservers:
        addresses:` [8.8.8.8, 1.1.1.1]` список данных (строк)
      - 8.8.8.8
      - 1.1.1.1
  version: 2
"
$network = ConvertFrom-Yaml $netplan
$network.Values.ethernets.ens160.nameservers

$DataType = "
int: !!int 10.1
flo: !!float 10.1
str: !!str string
bool: !!bool` boolean
"
</code></pre>
<h1 id="toml"><a class="header" href="#toml">TOML</a></h1>
<p><code>Install-Module -Name PSToml -Scope CurrentUser</code> Устанавливаем модуль для чтения toml (PSToml) <br />
<code>$toml = Get-Content "$home\Documents\Git\lifailon.github.io\hugo.toml"</code> Читаем содержимое конфигурации Hugo в формате toml <br />
<code>$json = ConvertFrom-Toml $toml | ConvertTo-Json -Depth 3</code> Конвертируем TOML в JSON <br />
<code>$json | Out-File "$home\Documents\Git\lifailon.github.io\hugo.json"</code> Сохраняем конфигурационный файл в формате JSON</p>
<h1 id="markdown"><a class="header" href="#markdown">Markdown</a></h1>
<h3 id="convert-markdown-to-html"><a class="header" href="#convert-markdown-to-html">Convert Markdown to HTML</a></h3>
<pre><code class="language-PowerShell">function ConvertFrom-MarkdownToHtml {
    param (
        [Parameter(Mandatory = $true,ValueFromPipeline = $true)]$Markdown
    )
    $html = $(Get-Content index.md -Raw | ConvertFrom-Markdown).html
    @"
  &lt;!DOCTYPE html&gt;
  &lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
  $html
  &lt;/body&gt;
  &lt;/html&gt;
  "@
}
</code></pre>
<p><code>Get-Content index.md -Raw | ConvertFrom-MarkdownToHtml | Out-File index.html</code></p>
<h3 id="psmarkdown"><a class="header" href="#psmarkdown">PSMarkdown</a></h3>
<p>Install-Module PSMarkdown</p>
<h3 id="convertfrom-markdownv2"><a class="header" href="#convertfrom-markdownv2">ConvertFrom-MarkdownV2</a></h3>
<pre><code class="language-PowerShell">Function ConvertFrom-MarkdownV2 {
    [CmdletBinding()]
    [OutputType([PSObject])]
    Param (
        [Parameter(
            Mandatory = $true,
            Position = 0,
            ValueFromPipeline = $true
        )]
        $InputObject
    )
    Begin {
        $items = @()
    }
    Process {
        $mddata = $InputObject
        $data = $mddata | Where-Object {$_ -notmatch "--" }
        $items += $data
    }
    End {
       $object = $items -replace ' +', '' | ConvertFrom-Csv -Delimiter '|'
       $object 
    }
}
</code></pre>
<h1 id="convertto-markdown"><a class="header" href="#convertto-markdown">ConvertTo-Markdown</a></h1>
<pre><code class="language-PowerShell">Function ConvertTo-Markdown {
    [CmdletBinding()]
    [OutputType([string])]
    Param (
        [Parameter(
            Mandatory = $true,
            Position = 0,
            ValueFromPipeline = $true
        )]
        [PSObject[]]$InputObject
    )
    Begin {
        $items = @()
        $columns = @{}
    }
    Process {
        ForEach($item in $InputObject) {
            $items += $item
            $item.PSObject.Properties | ForEach-Object {
                if($null -ne $_.Value) {
                    if(-not $columns.ContainsKey($_.Name) -or $columns[$_.Name] -lt $_.Value.ToString().Length) {
                        $columns[$_.Name] = $_.Value.ToString().Length
                    }
                }
            }
        }
    }
    End {
        ForEach($key in $($columns.Keys)) {
            $columns[$key] = [Math]::Max($columns[$key], $key.Length)
        }
        $header = @()
        ForEach($key in $columns.Keys) {
            $header += ('{0,-' + $columns[$key] + '}') -f $key
        }
        $header -join ' | '
        $separator = @()
        ForEach($key in $columns.Keys) {
            $separator += '-' * $columns[$key]
        }
        $separator -join ' | '
        ForEach($item in $items) {
            $values = @()
            ForEach($key in $columns.Keys) {
                $values += ('{0,-' + $columns[$key] + '}') -f $item.($key)
            }
            $values -join ' | '
        }
    }
}
</code></pre>
<h1 id="html"><a class="header" href="#html">HTML</a></h1>
<h3 id="convertfrom-html"><a class="header" href="#convertfrom-html">ConvertFrom-Html</a></h3>
<pre><code class="language-PowerShell">function ConvertFrom-Html {
    param (
        [Parameter(ValueFromPipeline)]$url
    )
    $irm = Invoke-RestMethod $url
    $HTMLFile = New-Object -ComObject HTMLFile
    $Bytes = [System.Text.Encoding]::Unicode.GetBytes($irm)
    $HTMLFile.write($Bytes)
    ($HTMLFile.all | where {$_.tagname -eq "body"}).innerText
}

$apache_status = "http://192.168.3.102/server-status"
$apache_status | ConvertFrom-Html
</code></pre>
<h3 id="convertto-html"><a class="header" href="#convertto-html">ConvertTo-Html</a></h3>
<p><code>Get-Process | select Name, CPU | ConvertTo-Html -As Table &gt; "$home\desktop\proc-table.html"</code> вывод в формате List (Format-List) или Table (Format-Table)</p>
<pre><code class="language-PowerShell">$servers = "ya.ru","ya.com","google.com"
$path = "$home\Desktop\Ping.html" 
$header = @"
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"&gt;
&lt;head&gt;
&lt;title&gt;Отчет о статусе серверов&lt;/title&gt;
&lt;style type="text/css"&gt;
&lt;!--
body {
background-color: #E0E0E0;
font-family: sans-serif
}
table, th, td {
background-color: white;
border-collapse:collapse;
border: 1px solid black;
padding: 5px
}
--&gt;
&lt;/style&gt;
"@
$body = @"
&lt;h1&gt;Ping status&lt;/h1&gt;
&lt;p&gt;$(get-date -Format "dd.MM.yyyy hh:mm").&lt;/p&gt;
"@
$results = foreach ($server in $servers) { 
    if (Test-Connection $server -Count 1 -ea 0 -Quiet) { 
        $status = "Up" 
    }
    else { 
        $status = "Down"
    }
    [PSCustomObject]@{
        Name = $server
        Status = $status
    }
}
$results | ConvertTo-Html -head $header -body $body | foreach {
    $_ -replace "&lt;td&gt;Down&lt;/td&gt;","&lt;td style='background-color:#FF8080'&gt;Down&lt;/td&gt;" -replace "&lt;td&gt;Up&lt;/td&gt;","&lt;td style='background-color:#5BCCF3'&gt;Up&lt;/td&gt;"
} | Out-File $path
Invoke-Item $path
</code></pre>
<h3 id="pswritehtml"><a class="header" href="#pswritehtml">PSWriteHTML</a></h3>
<pre><code class="language-PowerShell">Import-Module PSWriteHTML
(Get-Module PSWriteHTML).ExportedCommands
Get-Service | Out-GridHtml -FilePath ~\Desktop\Get-Service-Out-GridHtml.html
</code></pre>
<h3 id="htmlreport"><a class="header" href="#htmlreport">HtmlReport</a></h3>
<pre><code class="language-PowerShell">Import-Module HtmlReport
$topVM = ps | Sort PrivateMemorySize -Descending | Select -First 10 | %{,@(($_.ProcessName + " " + $_.Id), $_.PrivateMemorySize)}
$topCPU = ps | Sort CPU -Descending | Select -First 10 | %{,@(($_.ProcessName + " " + $_.Id), $_.CPU)}
New-Report -Title "Piggy Processes" -Input {
New-Chart Bar "Top VM Users" -input $topVm
New-Chart Column "Top CPU Overall" -input $topCPU
ps | Select ProcessName, Id, CPU, WorkingSet, *MemorySize | New-Table "All Processes"
} &gt; ~\Desktop\Get-Process-HtmlReport.html
</code></pre>
<h1 id="htmlagilitypack"><a class="header" href="#htmlagilitypack">HtmlAgilityPack</a></h1>
<p><a href="https://www.nuget.org/packages/HtmlAgilityPack">Source</a></p>
<pre><code class="language-PowerShell"># Загрузка библиотеки C#, которая позволяет парсить HTML-документы, выбирать элементы DOM и извлекать из них данные
Add-Type -Path "C:\Users\Lifailon\Downloads\HtmlAgilityPack\Net40\HtmlAgilityPack.dll"
$title = "новобранец"
$url = "http://fasts-torrent.net"
$ep = "engine/ajax/search_torrent.php?title=$title"
$html = Invoke-RestMethod "$url/$ep"
# Создание нового объекта HtmlDocument из HtmlAgilityPack, который будет использоваться для загрузки и обработки HTML-кода
$HtmlDocument = New-Object HtmlAgilityPack.HtmlDocument
# Загрузка HTML в созданный объект HtmlDocument
$HtmlDocument.LoadHtml($html)
$torrents = @()
# Использование XPath для выбора всех элементов &lt;tr&gt; (строк таблицы) в документе
$HtmlDocument.DocumentNode.SelectNodes("//tr") | ForEach-Object {
    # Для каждой строки таблицы выбираем классы, соответствующие названию раздачи, размеру и ссылке для скачивания.
    $titleNode = $_.SelectSingleNode(".//td[@class='torrent-title']")
    $sizeNode = $_.SelectSingleNode(".//td[@class='torrent-sp']")
    $downloadLinkNode = $_.SelectSingleNode(".//td[@class='torrent-d-btn']/a")
    # Проверяем, что все классы найдены
    if ($titleNode -ne $null -and $sizeNode -ne $null -and $downloadLinkNode -ne $null) {
        # Извлечение текста из классов
        $title = $titleNode.InnerText.Trim()
        $size = $sizeNode.InnerText.Trim()
        $downloadLink = $downloadLinkNode.Attributes["href"].Value
        $torrent = New-Object PSObject -Property @{
            Title = $title
            Size = $size
            DownloadLink = "$($url)$($downloadLink)"
        }
        $torrents += $torrent
    }
}
</code></pre>
<p><code>$torrents</code></p>
<pre><code class="language-PowerShell">Title                                                                    Size     DownloadLink
-----                                                                    ----     ------------
Новобранец (6 сезон: 1-3 серии из 13) (2024) WEBRip | RuDub              1,55 ГБ  http://fasts-torrent.net/download/449613/torrent/-6-1-3-13-2024-webrip-rudub/
Новобранец (5 сезон: 1-22 серии из 22) (2023) WEBRip 1080p | RuDub       54,15 ГБ http://fasts-torrent.net/download/433749/torrent/-5-1-22-22-2023-webrip-1080p-rudub/
Новобранец (5 сезон: 1-22 серии из 22) (2023) WEBRip 720p | RuDub        30,14 ГБ http://fasts-torrent.net/download/433750/torrent/-5-1-22-22-2023-webrip-720p-rudub/
Новобранец (5 сезон: 1-22 серии из 22) (2023) WEBRip | RuDub             11,55 ГБ http://fasts-torrent.net/download/433751/torrent/-5-1-22-22-2023-webrip-rudub/
Новобранец (4 сезон: 1-22 серии из 22) (2021) WEB-DL 720p | RG.Paravozik 21.33 Gb http://fasts-torrent.net/download/418618/torrent/-4-1-22-22-2021-web-dl-720p-rgparavozik/
Полицейский с половиной: Новобранец (2017) WEB-DLRip 720p| Чистый звук   3.41 Gb  http://fasts-torrent.net/download/254846/torrent/-2017-web-dlrip-720p-/
Полицейский с половиной: Новобранец (2017) WEB-DLRip | Чистый звук       1.37 Gb  http://fasts-torrent.net/download/254845/torrent/-2017-web-dlrip-/
Новобранец (2 сезон: 1-20 серии из 20) (2019) WEBRip | BaibaKo           11.28 Gb http://fasts-torrent.net/download/364669/torrent/-2-1-20-20-2019-webrip-baibako/
Новобранец (2 сезон: 1-20 серии из 20) (2019) WEBRip 1080p | Octopus     45.97 Gb http://fasts-torrent.net/download/364161/torrent/-2-1-20-20-2019-webrip-1080p-octopus/
Новобранец (2 сезон: 1-20 серии из 20) (2019) WEB-DLRip | LostFilm       11.95 Gb http://fasts-torrent.net/download/364668/torrent/-2-1-20-20-2019-web-dlrip-lostfilm/
</code></pre>
<h1 id="wmi"><a class="header" href="#wmi">WMI</a></h1>
<h3 id="windows-management-instrumentation"><a class="header" href="#windows-management-instrumentation">Windows Management Instrumentation</a></h3>
<p><code>Get-WmiObjec -ComputerName localhost -Namespace root -class "__NAMESPACE" | select name,__namespace</code> отобразить дочернии Namespace (логические иерархические группы) <br />
<code>Get-WmiObject -List</code> отобразить все классы пространства имен "root\cimv2" (по умолчанию), свойства (описывают конфигурацию и текущее состояние управляемого ресурса) и их методы (какие действия позволяет выполнить над этим ресурсом) <br />
<code>Get-WmiObject -List | Where-Object {$_.name -match "video"}</code> поиск класса по имени, его свойств и методов <br />
<code>Get-WmiObject -ComputerName localhost -Class Win32_VideoController</code> отобразить содержимое свойств класса</p>
<p><code>gwmi -List | where name -match "service" | ft -auto</code> если в таблице присутствуют Methods, то можно взаимодействовать {StartService, StopService} <br />
<code>gwmi -Class win32_service | select *</code> отобразить список всех служб и всех их свойств <br />
<code>Get-CimInstance Win32_service</code> обращается на прямую к "root\cimv2" <br />
<code>gwmi win32_service -Filter "name='Zabbix Agent'"</code> отфильтровать вывод по имени <br />
<code>(gwmi win32_service -Filter "name='Zabbix Agent'").State</code> отобразить конкретное свойство <br />
<code>gwmi win32_service -Filter "State = 'Running'"</code> отфильтровать запущенные службы <br />
<code>gwmi win32_service -Filter "StartMode = 'Auto'"</code> отфильтровать службы по методу запуска <br />
<code>gwmi -Query 'select * from win32_service where startmode="Auto"'</code> WQL-запрос (WMI Query Language) <br />
<code>gwmi win32_service | Get-Member -MemberType Method</code> отобразить все методы взаимодействия с описание применения (Delete, StartService) <br />
<code>(gwmi win32_service -Filter 'name="Zabbix Agent"').Delete()</code> удалить службу <br />
<code>(gwmi win32_service -Filter 'name="MSSQL$MSSQLE"').StartService()</code> запустить службу</p>
<p><code>Get-CimInstance -ComputerName $srv Win32_OperatingSystem | select LastBootUpTime</code> время последнего включения <br />
<code>gwmi -ComputerName $srv -Class Win32_OperatingSystem | select LocalDateTime,LastBootUpTime</code> текущее время и время последнего включения <br />
<code>gwmi Win32_OperatingSystem | Get-Member -MemberType Method</code> методы reboot и shutdown <br />
<code>(gwmi Win32_OperatingSystem -EnableAllPrivileges).Reboot()</code> используется с ключем повышения привелегий <br />
<code>(gwmi Win32_OperatingSystem -EnableAllPrivileges).Win32Shutdown(0)</code> завершение сеанса пользователя</p>
<pre><code class="language-PowerShell">$system = Get-WmiObject -Class Win32_OperatingSystem
$InstallDate = [Management.ManagementDateTimeconverter]::ToDateTime($system.installdate)` Получаем дату установки ОС
$AfterInstallDays = ((Get-Date) — $Installdate).Days` Вычисляем время, прошедшее с момента установки
$ShortInstallDate = "{0:yyyy-MM-dd HH:MM}" -f ($InstallDate)
"Система установлена: $ShortInstallDate (Прошло $AfterInstalldays дней)"
</code></pre>
<p><code>(Get-WmiObject win32_battery).estimatedChargeRemaining</code> заряд батареи в процентах <br />
<code>gwmi Win32_UserAccount</code> доменные пользователи <br />
<code>(gwmi Win32_SystemUsers).PartComponent</code> <br />
<code>Get-CimInstance -ClassName Win32_LogonSession</code> <br />
<code>Get-CimInstance -ClassName Win32_BIOS</code></p>
<p><code>gwmi -list -Namespace root\CIMV2\Terminalservices</code> <br />
<code>(gwmi -Class Win32_TerminalServiceSetting -Namespace root\CIMV2\TerminalServices).AllowTSConnections</code> <br />
<code>(gwmi -Class Win32_TerminalServiceSetting -Namespace root\CIMV2\TerminalServices).SetAllowTSConnections(1)</code> включить RDP</p>
<pre><code>$srv = "localhost"
gwmi Win32_logicalDisk -ComputerName $srv | where {$_.Size -ne $null} | select @{
Label="Value"; Expression={$_.DeviceID}}, @{Label="AllSize"; Expression={
[string]([int]($_.Size/1Gb))+" GB"}},@{Label="FreeSize"; Expression={
[string]([int]($_.FreeSpace/1Gb))+" GB"}}, @{Label="Free%"; Expression={
[string]([int]($_.FreeSpace/$_.Size*100))+" %"}}
</code></pre>
<h3 id="network-level-authentication"><a class="header" href="#network-level-authentication">Network Level Authentication</a></h3>
<p><code>(gwmi -class "Win32_TSGeneralSetting" -Namespace root\cimv2\Terminalservices -Filter "TerminalName='RDP-tcp'").UserAuthenticationRequired</code> <br />
<code>(gwmi -class "Win32_TSGeneralSetting" -Namespace root\cimv2\Terminalservices -Filter "TerminalName='RDP-tcp'").SetUserAuthenticationRequired(1)</code> включить NLA <br />
<code>Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name SecurityLayer</code> отобразить значение (2) <br />
<code>Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name UserAuthentication</code> отобразить значение (1) <br />
<code>Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name SecurityLayer -Value 0</code> изменить значение <br />
<code>Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name UserAuthentication -Value 0</code> <br />
<code>REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\CredSSP\Parameters /v AllowEncryptionOracle /t REG_DWORD /d 2</code> отключить на клиентском компьютере проверку версии CredSSP, если на целевом комьютере-сервере не установлены обновления KB4512509 от мая 2018 года</p>
<h1 id="regedit"><a class="header" href="#regedit">Regedit</a></h1>
<p><code>Get-PSDrive</code> список всех доступных дисков/разделов, их размер и веток реестра <br />
<code>cd HKLM:\</code> HKEY_LOCAL_MACHINE <br />
<code>cd HKCU:\</code> HKEY_CURRENT_USER <br />
<code>Get-Item</code> получить информацию о ветке реестра <br />
<code>New-Item</code> создать новый раздел реестра <br />
<code>Remove-Item</code> удалить ветку реестра <br />
<code>Get-ItemProperty</code> получить значение ключей/параметров реестра (это свойства ветки реестра, аналогично свойствам файла) <br />
<code>Set-ItemProperty</code> изменить название или значение параметра реестра <br />
<code>New-ItemProperty</code> создать параметр реестра <br />
<code>Remove-ItemProperty</code> удалить параметр</p>
<p><code>Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select DisplayName</code> список установленных программ <br />
<code>Get-Item HKCU:\SOFTWARE\Microsoft\Office\16.0\Outlook\Profiles\Outlook\9375CFF0413111d3B88A00104B2A6676\00000002</code> посмотреть содержимое Items <br />
<code>(Get-ItemProperty HKCU:\SOFTWARE\Microsoft\Office\16.0\Outlook\Profiles\Outlook\9375CFF0413111d3B88A00104B2A6676\00000002)."New Signature"</code> отобразить значение (Value) свойства (Property) Items <br />
<code>$reg_path = "HKCU:\SOFTWARE\Microsoft\Office\16.0\Outlook\Profiles\Outlook\9375CFF0413111d3B88A00104B2A6676\00000002"</code> <br />
<code>$sig_name = "auto"</code> <br />
<code>Set-ItemProperty -Path $reg_path -Name "New Signature" -Value $sig_name</code> изменить или добавить в корне ветки (Path) свойство (Name) со значением (Value) <br />
<code>Set-ItemProperty -Path $reg_path -Name "Reply-Forward Signature" -Value $sig_name</code></p>
<pre><code>Windows Registry Editor Version 5.00
[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskmgr.exe]
"Debugger"="\"C:\\Windows\\System32\\Taskmgr.exe\""
</code></pre>
<h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<p><code>lodctr /R</code> пересоздать счетчиков производительности из системного хранилища архивов (так же исправляет счетчики для CIM, например, для cpu Win32_PerfFormattedData_PerfOS_Processor и iops Win32_PerfFormattedData_PerfDisk_PhysicalDisk) <br />
<code>(Get-Counter -ListSet *).CounterSetName</code> вывести список всех доступных счетчиков производительности в системе <br />
<code>(Get-Counter -ListSet *memory*).Counter</code> поиск по wildcard-имени во всех счетчиках (включая дочернии) <br />
<code>Get-Counter "\Memory\Available MBytes"</code> объем свободной оперативной памяти <br />
<code>Get-Counter -cn $srv "\LogicalDisk(*)\% Free Space"</code> % свободного места на всех разделах дисков <br />
<code>(Get-Counter "\Process(*)\ID Process").CounterSamples</code> <br />
<code>Get-Counter "\Processor(_Total)\% Processor Time" –ComputerName $srv -MaxSamples 5 -SampleInterval 2</code> 5 проверок каждые 2 секунды <br />
<code>Get-Counter "\Процессор(_Total)\% загруженности процессора" -Continuous</code> непрерывно <br />
<code>(Get-Counter "\Процессор(*)\% загруженности процессора").CounterSamples</code></p>
<p><code>(Get-Counter -ListSet *интерфейс*).Counter</code> найти все счетчики <br />
<code>Get-Counter "\Сетевой интерфейс(*)\Всего байт/с"</code> отобразить все адаптеры (выбрать действующий по трафику)</p>
<pre><code class="language-PowerShell">$WARNING = 25
$CRITICAL = 50
$TransferRate = ((Get-Counter "\\huawei-mb-x-pro\сетевой интерфейс(intel[r] wi-fi 6e ax211 160mhz)\всего байт/с"
).countersamples | select -ExpandProperty CookedValue)*8
$NetworkUtilisation = [math]::round($TransferRate/1000000000*100,2)
if ($NetworkUtilisation -gt $CRITICAL){
Write-Output "CRITICAL: $($NetworkUtilisation) % Network utilisation, $($TransferRate.ToString('N0')) b/s"   
#exit 2		
}
if ($NetworkUtilisation -gt $WARNING){
Write-Output "WARNING: $($NetworkUtilisation) % Network utilisation, $($TransferRate.ToString('N0')) b/s"
#exit 1
}
Write-Output "OK: $($NetworkUtilisation) % Network utilisation, $($TransferRate.ToString('N0')) b/s"   
#exit 0
</code></pre>
<h1 id="snmp"><a class="header" href="#snmp">SNMP</a></h1>
<h3 id="setup-snmp-service"><a class="header" href="#setup-snmp-service">Setup SNMP Service</a></h3>
<p><code>Install-WindowsFeature SNMP-Service,SNMP-WMI-Provider -IncludeManagementTools</code> установить роль SNMP и WMI провайдер через Server Manager <br />
<code>Get-WindowsFeature SNMP*</code> <br />
<code>Add-WindowsCapability -Online -Name SNMP.Client~~~~0.0.1.0</code> установить компонент Feature On Demand для Windows 10/11<code>\ </code>Get-Service SNMP*<code>\ </code>Get-NetFirewallrule -DisplayName <em>snmp</em> | ft<code>\ </code>Get-NetFirewallrule -DisplayName <em>snmp</em> | Enable-NetFirewallRule`</p>
<h3 id="setting-snmp-service-via-regedit"><a class="header" href="#setting-snmp-service-via-regedit">Setting SNMP Service via Regedit</a></h3>
<p>Agent: <br />
<code>New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\services\SNMP\Parameters\RFC1156Agent" -Name "sysContact" -Value "lifailon-user"</code> создать (New) или изменить (Set) <br />
<code>New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\services\SNMP\Parameters\RFC1156Agent" -Name "sysLocation" -Value "plex-server"</code></p>
<p>Security: <br />
<code>New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\services\SNMP\Parameters\TrapConfiguration\public"</code> создать новый community string <br />
<code>New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\SNMP\Parameters\ValidCommunities" -Name "public" -Value 16</code> назначить права на public <br />
<code>1 — NONE</code> <br />
<code>2 — NOTIFY</code> позволяет получать SNMP ловушки <br />
<code>4 — READ ONLY</code> позволяет получать данные с устройства <br />
<code>8 — READ WRITE</code> позволяет получать данные и изменять конфигурацию устройства <br />
<code>16 — READ CREATE</code> позволяет читать данные, изменять и создавать объекты <br />
<code>New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\SNMP\Parameters\PermittedManagers" -Name "1" -Value "192.168.3.99"</code> от кого разрешено принимать запросы <br />
<code>Get-Service SNMP | Restart-Service</code></p>
<h3 id="snmpwalk"><a class="header" href="#snmpwalk">snmpwalk</a></h3>
<p><code>snmpwalk -v 2c -c public 192.168.3.100</code> <br />
<code>snmpwalk -v 2c -c public -O e 192.168.3.100</code></p>
<h3 id="snmp-modules"><a class="header" href="#snmp-modules">SNMP Modules</a></h3>
<p><code>Install-Module -Name SNMP</code> <br />
<code>Get-SnmpData -IP 192.168.3.100 -OID 1.3.6.1.2.1.1.4.0 -UDPport 161 -Community public</code> <br />
<code>(Get-SnmpData -IP 192.168.3.100 -OID 1.3.6.1.2.1.1.4.0).Data</code> <br />
<code>Invoke-SnmpWalk -IP 192.168.3.100 -OID 1.3.6.1.2.1.1</code> пройтись по дереву OID <br />
<code>Invoke-SnmpWalk -IP 192.168.3.100 -OID 1.3.6.1.2.1.25.6.3.1.2</code> список установленного ПО <br />
<code>Invoke-SnmpWalk -IP 192.168.3.100 -OID 1.3.6.1.2.1.25.2.3.1</code> список разделов и памяти (C: D: Virtual Memory и Physical Memory) <br />
<code>Set-SnmpData</code> изменение данных на удаленном устройстве</p>
<p><code>Install-Module -Name SNMPv3</code> <br />
<code>Invoke-SNMPv3Get</code> получение данных по одному OID <br />
<code>Invoke-SNMPv3Set</code> изменение данных <br />
<code>Invoke-SNMPv3Walk</code> обход по дереву OID <br />
<code>Invoke-SNMPv3Walk -UserName lifailon -Target 192.168.3.100 -AuthSecret password -PrivSecret password -OID 1.3.6.1.2.1.1 -AuthType MD5 -PrivType AES128</code></p>
<h3 id="lextm-sharpsnmplib"><a class="header" href="#lextm-sharpsnmplib">Lextm SharpSnmpLib</a></h3>
<p><a href="https://learn.microsoft.com/ru-ru/powershell/dsc/reference/resources/windows/fileresource?view=dsc-1.1">Синтаксис</a> <br />
<a href="https://api.nuget.org/v3-flatcontainer/lextm.sharpsnmplib/12.5.2/lextm.sharpsnmplib.12.5.2.nupkg">Download lib</a></p>
<p><code>Add-Type -LiteralPath "$home\Desktop\lextm.sharpsnmplib-12.5.2\net471\SharpSnmpLib.dll"</code></p>
<pre><code class="language-PowerShell">$port = 161
$OID = "1.3.6.1.2.1.1.4.0"
$variableList = New-Object Collections.Generic.List[Lextm.SharpSnmpLib.Variable]
$variableList.Add([Lextm.SharpSnmpLib.Variable]::new([Lextm.SharpSnmpLib.ObjectIdentifier]::new($OID)))
$timeout = 3000
[Net.IPAddress]$ip = "192.168.3.100"
$endpoint = New-Object Net.IpEndPoint $ip, $port
$Community = "public"
[Lextm.SharpSnmpLib.VersionCode]$Version = "V2"

$message = [Lextm.SharpSnmpLib.Messaging.Messenger]::Get(
$Version,
$endpoint,
$Community,
$variableList,
$TimeOut
)
$message.Data.ToString()
</code></pre>
<h3 id="walk"><a class="header" href="#walk">Walk</a></h3>
<pre><code class="language-PowerShell">[Lextm.SharpSnmpLib.ObjectIdentifier]$OID = "1.3.6.1.2.1.1" # дерево или конечный OID
$WalkMode = [Lextm.SharpSnmpLib.Messaging.WalkMode]::WithinSubtree # режим обхода по дереву
$results = New-Object Collections.Generic.List[Lextm.SharpSnmpLib.Variable]
$message = [Lextm.SharpSnmpLib.Messaging.Messenger]::Walk(
  $Version,
  $endpoint,
  $Community,
  $OID,
  $results,
  $TimeOut,
  $WalkMode
)
$results

$results2 = @()
foreach ($d in $results) {
$results2 +=[PSCustomObject]@{'ID'=$d.id.ToString();'Data'=$d.Data.ToString()} # перекодировать вывод построчно в строку
}
$results2
</code></pre>
<h1 id="packagemanagement"><a class="header" href="#packagemanagement">PackageManagement</a></h1>
<p><code>Import-Module PackageManagement</code> импортировать модуль <br />
<code>Get-Module PackageManagement</code> информация о модуле <br />
<code>Get-Command -Module PackageManagement</code> отобразить все командлеты модуля <br />
<code>Get-Package</code> отобразить все установленные пакеты PowerShellGallery <br />
<code>Get-Package -ProviderName msi,Programs</code> список установленных программ
<code>[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12</code> включить использование протокол TLS 1.2 (если не отключены протоколы TLS 1.0 и 1.1) <br />
<code>Get-PackageSource</code> источники установки пакетов <br />
<code>Get-PackageProvider</code> отобразить список провайдеров менеджеров пакетов <br />
<code>Get-PackageProvider | Where-Object Name -Match nuget</code> <br />
<code>Find-PackageProvider</code> отображение всех доступных менеджеров пакетов <br />
<code>Find-PackageProvider nuget</code> <br />
<code>Install-PackageProvider NuGet -Force</code> установить менеджер пакетов nuget <br />
<code>Install-PackageProvider PSGallery -Force</code> установить источник <br />
<code>Install-PackageProvider Chocolatey -Force</code> <br />
<code>Set-PackageSource nuget -Trusted</code> разрешить установку пакетов из указанного источника <br />
<code>Register-PSRepository -Name "NuGet" -SourceLocation "https://www.nuget.org/api/v2" -InstallationPolicy Trusted</code> зарегестрировать менеджер пакетов используя url (работает для Power Shell Core) <br />
<code>Set-PackageSource -Name NuGet -Trusted</code> изменить источник по умолчанию <br />
<code>Find-Package PSEverything</code> поиск пакетов по имени во всех менеджерах <br />
<code>Find-Package PSEverything -Provider NuGet</code> поиск пакета у выбранного провайдера <br />
<code>Install-Module PSEverything -Scope CurrentUser</code> установить модуль для текущего пользователя <br />
<code>Install-Package -Name VeeamLogParser -ProviderName PSGallery -scope CurrentUser</code> <br />
<code>Get-Command *Veeam*</code> <br />
<code>Import-Module -Name VeeamLogParser</code> загрузить модуль <br />
<code>Get-Module VeeamLogParser | select -ExpandProperty ExportedCommands</code> отобразить список функций</p>
<h3 id="winget"><a class="header" href="#winget">winget</a></h3>
<p><a href="https://github.com/microsoft/winget-cli">Source</a>
<a href="https://winget.run">Web</a></p>
<p><code>winget list</code> список установленных пакетов <br />
<code>winget search VLC</code> найти пакет <br />
<code>winget show VideoLAN.VLC</code> информация о пакете <br />
<code>winget show VideoLAN.VLC --versions</code> список доступных версий в репозитории <br />
<code>winget install VideoLAN.VLC</code> установить пакет <br />
<code>winget uninstall VideoLAN.VLC</code> удалить пакет <br />
<code>winget download jqlang.jq</code> загрузкить пакет (https://github.com/jqlang/jq/releases/download/jq-1.7/jq-windows-amd64.exe) <br />
<code>winget install jqlang.jq</code> добавляет в переменную среду и псевдоним командной строки jq <br />
<code>winget uninstall jqlang.jq</code></p>
<h3 id="jqlang"><a class="header" href="#jqlang">jqlang</a></h3>
<pre><code class="language-PowerShell">[uri]$url = $($(irm https://api.github.com/repos/jqlang/jq/releases/latest).assets.browser_download_url -match "windows-amd64").ToString() # получить версию latest на GitHub
irm $url -OutFile "C:\Windows\System32\jq.exe" # загрузить jq.exe
</code></pre>
<h3 id="scoop"><a class="header" href="#scoop">Scoop</a></h3>
<p><code>Set-ExecutionPolicy RemoteSigned -Scope CurrentUser</code> <br />
<code>irm get.scoop.sh | iex</code> установка <br />
<code>scoop help</code> <br />
<code>scoop search jq</code> <br />
<code>scoop info jq</code> <br />
<code>(scoop info jq).version</code> <br />
<code>scoop cat jq</code> <br />
<code>scoop download jq</code> C:\Users\lifailon\scoop\cache <br />
<code>scoop install jq</code> C:\Users\lifailon\scoop\apps\jq\1.7 <br />
<code>scoop list</code> <br />
<code>(scoop list).version</code> <br />
<code>scoop uninstall jq</code></p>
<h3 id="chocolatey"><a class="header" href="#chocolatey">Chocolatey</a></h3>
<pre><code class="language-PowerShell">Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
</code></pre>
<p><code>choco -v</code> <br />
<code>choco -help</code> <br />
<code>choco list</code> <br />
<code>choco install adobereader</code></p>
<h1 id="nuget"><a class="header" href="#nuget">NuGet</a></h1>
<p><code>Invoke-RestMethod https://dist.nuget.org/win-x86-commandline/latest/nuget.exe -OutFile "$home\Documents\nuget.exe"</code> <br />
<code>Invoke-Expression "$home\Documents\nuget.exe search Selenium.WebDriver"</code> <br />
<code>Invoke-Expression "$home\Documents\nuget.exe install Selenium.WebDriver"</code> <br />
<code>Get-Item $home\Documents\*Selenium*</code></p>
<p><code>&amp; "$home\Documents\nuget.exe" list console-translate</code> <br />
<code>$nuget_api_key = "&lt;API-KEY&gt;"</code> <br />
<code>$source = "https://api.nuget.org/v3/index.json"</code> <br />
<code>$Name = "Console-Translate"</code> <br />
<code>$path = "$home\Documents\$Name"</code> <br />
<code>New-Item -Type Directory $path</code> <br />
<code>Copy-Item "$home\Documents\Git\$Name\$Name\0.2\*" "$path\"</code> <br />
<code>Copy-Item "$home\Documents\Git\$Name\LICENSE" "$path\"</code> <br />
<code>Copy-Item "$home\Documents\Git\$Name\README.md" "$path\"</code></p>
<pre><code class="language-xml">'&lt;?xml version="1.0"?&gt;
&lt;package &gt;
  &lt;metadata&gt;
    &lt;id&gt;Console-Translate&lt;/id&gt;
    &lt;version&gt;0.2.2&lt;/version&gt;
    &lt;authors&gt;Lifailon&lt;/authors&gt;
    &lt;owners&gt;Lifailon&lt;/owners&gt;
    &lt;description&gt;Cross-platform client for translating text in the console, uses API Google (edded public free token), MyMemory and DeepLX (no token required)&lt;/description&gt;
    &lt;tags&gt;PowerShell, Module, Translate, api&lt;/tags&gt;
    &lt;repository type="git" url="https://github.com/Lifailon/Console-Translate" /&gt;
    &lt;projectUrl&gt;https://github.com/Lifailon/Console-Translate&lt;/projectUrl&gt;
    &lt;licenseUrl&gt;https://github.com/Lifailon/Console-Translate/blob/rsa/LICENSE&lt;/licenseUrl&gt;
    &lt;contentFiles&gt;
      &lt;files include="Console-Translate.psm1" buildAction="Content" /&gt;
      &lt;files include="Console-Translate.psd1" buildAction="Content" /&gt;
      &lt;files include="lang-iso-639-1.csv" buildAction="Content" /&gt;
      &lt;files include="README.md" buildAction="Content" /&gt;
      &lt;files include="LICENSE" buildAction="Content" /&gt;
    &lt;/contentFiles&gt;
  &lt;/metadata&gt;
&lt;/package&gt;' &gt; "$path\$Name.nuspec"
</code></pre>
<p><code>Set-Location $path</code> <br />
<code>&amp; "$home\Documents\nuget.exe" pack "$path\$Name.nuspec"</code> <br />
<code>&amp; "$home\Documents\nuget.exe" push "$path\$Name.0.2.2.nupkg" -ApiKey $nuget_api_key -Source $source</code> <br />
<code>&amp; "$home\Documents\nuget.exe" push "$path\$Name.0.2.2.nupkg" -ApiKey $nuget_api_key -Source $source -SkipDuplicate</code></p>
<p><code>Install-Package Console-Translate -Source nuget.org</code> <br />
<code>Get-Package Console-Translate | select *</code></p>
<p><code>Register-PSRepository -Name "NuGet" -SourceLocation "https://www.nuget.org/api/v2" -InstallationPolicy Trusted</code> <br />
<code>Get-PSRepository</code> <br />
<code>Find-Module -Name Console-Translate</code> <br />
<code>Install-Module Console-Translate -Repository NuGet</code></p>
<p><code>&amp; "$home\Documents\nuget.exe" delete Console-Translate 0.2.0 -Source https://api.nuget.org/v3/index.json -ApiKey $nuget_api_key -NoPrompt</code></p>
<h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<h3 id="get-query"><a class="header" href="#get-query">Get-Query</a></h3>
<p><code>Install-Module Get-Query -Repository NuGet</code> установить модуль <br />
<code>Get-Help Get-Query</code> <br />
<code>Get-Query localhost</code> отобразить всех авторизованных пользователей, их статус и время работы (по умолчанию localhost) <br />
<code>Get-Query 192.168.1.1.1 -proc</code> список всех пользовательских процессов (по умолчанию -user *) <br />
<code>Get-Query 192.168.1.1.1 -proc -user username</code> список процессов указанного пользователя</p>
<h3 id="console-translate"><a class="header" href="#console-translate">Console-Translate</a></h3>
<p><code>Install-Module Console-Translate -Repository NuGet</code> <br />
<code>Get-Translate "Module for text translation"</code> <br />
<code>Get-Translate "Модуль для перевода текста"</code> <br />
<code>Get-Translate "Привет world" -LanguageSelected</code> т.к. больше латинских символов (на 1), то перевод будет произведен на английский язык <br />
<code>Get-Translate "Hello друг" -LanguageSelected</code> перевод на русский язык <br />
<code>Get-Translate -Text "Модуль для перевода текста" -LanguageSource ru -LanguageTarget tr</code> <br />
<code>Get-Translate -Provider MyMemory -Text "Hello World" -Alternatives</code> выбрать провайдер перевода и добавить альтернативные варианты вывода <br />
<code>Get-DeepLX "Get select" ru</code> <br />
<code>Start-DeepLX -Job</code> запустить сервер в режиме процесса <br />
<code>Start-DeepLX -Status</code> <br />
<code>Get-DeepLX -Server 192.168.3.99 -Text "Module for text translation" ru</code> <br />
<code>Stop-DeepLX</code> <br />
<code>Get-LanguageCode</code> получение кодов языков по стандарту ISO-639-1</p>
<h3 id="console-download"><a class="header" href="#console-download">Console-Download</a></h3>
<p><code>Install-Module Console-Download -Repository NuGet</code> устаовить модуль из менеджера пакетов NuGet <br />
<code>Invoke-Expression $(Invoke-RestMethod "https://raw.githubusercontent.com/Lifailon/Console-Download/rsa/module/Console-Download/Console-Download.psm1")</code> или импортировать модуль из GitHub репозитория в текущую сессию PowerShell <br />
<code>Invoke-Download -Url "https://github.com/PowerShell/PowerShell/releases/download/v7.4.2/PowerShell-7.4.2-win-x64.zip"</code> загрузить файл в один поток с отображением скорости загрузки в реальном времен (путь загрузки файла по умолчанию: $home\downloads) <br />
<code>Invoke-Download -Url "https://github.com/PowerShell/PowerShell/releases/download/v7.4.2/PowerShell-7.4.2-win-x64.zip" -Thread 3</code> загрузить один и тотже файл в 3 потока (создается 3 файла, доступно от 1 до 20 потоков)</p>
<pre><code class="language-PowerShell">$urls = @(
    "https://github.com/PowerShell/PowerShell/releases/download/v7.4.2/PowerShell-7.4.2-win-x64.zip",
    "https://github.com/Lifailon/helperd/releases/download/0.0.1/Helper-Desktop-Setup-0.0.1.exe"
)
Invoke-Download $urls # загрузить параллельно 2 файла
</code></pre>
<p><code>$urls = Get-Content "$home\Desktop\links.txt"</code> <br />
<code>Invoke-Download $urls</code> передайте список URL-адресов из файла для загрузки файлов, эквивалентному числу url</p>
<p><code>$urls = Get-LookingGlassList</code> отобразить актуальный список конечных точек Looking Glass через Looking.House (выдает 3 ссылки на загрузку файлов по 10, 100 и 1000 мбайт для каждого региона) <br />
<code>$usaNy = $urls | Where-Object region -like *USA*New*York*</code> отфильтровать список по региону и городу <br />
<code>$url = $usaNy[0].url100mb</code> забрать первую ссылку с файлов на 100 МБайт <br />
<code>Invoke-Download $url</code> начать загрузку файла <br />
<code>Invoke-Download $url -Thread 3</code> начать загрузку 3-х одинаковых файлов</p>
<h3 id="pseverything"><a class="header" href="#pseverything">PSEverything</a></h3>
<p><code>Install-Module PSEverything -Repository NuGet</code> <br />
<code>Find-Everything pingui</code> найти все файлы в системе (на всех локальных дисках) с именем <em>pingui</em> через dll csharp версии Everything (по умолчанию) <br />
<code>Find-Everything pingui-0.1.py | Format-List</code> <br />
<code>Find-Everything pingui -es</code> использовать cli версию Everything для поиска (при первом использовании версии, необходимо дождаться автоматической установки файлов зависимостей) <br />
<code>Find-Everything pingui-0.1 -ComputerName localhost</code> поиск на удаленном компьютере через REST API, если запущен HTTP-сервер Everything</p>
<h3 id="hardwaremonitor"><a class="header" href="#hardwaremonitor">HardwareMonitor</a></h3>
<p><code>Install-Module HardwareMonitor -Repository NuGet -Scope AllUsers</code> <br />
<code>Install-LibreHardwareMonitor</code> установить и запустить LibreHardwareMonitor в систему (https://github.com/LibreHardwareMonitor/LibreHardwareMonitor) <br />
<code>Install-OpenHardwareMonitor</code> установить OpenHardwareMonitor (https://github.com/openhardwaremonitor/openhardwaremonitor) <br />
<code>Get-Sensor | Where-Object {($_.SensorName -match "Temperature") -or ($_.SensorType -match "Temperature")} | Format-Table</code> использовать LibreHardwareMonitor и WMI/CIM (по умолчанию) и отфильтровать вывод по наименованию датчикам или типу сенсора для вывода датчиков температуры <br />
<code>Get-Sensor -Open</code> использовать OpenHardwareMonitor <br />
<code>Get-Sensor -ComputerName 192.168.3.99 -Port 8086 | Format-Table</code> вывести датчики системы через REST API <br />
<code>Get-Sensor -ComputerName 192.168.3.99 -Port 8085 -User hardware -Password monitor | Where-Object Value -notmatch "^0,0" | Format-Table</code> использовать авторизацию и отфильтровать вывод не пустых датчиков <br />
<code>Get-Sensor -Library | Where-Object Value -ne 0 | Format-Table</code> использовать динамическую библиотеку (dll) через .NET</p>
<h3 id="crystaldisk-cli"><a class="header" href="#crystaldisk-cli">CrystalDisk-Cli</a></h3>
<p><code>Install-Module CrystalDisk-Cli -Repository NuGet</code> <br />
<code>Get-DiskInfoSettings</code> отобразить настройки программы Crystal-DiskInfo (https://github.com/hiyohiyo/CrystalDiskInfo) <br />
<code>Get-DiskInfoSettings -AutoRefresh 5</code> изминить время сканирования на 5 минут <br />
<code>Get-DiskInfo -List</code> отобразить список дисков <br />
<code>Get-DiskInfo</code> получить результаты последнего сканирования (статус, температура и т.п.) <br />
<code>Get-DiskInfo -Report | Select-Object Name,Date,HealthStatus,Temperature</code> получить актуальный отчет (запустить сканирование и дождаться результатов)</p>
<h3 id="ps-pi-hole"><a class="header" href="#ps-pi-hole">PS-Pi-Hole</a></h3>
<pre><code class="language-PowerShell">$path_psm = ($env:PSModulePath.Split(";")[0])+"\Invoke-Pi-Hole\Invoke-Pi-Hole.psm1"
if (!(Test-Path $path_psm)) {
    New-Item $path_psm -ItemType File -Force
}
irm https://raw.githubusercontent.com/Lifailon/PS-Pi-Hole/rsa/Invoke-Pi-Hole/Invoke-Pi-Hole.psm1 | Out-File $path_psm -Force
</code></pre>
<p><code>sudo cat /etc/pihole/setupVars.conf | grep WEBPASSWORD</code> получить токен доступа <br />
<code>$Server = "192.168.1.253"</code> <br />
<code>$Token = "5af9bd44aebce0af6206fc8ad4c3750b6bf2dd38fa59bba84ea9570e16a05d0f"</code> <br />
<code>Invoke-Pi-Hole -Versions -Server $Server -Token $Token</code> получить текущую версию ядра (backend) и веб (frontend) на сервере а также последнюю доступную версию для обновления <br />
<code>Invoke-Pi-Hole -Releases -Server $Server -Token $Token</code> узнать последнюю доступную версию в репозитории на GitHub <br />
<code>Invoke-Pi-Hole -QueryLog -Server $Server -Token $Token</code> отобразить полный журнал запросов (клиент, домен назначения, тип записи, статус время запроса и адрес пересылки forward dns - куда ушел запрос) <br />
<code>Invoke-Pi-Hole -AdList -Server $Server -Token $Token</code> получить списки блокировак используемых на сервере (дата обновления, количество доменов и url-источника) <br />
<code>Invoke-Pi-Hole -Status -Server $Server -Token $Token</code> статус работы режима блокировки <br />
<code>Invoke-Pi-Hole -Enable -Server $Server -Token $Token</code> включить блокировку <br />
<code>Invoke-Pi-Hole -Disable -Server $Server -Token $Token</code> отключить блокировку <br />
<code>Invoke-Pi-Hole -Stats -Server $Server -Token $Token</code> подключиться к серверу Pi-Hole для получения статистики (метрики: количество доменов для блокировки, количество запросов и блокировок за сегодня и т.д.) <br />
<code>Invoke-Pi-Hole -QueryTypes -Server $Server -Token $Token</code> статистика запросов по типу записей относительно 100% <br />
<code>Invoke-Pi-Hole -TopClient -Server $Server -Token $Token</code> список самых активных клиентов (ip/name и количество запросов проходящих через сервер) <br />
<code>Invoke-Pi-Hole -TopPermittedDomains -Count 100 -Server $Server -Token $Token</code> список самых посещяемых доменов и количество запросов <br />
<code>Invoke-Pi-Hole -LastBlockedDomain -Server $Server -Token $Token</code> адрес последнего заблокированного домена <br />
<code>Invoke-Pi-Hole -ForwardServer -Server $Server -Token $Token</code> список серверов для пересылки, которым обычно выступает DNS-сервер стоящий за Pi-Hole в локальной сети, например AD <br />
<code>Invoke-Pi-Hole -Data -Server $Server -Token $Token</code> количество запросов за каждые 10 минут в течение последних 24 часов</p>
<h3 id="check-host"><a class="header" href="#check-host">Check-Host</a></h3>
<pre><code class="language-PowerShell">$path = $(($env:PSModulePath -split ";")[0]) + "\Get-CheckHost"
if (Test-Path $path) {
    Remove-Item $path -Force -Recurse
    New-Item -ItemType Directory -Path $path
} else {
    New-Item -ItemType Directory -Path $path
}
Invoke-RestMethod "https://raw.githubusercontent.com/Lifailon/Check-Host/rsa/Get-CheckHost/Get-CheckHost.psm1" -OutFile "$path\Get-CheckHost.psm1"
</code></pre>
<p><code>Install-Module CheckHost</code> установить модуль работы с Check-Host (https://check-host.net) через api <br />
<code>Get-CheckHost -List</code> список хостов (node) разных регионов (40) <br />
<code>Get-CheckHost -Server google.com -Type ping -Count 5</code> использовать 5 любых хостов для 4 пингов с каждого до указанного url (google) <br />
<code>Get-CheckHost -Server google.com -Type dns -Count 5</code> проверить DNS (возвращает А-запись или диапазон с ip-адресом) <br />
<code>Get-CheckHost -Server google.com:443 -Type http -Count 5</code> проверить доступность порта <br />
<code>Get-CheckHost -Server google.com:443 -Type tcp -Count 5</code> проверить доступность TCP или UDP порта</p>
<h3 id="psdomaintest"><a class="header" href="#psdomaintest">PSDomainTest</a></h3>
<p><code>Install-Module PSDomainTest -Repository NuGet -Scope CurrentUser</code> <br />
<code>Get-DomainTest -Domain github.com -Warning</code> протестировать домен и DNS записи на ошибки (вывести только ошибки) через ZoneMaster (https://github.com/zonemaster/zonemaster) <br />
<code>Get-DomainTest -Domain github.com -Warning -json</code> вывод в формате json <br />
<code>Get-DomainTest -Domain github.com -html | Out-File .\result.html</code> получить отчет в формате HTML-таблицы с фильтрацией по столбцам</p>
<h3 id="winapi"><a class="header" href="#winapi">WinAPI</a></h3>
<p><code>Install-Module ps.win.api -Repository NuGet -AllowClobber</code> <br />
<code>Import-Module ps.win.api</code> <br />
<code>Get-Command -Module ps.win.api</code> <br />
<code>Start-WinAPI</code> запустить сервер <br />
<code>Test-WinAPI</code> статус сервера <br />
<code>Stop-WinAPI</code> остановить сервер <br />
<code>Read-WinAPI</code> отобразить лог в реальном времени <br />
<code>Get-Hardware</code> вывести сводную информацию о системе с использованием потоков (фоновых заданий) <br />
<code>Get-DiskPhysical</code> отобразить список физических дисков, их размер, интерфейс и статус <br />
<code>Get-DiskPhysical -ComputerName 192.168.3.100 -Port 8443 -User rest -Pass api</code> получить информацию с удаленного сервер, на котором запущен сервер WinAPI (доступно для всех функций модуля) <br />
<code>Get-DiskLogical</code> список логических дисков (включая виртуальные диски), их файловая система, общий и используемый размер в гб и процентах <br />
<code>Get-DiskPartition</code> список разделов физических дисков (отобразит скрытые разделы, загрузочный и порядок назначения байт) <br />
<code>Get-Smart</code> статус работы всех дисков и текущая температура <br />
<code>Get-IOps</code> количество операций ввода/вывода дисковой подсистемы <br />
<code>Get-Files</code> подробная информация о файлах (добавляет дату создания, изменения, доступа, количество дочерних файлов и директорий) <br />
<code>Find-Process</code> поиск пути к исполняемому файлу по имени остановленного (не запущенного) процесса в директориях <br />
<code>Get-ProcessPerformance</code> информация о процессах (Get-Process) в человеко-читаемом формате <br />
<code>Get-CPU</code> список все ядер и нагрузка на каждое ядро и на все сразу (суммарное процессорное время, привилегированное и пользовательское время процессора) <br />
<code>Get-MemorySize</code> размер оперативной, виртуальной памяти, суммарное потребление памяти процессов и путь к файлу подкачки <br />
<code>Get-MemorySlots</code> список всех слотов оперативной памяти <br />
<code>Get-NetInterfaceStat</code> статистика активного сетевого интерфейса за время с момента загрузки системы (количество пакетов и ГБ) <br />
<code>Get-NetInterfaceStat -Current</code> текущая статистика активного сетевого интерфейса (количество пакетов и МБ/c) <br />
<code>Get-NetIpConfig</code> конфигурация всех сетевых интерфейсов (ip и mac-адрес, статус DHCP сервера, дата аренды) <br />
<code>Get-NetStat</code> развернутая статистика сетевых интерфейсов (из Get-NetTCPConnection), добавляет имя процесса, имя удаленного хоста (через nslookup), время работы процесса (не процессорное время) и путь к исполняемому файлу <br />
<code>Get-Performance</code> информация из счетчиков (Get-Counter) человеко-читаемом формате <br />
<code>Get-VideoCard</code> информация о всех видео-картах (наименование, частота и объем видео-памяти) <br />
<code>Get-Software</code> список установленного програмного обеспечения <br />
<code>Get-WinUpdate</code> список обновлений Windows (дата установки и источник) <br />
<code>Get-Driver</code> список установленных драйверов (имя, провайдер, версия и дата установки)</p>
<h3 id="psyslog"><a class="header" href="#psyslog">pSyslog</a></h3>
<p><code>Install-Module pSyslog -Repository NuGet</code> <br />
<code>Start-pSyslog -Port 514</code> запустить сервер на порту 514 (по умолчанию) <br />
<code>Start-pSyslog -RotationSize 500</code> указать размер файла локального журнала для его ротации (обрезания) в КБ <br />
<code>Get-pSyslog -Status | Format-List</code> отобразить статус работы <br />
<code>Get-pSyslog</code> вывести журнал сообщений в реальном времени <br />
<code>Stop-pSyslog</code> остановить сервер <br />
<code>Send-pSyslog -Content "Test" -Server 192.168.3.99</code> отправить сообщение на Syslog-сервер <br />
<code>Send-pSyslog -Content "Test" -Server 192.168.3.99 -Type Informational -PortServer 514 -PortClient 55514</code> <br />
<code>(Get-Service -Name WinRM).Status | Send-pSyslog -Server 192.168.3.102 -Tag Service[WinRM]</code> <br />
<code>Send-pSyslog -Content "test" -Server 192.168.3.99 -PortServer 514 -Base64</code> использовать шифрование при отправки сообщения (расшифровка работает только для сервера pSyslog) <br />
<code>Start-UDPRelay -inPort 515 -outIP 192.168.3.102 -outPort 514</code> запустить сервер в режиме UDP-Relay, который слушает на порту 515 и переадресует сообщения на Syslog сервер 192.168.3.102 с портом 514 <br />
<code>Send-pSyslog -Server 192.168.3.99 -PortServer 515 -Content $(Get-Date)</code> отправить сообщение на сервере UDP-Relay <br />
<code>Show-pSyslog -Type Warning -Count</code> отобразить метрики (количество ошибок) <br />
<code>Show-pSyslog -Type Alert -Count</code> <br />
<code>Show-pSyslog -Type Critical -Count</code> <br />
<code>Show-pSyslog -Type Error -Count</code> <br />
<code>Show-pSyslog -Type Emergency -Count</code> <br />
<code>Show-pSyslog -Type Informational -Count</code> <br />
<code>Show-pSyslog -LogFile 05-06 | Out-GridView</code> прочитать локальный журнал логирования и вывести в GridView для фильтрации сообщений <br />
<code>Show-pSyslog -Count</code> отобразить количество сообщений локального журнала <br />
<code>Show-pSyslog -Count -LogFile 10-06</code> выбрать журнал по дате</p>
<h3 id="syslog-source-message"><a class="header" href="#syslog-source-message">Syslog source message</a></h3>
<pre><code class="language-PowerShell">Add-Type -TypeDefinition @"
public enum Syslog_Facility {
    kern,     // 0  kernel (core) messages
    user,     // 1  user level messages
    mail,     // 2  mail system
    daemon,   // 3  system daemons
    auth,     // 4  security/authorization messages (login/su)
    syslog,   // 5  syslog daemon
    lpr,      // 6  line printer subsystem (creating jobs and send to spool for print by using lpd)
    news,     // 7  network news subsystem (USENET)
    uucp,     // 8  Unix-to-Unix Copy subsystem
    cron,     // 9  scheduling daemon
    authpriv, // 10 security/authorization private messages
    ftp,      // 11 FTP daemon
    ntp,      // 12 NTP daemon
    security, // 13 security log audit
    console,  // 14 console log alert
    clock,    // 15 clock subsystem
    local0,   // 16 local use
    local1,   // 17
    local2,   // 18
    local3,   // 19
    local4,   // 20
    local5,   // 21
    local6,   // 22
    local7    // 23
}
"@
</code></pre>
<h3 id="syslog-type-message"><a class="header" href="#syslog-type-message">Syslog type message</a></h3>
<pre><code class="language-PowerShell">Add-Type -TypeDefinition @"
public enum Syslog_Severity {
    Emergency,     // 0 emerg
    Alert,         // 1 alert
    Critical,      // 2 crit
    Error,         // 3 err
    Warning,       // 4 warning
    Notice,        // 5 notice
    Informational, // 6 info
    Debug          // 7 debug
}
"@
</code></pre>
<h1 id="pester"><a class="header" href="#pester">Pester</a></h1>
<p><a href="https://github.com/pester/Pester">Source</a></p>
<p><code>Install-Module -Name Pester -Repository PSGallery -Force -AllowClobber</code> <br />
<code>Import-Module Pester</code> <br />
<code>$(Get-Module Pester -ListAvailable).Version</code></p>
<p><code>.Tests.ps1</code></p>
<pre><code class="language-PowerShell">function Add-Numbers {
    param (
        [int]$a,
        [int]$b
    )
    $a + $b
}
Describe "Add-Numbers" {
    Context "При сложении двух чисел" {
        It "Должна вернуться правильная сумма" {
            $result = Add-Numbers -a 3 -b 4
            $result | Should -Be 7
        }
    }
    Context "При сложении двух чисел" {
        It "Должна вернуться ошибка (5+0 -ne 4)" {
            $result = Add-Numbers -a 5 -b 0
            $result | Should -Be 4
        }
    }
}

function Get-RunningProcess {
    return Get-Process | Select-Object -ExpandProperty Name
}
Describe "Get-RunningProcess" {
    Context "При наличии запущенных процессов" {
        It "Должен возвращать список имен процессов" {
            $result = Get-RunningProcess
            $result | Should -Contain "svchost"
            $result | Should -Contain "explorer"
        }
    }
    Context "Когда нет запущенных процессов" {
        It "Должен возвращать пустой список" {
            # Замокать функцию Get-Process, чтобы она всегда возвращала пустой список процессов
            Mock Get-Process { return @() }
            $result = Get-RunningProcess
            $result | Should -BeEmpty
        }
    }
}
</code></pre>
<h1 id="oh-my-posh"><a class="header" href="#oh-my-posh">oh-my-posh</a></h1>
<p><a href="https://ohmyposh.dev/docs/installation/windows">Install</a></p>
<p><code>winget install JanDeDobbeleer.OhMyPosh -s winget</code> <br />
<code>choco install oh-my-posh -y</code> <br />
<code>scoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json</code> <br />
<code>Set-ExecutionPolicy Bypass -Scope Process -Force; Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://ohmyposh.dev/install.ps1'))</code></p>
<p><a href="https://ohmyposh.dev/docs/themes">Themes</a></p>
<p><code>Get-PoshThemes</code> отобразить список всех тем <br />
<code>oh-my-posh init pwsh --config "$env:POSH_THEMES_PATH/di4am0nd.omp.json" | Invoke-Expression</code> применить (использовать) тему в текущей сессии <br />
<code>oh-my-posh init pwsh --config "https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh/main/themes/cert.omp.json" | Invoke-Expression</code> считать тему из репозитория <br />
<code>New-Item -Path $PROFILE -Type File -Force</code> создайт файл профилья PowerShell <br />
<code>'oh-my-posh init pwsh --config "$env:POSH_THEMES_PATH/di4am0nd.omp.json" | Invoke-Expression' &gt; $PROFILE</code> сохранить тему профиля (загружать тему при запуске PowerShell)</p>
<h3 id="themes-performance"><a class="header" href="#themes-performance">themes-performance</a></h3>
<p><code>Install-Module themes-performance -Repository NuGet</code> установить модуль с темами <br />
<code>Set-PoshTheme -Theme System-Sensors</code> использовать тему с датчиками из LibreHardwareMonitor <br />
<code>Set-PoshTheme -Theme System-Sensors -Save</code> загрузить тему из репозитория на локальный компьютер и сохранить тему в профиле <br />
<code>Set-PoshTheme -Theme System-Performance</code> использовать тему с датчиками системы, получаемыми из системы WMI/CIM (заряд батареи ноутбука | загрузка CPU в % | использование оперативной памяти | скорость активного сетевого интерфейса) <br />
<code>Set-PoshTheme -Theme System-Performance -Save</code> <br />
<code>Set-PoshTheme -Theme Pwsh-Process-Performance</code> время работы текущего процесса pwsh (процессорное время), количество работающих/общее (статус успех/ошибка) фоновых заданий, Working Set текущего процесса и всех процессов PowerShell в системе <br />
<code>Set-PoshTheme -Theme Pwsh-Process-Performance -Save</code></p>
<h1 id="windows-terminal"><a class="header" href="#windows-terminal">Windows-Terminal</a></h1>
<h3 id="terminal-icons"><a class="header" href="#terminal-icons">Terminal-Icons</a></h3>
<p><code>Install-Module -Name Terminal-Icons -Repository PSGallery</code> <br />
<code>scoop bucket add extras</code> <br />
<code>scoop install terminal-icons</code></p>
<p><code>notepad $PROFILE</code> <br />
<code>Import-Module -Name Terminal-Icons</code></p>
<p>Использует шрифты, которые необходимо установить и настроить в параметрах профиля PowerShell: <a href="https://github.com/ryanoasis/nerd-fonts">Nerd Fonts</a> <br />
<a href="https://www.nerdfonts.com/font-downloads">Список шрифтов</a> <br />
Скачать и установить шрифт похожий на Cascadia Code - <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v3.1.1/CascadiaCode.zip">CaskaydiaCove</a></p>
<p>Установить шрифт в конфигурацию Windows Terminal для PowerShell Core:</p>
<pre><code class="language-json">"profiles": 
{
    "defaults": 
    {
        "colorScheme": "One Half Dark",
        "experimental.retroTerminalEffect": true,
        "font": 
        {
            "size": 10.0
        },
        "useAtlasEngine": true
    },
    "list": 
    [
        // PowerShell Core
        {
            "font": 
            {
                "face": "CaskaydiaMono Nerd Font" // устанавливаем шрифт для работы Terminal-Icons
            },
            "guid": "{574e775e-4f2a-5b96-ac1e-a2962a402336}",
            "hidden": false,
            "name": "PowerShell Core",
            "source": "Windows.Terminal.PowershellCore"
        },
        // WSL (Ubuntu)
        {
            "guid": "{2c4de342-38b7-51cf-b940-2309a097f518}",
            "hidden": false,
            "name": "WSL",
            "source": "Windows.Terminal.Wsl"
        },
        // ssh
        {
            "commandline": "ssh lifailon@192.168.1.100 -p 22",
            "guid": "{a3ec86f6-2bc1-59dd-814d-2a0d935af5f8}",
            "icon": "🐧",
            "name": "devops-01"
        }
    ]
}
</code></pre>
<h3 id="custom-actions"><a class="header" href="#custom-actions">Custom Actions</a></h3>
<p>Custom actions: https://learn.microsoft.com/ru-ru/windows/terminal/customize-settings/actions <br />
Escape-последовательности: https://learn.microsoft.com/ru-ru/cpp/c-language/escape-sequences?view=msvc-170</p>
<pre><code class="language-json">"actions": 
[
    {
        "command": 
        {
            "action": "copy",
            "singleLine": false
        },
        "keys": "ctrl+c"
    },
    {
        "command": "paste",
        // Сохраняем классическую вставку интерпритатора, не заставляя выполнять код построчно
        "keys": "ctrl+shift+v" // default: ctrl+v
    },
    {
        "command": "find",
        "keys": "ctrl+f" // default: ctrl+shift+f
    },
    {
        "command": 
        {
            "action": "splitPane",
            "split": "left", // default: auto
            "splitMode": "duplicate"
        },
        "keys": "ctrl+shift+d" // default: alt+shift+d
    },
    // Очистить строку
    {
        "command": {
            "action": "sendInput",
            "input": "\u0001\u001b[3~"
        },
        "keys": "ctrl+k"
    },
    // Очистить терминал
    {
        "command": {
            "action": "sendInput",
            "input": "\u0001\u001b[3~clear\r"
        },
        "keys": "ctrl+l"
    },
    // Вставить шаблон модуля для перевода текста через Google Translate
    {
        "command": {
            "action": "sendInput",
            "input": "\u0001\u001b[3~Get-Translate -Alternatives -Provider Google ''\u001b[D"
        },
        "keys": "ctrl+g"
    },
    // Вставить шаблон модуля для перевода текста через MyMemory
    {
        "command": {
            "action": "sendInput",
            "input": "\u0001\u001b[3~Get-Translate -Alternatives -Provider MyMemory ''\u001b[D"
        },
        "keys": "ctrl+q"
    },
    // Быстрый перевод текста из буфера обмена
    {
        "command": {
            "action": "sendInput",
            "input": "\u0001\u001b[3~Get-Translate -Alternatives -Provider MyMemory -Text $(Get-Clipboard)\u001b[D\r"
        },
        "keys": "ctrl+shift+q"
    },
    // Быстрый пинг dns google
    {
        "command": {
            "action": "sendInput",
            "input": "\u0001\u001b[3~ping 8.8.8.8 -t\r"
        },
        "keys": "ctrl+p"
    }
]
</code></pre>
<h1 id="pandoc"><a class="header" href="#pandoc">Pandoc</a></h1>
<pre><code class="language-PowerShell">$release_latest = Invoke-RestMethod "https://api.github.com/repos/jgm/pandoc/releases/latest"
$url = $($release_latest.assets | Where-Object name -match "windows-x86_64.zip").browser_download_url
Invoke-RestMethod $url -OutFile $home\Downloads\pandoc.zip
Expand-Archive -Path "$home\Downloads\pandoc.zip" -DestinationPath "$home\Downloads\"
$path = $(Get-ChildItem "$home\Downloads\pandoc-*\*.exe").FullName
Copy-Item -Path $path -Destination "C:\Windows\System32\pandoc.exe"
Remove-Item "$home\Downloads\pandoc*" -Force -Recurse
</code></pre>
<p><code>pandoc -s README.md -o index.html</code> конвертация из Markdown в HTML <br />
<code>pandoc README.md -o index.html --css=styles.css</code> применить стили из css <br />
<code>pandoc -s index.html -o README.md</code> конвертация из HTML в Markdown <br />
<code>pandoc -s README.md -o README.docx</code> конвертация в Word <br />
<code>pandoc -s README.md -o README.epub</code> конвертация в открытый формат электронных версий книг <br />
<code>pandoc -s README.md -o README.pdf</code> конвертация в PDF (требуется rsvg-convert) <br />
<code>pandoc input.md -f markdown+hard_line_breaks -o output.md</code> конвертация из markdown документа, который не содержит обратный слэш в конце каждой строки для переноса (), который их добавит</p>
<h3 id="convert-excel-to-markdown"><a class="header" href="#convert-excel-to-markdown">Convert Excel to Markdown</a></h3>
<pre><code class="language-PowerShell">Import-Module ImportExcel
Import-Excel -Path srv.xlsx | Export-Csv -Path $csvFilePath -NoTypeInformation -Encoding UTF8 # конвертация Excel в csv
pandoc -s -f csv -t markdown input.csv -o output.md # конвертация таблицу csv в markdown
</code></pre>
<h1 id="ffmpeg"><a class="header" href="#ffmpeg">FFmpeg</a></h1>
<pre><code class="language-PowerShell">$release_latest = Invoke-RestMethod "https://api.github.com/repos/BtbN/FFmpeg-Builds/releases/latest"
$url = $($release_latest.assets | Where-Object name -match "ffmpeg-master-latest-win64-gpl.zip").browser_download_url
Invoke-RestMethod $url -OutFile $home\Downloads\ffmpeg-master-latest-win64-gpl.zip
Expand-Archive -Path "$home\Downloads\ffmpeg-master-latest-win64-gpl.zip" -DestinationPath "$home\Downloads\"
Copy-Item -Path "$home\Downloads\ffmpeg-master-latest-win64-gpl\bin\ffmpeg.exe" -Destination "C:\Windows\System32\ffmpeg.exe"
Remove-Item "$home\Downloads\ffmpeg-*" -Force -Recurse
</code></pre>
<p><code>ffmpeg -i input.mp4 output.gif</code> конвертировать mp4 в gif <br />
<code>ffmpeg -i input.mp4 -filter_complex "scale=1440:-1:flags=lanczos" output.gif</code> изменить разрешение на выходе <br />
<code>ffmpeg -i input.mp4 -filter_complex "scale=1440:-1:flags=lanczos" -r 10 output.gif</code> изменить количество кадров в секунду на выходе <br />
<code>ffmpeg -i input.mp4 -filter_complex "fps=5,scale=960:-1:flags=lanczos,split[s0][s1];[s0]palettegen=max_colors=32[p];[s1][p]paletteuse=dither=bayer" output.gif</code> сжатие за счет цветовой политры <br />
<code>ffmpeg -i input.mp4 -ss 00:00:10 -frames:v 1 -q:v 1 output.jpg</code> вытащить скриншот из видео на 10 секунде <br />
<code>ffmpeg -i input.mp4 -ss 00:00:05 -to 00:00:10 -c copy output.mp4</code> вытащить кусок видео <br />
<code>ffmpeg -i "%d.jpeg" -framerate 2 -c:v libx264 -r 30 -pix_fmt yuv420p output.mp4</code> создать видео из фото (1.jpeg, 2.jpeg и т.д.) с framerate (частотой кадров) в создаваемом видео 2 кадра в секунду <br />
<code>ffmpeg -i "rtsp://admin:password@192.168.3.201:554" -rtsp_transport tcp -c:v copy -c:a aac -strict experimental output.mp4</code> запись без перекодирования (copy) RTSP-потока с камеры видеонаблюдения (+ аудио в кодеке AAC) в файл <br />
<code>ffmpeg -i "rtsp://admin:password@192.168.3.201:554" -rtsp_transport tcp -c:v copy -c:a aac -strict experimental -movflags +faststart+frag_keyframe+empty_moov output.mp4</code> переместить метаданные в начало файла, что позволяет начать воспроизведение файла в видеоплеере до его полной загрузки <br />
<code>ffmpeg -i "rtsp://admin:password@192.168.3.201:554" -rtsp_transport tcp -frames:v 1 -c:v mjpeg output.jpg</code> сделать скриншот <br />
<code>ffmpeg -i input.mp4 -vf "pad=width=iw:height=ih+100:x=0:y=100:color=black" -c:a copy output.mp4</code> width=iw: (ширина видео остается как у исходного файла), height=ih+100 (высота видео увеличивается на 100 пикселей), x=0 (горизонтальное смещение установлено в 0), y=100 (вертикальное смещение установлено в 100 пикселей вниз, чтобы добавить черное пространство сверху), color=black (цвет добавленного пространства — черный)</p>
<h1 id="handbrake"><a class="header" href="#handbrake">HandBrake</a></h1>
<pre><code class="language-PowerShell">$url = "https://github.com/HandBrake/HandBrake/releases/download/1.8.0/HandBrakeCLI-1.8.0-win-x86_64.zip"
Invoke-RestMethod $url -OutFile $home\Downloads\HandBrakeCLI.zip
Expand-Archive -Path $home\Downloads\HandBrakeCLI.zip -OutputPath "$home\Downloads\"
Copy-Item -Path "$home\Downloads\HandBrakeCLI.exe" -Destination "C:\Windows\System32\HandBrakeCLI.exe"
Remove-Item "$home\Downloads\doc" -Force -Recurse
Remove-Item "$home\Downloads\HandBrakeCLI*"
</code></pre>
<p><code>HandBrakeCLI -i input.mp4 -o output.mkv</code> конвертирует видео в формате mp4 в формат mkv с использованием стандартных настроек HandBrake <br />
<code>HandBrakeCLI -i input.mp4 -o output.mkv -q 20</code> установить качество видео 20, значения варьируются от 0 (максимальное качество) до 51 (минимальное качество), где 20 считается хорошим качеством для большинства видео <br />
<code>HandBrakeCLI -i input.mp4 -o output.mkv -r 30</code> установить частоту кадров на 30 fps <br />
<code>HandBrakeCLI -i input.mp4 -o output.mkv --maxWidth 1280 --maxHeight 720</code> изменить размер на 1280х720 <br />
<code>HandBrakeCLI -i input.mp4 -o output.mkv -b 1500</code> установить битрейт видео 1500 кбит/с <br />
<code>HandBrakeCLI -i input.mp4 -o output.mkv -e x264</code> преобразовать видео с использованием кодека x264 <br />
<code>HandBrakeCLI -i input.mp4 -o output.mp4 --crop 0:200:0:0</code> обрезать видео снизу на 200px (верх:низ:лево:право) <br />
<code>HandBrakeCLI -i input.mp4 -o output.mp4 --start-at duration:5 --stop-at duration:15</code> обрезать видео (на выходе будет 15-секундное видео с 5 по 20 секунду)</p>
<h1 id="imagemagick"><a class="header" href="#imagemagick">ImageMagick</a></h1>
<p>Source: <a href="https://sourceforge.net/projects/imagemagick">ImageMagick</a></p>
<p><code>magick identify -verbose PowerShell-Commands.png</code> извлечь метаданные изображения <br />
<code>magick PowerShell-Commands.png output.jpg</code> конвертация формата изображения <br />
<code>magick PowerShell-Commands.png -resize 800x600 output.jpg</code> изменить размер (увеличить или уменьшить) <br />
<code>magick PowerShell-Commands.png -crop 400x300+100+50 output.jpg</code> обрезать <br />
<code>magick PowerShell-Commands.png -rotate 90 output.jpg</code> повернуть изображение <br />
<code>magick PowerShell-Commands.png -fill white -pointsize 24 -gravity center -annotate +0+0 "PowerShell" output.jpg</code> наложить текст на изображение <br />
<code>magick PowerShell-Commands.png -brightness-contrast +20x+10 output.jpg</code> изменить яркость и контрастность <br />
<code>magick convert -delay 100 1.png 2.png 3.png output.gif</code> создать gif из изображений <br />
<code>magick convert image1.jpg image2.jpg -append output.jpg</code> вертикально объединенить изображения</p>
<h1 id="youtube"><a class="header" href="#youtube">YouTube</a></h1>
<pre><code class="language-PowerShell">$release_latest = Invoke-RestMethod "https://api.github.com/repos/yt-dlp/yt-dlp/releases/latest"
$url = $($release_latest.assets | Where-Object name -match "yt-dlp.exe").browser_download_url
Invoke-RestMethod $url -OutFile "C:\Windows\System32\yt-dlp.exe"
</code></pre>
<p><code>yt-dlp -F https://www.youtube.com/watch?v=gxplizjhqiw</code> отобразить список всех доступных форматов <br />
<code>yt-dlp -J https://www.youtube.com/watch?v=gxplizjhqiw</code> вывести данные в формате JSON <br />
<code>yt-dlp -J https://www.youtube.com/watch?v=gxplizjhqiw | jq -r .formats.[].format</code> id - resolution (format_note) <br />
<code>yt-dlp -f 137 https://www.youtube.com/watch?v=gxplizjhqiw</code> загрузить только видео в указанном формате по id <br />
<code>yt-dlp -f bestaudio https://www.youtube.com/watch?v=gxplizjhqiw</code> загрузить только аудио <br />
<code>yt-dlp -f best https://www.youtube.com/watch?v=gxplizjhqiw</code> загрузить видео с аудио в лучшем качестве <br />
<code>yt-dlp -f 'bestvideo[height&lt;=1080]+bestaudio/best[height&lt;=1080]' https://www.youtube.com/watch?v=gxplizjhqiw</code> загрузить в указанном качестве <br />
<code>yt-dlp -r 2m https://www.youtube.com/watch?v=gxplizjhqiw</code> ограничить скорость загрузки до 2 МБит/с</p>
<pre><code class="language-PowerShell">function Get-YouTube {
    param (
        $url
    )
    $result = yt-dlp -J $url
    $($result | ConvertFrom-Json).formats | 
    Where-Object filesize -ne $null | 
    Select-Object format_id,
    @{Name="FileSize"; 
        Expression={[string]([int]($_.filesize / 1024kb)).ToString("0.0")+" Mb"}
    },
    resolution,format_note,quality,fps,ext,language
}

$formats = Get-YouTube "https://www.youtube.com/watch?v=gxplizjhqiw"
$video = $($formats | Where-Object format_note -match 1080 | Where-Object ext -match mp4)[-1].format_id
$audio = $($formats | Where-Object resolution -match "audio" | Where-Object ext -match m4a)[-1].format_id
cd "$home\Downloads"
yt-dlp -f $video+$audio https://www.youtube.com/watch?v=gxplizjhqiw -o '%(title)s.%(ext)s'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>+++
title = "Linux"
[extra]
toc = true
toc_sidebar = true
go_to_top = true
+++</p>
<p align="center">
    <a href="https://github.com/Lifailon/PS-Commands/blob/rsa/linux.md"><img title="Linux Commands Logo"src="Linux/Linux-Commands-Logo.png"></a>
</p>
<p align="center">
    Заметки по работе с системными командами и консольными утилитами 🐧 <b>Linux</b>.
</p>
<hr />
<h2 id="bash"><a class="header" href="#bash">bash</a></h2>
<ul>
<li>Переменные</li>
</ul>
<p><code>text="(ip a)"</code> передает текст <br />
<code>echo $text</code> <br />
<code>ipaddr=$(ip a)</code> передает вывод команды <br />
<code>echo $ipaddr</code> <br />
<code>echo '$ipaddr'</code> в одинарных кавычках не происходит подстановка переменных <br />
<code>var=$((5+5))</code> <br />
<code>echo $var</code> <br />
<code>read -p "Enter: " enter</code> ручной ввод переменной
<code>echo $enter</code> <br />
<code>read -s -p "Enter password: " pass</code> ввод пароля <br />
<code>echo $pass</code> <br />
<code>echo -e "text\ntext"</code> экранирование <br />
<code>echo -e "# comment\nparam comment" &gt; ~/test.txt</code> записать в файл <br />
<code>cat ~/test.txt | grep -v "^#"</code> прочитать без комментариев в начале строки</p>
<p><code>original_value="Это длинная строка, которую нужно сократить до 50 символов."</code> <br />
<code>shortened_value="${original_value:0:50}"</code> обрезаем до 50 символов</p>
<p><code>true ; echo $?</code> код возврата 0 (успех) <br />
<code>false ; echo $?</code> код возврата 1 (ошибка)</p>
<ul>
<li>Массивы</li>
</ul>
<p><code>range={1..254}</code> создать срез от 1 до 254 <br />
<code>array=(1 2 3 4 5)</code> создать массив <br />
<code>array=($(ls /))</code> передает вывод команды <code>$(command)</code> разделенных через пробел <br />
<code>echo ${array[@]}</code> отобразить содержимое всего массива <code>@/*</code> <br />
<code>echo ${array[0]}</code> отобразить первый индекс в массиве <br />
<code>echo ${array[-1]}</code> отобразить последний индекс <br />
<code>echo ${array[@]:1:3}</code> вывести 3 элемента (срез) <br />
<code>echo ${#array[@]}</code> отобразить кол-во (<code>#</code>) элементов в массиве <br />
<code>echo ${#array[0]}</code> отобразить длинну (<code>#</code>) первого элемента в массиве <br />
<code>array[1]="22"</code> изменить значение по номеру индекса</p>
<pre><code class="language-bash">declare -A dict=(
    ["key 1"]=1
    ["key 2"]="text"
)
echo ${dict[key 1]}
echo ${dict[key 2]}
</code></pre>
<ul>
<li>Цикл for</li>
</ul>
<pre><code class="language-bash">for ((i=1; i &lt;= 10; i++)); do
    echo $i
done

array=($(ls /))
for arr in ${array[@]}; do
    echo $arr
done
</code></pre>
<p><code>break</code> прерывает цикл <br />
<code>continue</code> прерывает текущую интерацию в цикле и переходит к следующей</p>
<pre><code class="language-bash">array=(1 2 3 4 5)
for var in ${array[@]}; do
    if [ $var -gt 4 ]; then
        break
    elif [ $var -gt 3 ]; then
        echo "Last number: $var"
        continue
    fi
    echo "Number: $var"
done
</code></pre>
<ul>
<li>Цикл while</li>
</ul>
<pre><code class="language-bash">p=1
while [ $p -le 101 ]; do
    # если условие истинно, выполнять цикл в блоке do, пока не станет ложным
    echo "Значение переменной: $p"
    # ((p++)) # увеличить на +1
    # p=$(($p+10)) # прибавлять +10
    p+=0 # добавить текст в конец переменной
done
</code></pre>
<ul>
<li>Построчная передача вывода через pipe</li>
</ul>
<pre><code class="language-bash">num=0
ps | sed 1d | while read line; do
    ((num++)) # ((num+=1))
    echo "Line $num : $line"
done
</code></pre>
<ul>
<li>Условия</li>
</ul>
<p><code>if []</code>   если <br />
<code>then</code>    условие истинно <br />
<code>elif []</code> дополнительное условие <br />
<code>then</code>    дополнительное условие истинно <br />
<code>else</code>    условие ложно <br />
<code>fi</code>      больше нет условий</p>
<p><code>-z</code>          строка пуста <br />
<code>-n</code>          строка не пуста <br />
<code>=, (==)</code>     строки равны <br />
<code>!=</code>          строки неравны <br />
<code>-eq</code>         равно <br />
<code>-ne</code>         неравно <br />
<code>-lt, (&lt;)</code>    меньше <br />
<code>-le, (&lt;=)</code>   меньше или равно <br />
<code>-gt, (&gt;)</code>    больше <br />
<code>-ge, (&gt;=)</code>   больше или равно <br />
<code>!</code>           отрицание логического выражения <br />
<code>-a, (&amp;&amp;)</code>    логическое «и» (первая команда исполняется всегда, вторая — только в случае успешного завершения первой) <br />
<code>-o, (||)</code>    логическое «или» (первая команда исполняется всегда, вторая — только в случае неудачного завершения первой)</p>
<pre><code class="language-bash">if [[ -z "$variable" ]]; then
    echo "Переменная пустая"
else
    echo "Переменная не пустая"
fi
</code></pre>
<ul>
<li>Функции</li>
</ul>
<pre><code class="language-bash">function calc {
    if [ $2 = "+" ]
        then
        echo $(( $1 + $3 ))
    elif [ $2 = "-" ]
        then
        echo $(( $1 - $3 ))
    fi
}
</code></pre>
<p><code>calc 3 + 2</code> <br />
<code>calc 3 - 2</code></p>
<ul>
<li>Параметры</li>
</ul>
<p><code>nano script.sh</code></p>
<pre><code class="language-bash">#!/bin/bash
if [ -n "$1" -a "$2" ]; then
    echo Имя исполняемого файла: $0
    echo Первый переданный параметр: $1
    echo Второй переданный параметр $2
    echo Кол-во переданных параметров: $#
    echo Значение последнего переданного параметра: ${!#}
    echo Массив: $@
else
    echo "Параметры не заданы"
fi
</code></pre>
<p><code>chmod +x script.sh</code> сделать скрипт исполняемым <br />
<code>bash script.sh 1 2 3 4 5</code> передать параметры в скрипт</p>
<p><code>-e file</code> проверяет, существует ли файл <br />
<code>-d file</code> проверяет, существует ли файл, и является ли он директорией <br />
<code>-f file</code> проверяет, существует ли файл, и является ли он файлом <br />
<code>-r file</code> проверяет, существует ли файл, и доступен ли он для чтения <br />
<code>-w file</code> проверяет, существует ли файл, и доступен ли он для записи <br />
<code>-x file</code> проверяет, существует ли файл, и является ли он исполняемым <br />
<code>-s file</code> проверяет, существует ли файл, и не является ли он пустым</p>
<pre><code class="language-bash"># Получить список директорий и исполняемых файлов в дочерних директориях
path="/etc/*"
for folder in $path; do
    echo "$folder:"
    for file in $folder/*; do
        if [ -x $file ]; then
            echo "- $file"
        fi
    done
done
</code></pre>
<ul>
<li>case</li>
</ul>
<pre><code class="language-bash">read -rsn1 key
case $key in
  "1")
    echo выполнить действия, если $key равно 1 ;;
  "2")
    echo выполнить действия, если $key равно 2 ;;
  *)
    echo выполнить действия по умолчанию, если значение $key не соответствует ни одному условию
  ;;
esac
</code></pre>
<h2 id="filesystem"><a class="header" href="#filesystem">filesystem</a></h2>
<p><code>file Console-Performance.sh</code> узнать тип файла (текстовый, исполняемый файл, архив или другой) <br />
<code>stat Console-Performance.sh</code> узнать размер файла, количество блоков, занятых файлом на диске, количество жестких ссылок, права доступа и временные метки  <br />
<code>pwd</code> текущая директория <br />
<code>ls -lh *</code> отобразить содержимое каждого подкаталога отдельно <br />
<code>ls -lhaF</code> отобразить скрытые директории (-a) с точкой и выделит директории (/) <br />
<code>which top</code> узнать путь до исполняемого файла <br />
<code>stat $(which top)</code> узнать дату последнего доступа к файлу  <br />
<code>cat -n /etc/passwd</code> просмотр содержимого файла с отображением номеров строк <br />
<code>mkdir</code> создать директорию <br />
<code>mktemp -d</code> создать временный файл/каталог (-d) <br />
<code>touch -t 202106222200.15 test.file</code> создать файл и указать дату создания <br />
<code>cp test.file test.file2</code> копировать файла/каталог <br />
<code>mv test.file2 test.file3</code> переименовать/переместить файл/каталог <br />
<code>rm -r test.file</code> удалить каталог с файлами (-r)</p>
<h3 id="ln"><a class="header" href="#ln">ln</a></h3>
<p><code>echo "test" &gt; testfile</code> <br />
<code>ln /test/testfile /test/testlink</code> создать жестку (hard) ссылку, которая указывает на один и тот же inode, т.е. они делят одно и то же физическое местоположение на диске <br />
<code>rm testfile</code> при удалении одного из файлов не приводит к удалению содержимого, пока существует хотя бы одна жесткая ссылка <br />
<code>ln -s /test/testfile /test/testlink</code> создать символическую (-s - soft) ссылку, которая ссылается на файл testfile <br />
<code>echo "test" &gt;&gt; testfile</code> при добавлении в оригинальный файл, все изменения будут отражены в testlink <br />
<code>rm testfile</code> при удалении исходного файла у ссылки будет ошибка (No such file or directory)</p>
<h3 id="zip"><a class="header" href="#zip">zip</a></h3>
<p><code>rar a test.rar filename filename2</code> создать архив test.rar и добавить туда два файла (файлы копируются в архив) <br />
<code>unrar x test.rar</code> разархивировать <br />
<code>zip -r test.zip filename</code> архивировать (файлы копируются в архив) <br />
<code>unzip test.zip</code> разархивировать <br />
<code>bzip2 filename</code> архивировать в filename.bz2 (файлы перепещаются в архив) <br />
<code>bunzip2 filename.bz2</code> разархивировать <br />
<code>gzip filename</code> архивировать в filename.gz (файлы перепещаются в архив) <br />
<code>tar --totals -cvf archive.tar file1 file2 file3</code> архивировать три файла <br />
<code>wget https://github.com/librespeed/speedtest-cli/releases/download/v1.0.10/librespeed-cli_1.0.10_linux_amd64.tar.gz</code> загрузить архив <br />
<code>gunzip librespeed-cli_1.0.10_linux_amd64.tar.gz</code> извлечь из gz в tar <br />
<code>tar -tf librespeed-cli_1.0.10_linux_amd64.tar</code> отобразить содержимое архива <br />
<code>tar -xvf librespeed-cli_1.0.10_linux_amd64.tar</code> разархивировать <br />
<code>./librespeed-cli --help</code> <br />
<code>./librespeed-cli --json</code></p>
<h3 id="gpg"><a class="header" href="#gpg">gpg</a></h3>
<p><code>gpg -c filename</code> зашифровать данные <br />
<code>gpg filename.gpg</code> расшифровать данные <br />
<code>gpg --gen-key</code> создавать пару ключей (публичный и приватный ключи) <br />
<code>gpg --export -a 'User Name' &gt; publickey.asc</code> экспорт публичного ключа <br />
<code>gpg --import publickey.asc</code> импорт на второй стороне <br />
<code>gpg --encrypt --recipient 'Recipient Name' filename</code> зашифровать данные с использованием публичного ключа получателя, только владелец приватного ключа сможет расшифровать эти данные <br />
<code>gpg --decrypt encryptedfile.gpg</code> расшифровать данные можно с помощью приватного ключа <br />
<code>gpg --sign filename</code> подписывать данные с использованием приватного ключа для подтверждения их подлинности и целостности <br />
<code>gpg --verify signedfile.gpg</code> проверка подписи с использованием публичного ключа отправителя</p>
<h2 id="api"><a class="header" href="#api">api</a></h2>
<h3 id="curl"><a class="header" href="#curl">curl</a></h3>
<p><code>curl ifconfig.me</code> узнать внешний ip <br />
<code>curl -v telnet://192.168.3.100:22</code> првоерить доступность порта и отобразить кому он принадлежит <br />
<code>curl -s -o /dev/null http://google.com</code> подавить весь вывод (статистику --silent и --output) <br />
<code>curl -s -o /dev/null --show-error --fail http://google.com</code> оставить вывод ошибок <br />
<code>curl http://192.168.3.101:8081/api/ --connect-timeout 5</code> задать timeout ожидания ответа в секундах <br />
<code>curl -IL https://github.com/Lifailon/hwstat/archive/refs/tags/hwstat-0.0.8.zip</code> получить информацию о файле перед скачиванием (--head/--location) <br />
<code>curl -O https://raw.githubusercontent.com/Lifailon/hwstat/rsa/hwstat.sh</code> скачать файл <br />
<code>curl -o /tmp/hwstat.sh https://raw.githubusercontent.com/Lifailon/hwstat/rsa/hwstat.sh</code> указать путь <br />
<code>curl -Ik https://192.168.3.104:9443/</code> игнорировать ошибку самоподписанного сертификата SSL (--insecure) <br />
<code>curl -u &lt;user:password&gt; https://test.com/endpoint</code> авторизация <br />
<code>curl -x "http://Proxy:Proxy@192.168.3.100:9090" "https://kinozal.tv/rss.xml"</code> использовать Proxy-сервер <br />
<code>curl --insecure --ssl-reqd "smtps://smtp.yandex.ru" --mail-from "src@yandex.ru" --mail-rcpt "dst@yandex.ru" --user "src@yandex.ru" --upload-file out.txt</code> отправка email через SMTPS (SMTP over SSL/TLS) сервер</p>
<h3 id="influxdb"><a class="header" href="#influxdb">influxdb</a></h3>
<pre><code class="language-bash">ip="192.168.3.104"
db="dbash"
table="icmp_metrics_table"
server="google.com"
host=$(hostname)
date=$(echo $EPOCHREALTIME | sed -E "s/\..+//")"000000000"
ping=$(ping $server -c 1)
loss=$(printf "%s\n" "${ping[@]}" | grep -Eo "[0-9]+%" | sed "s/%//")
if (( $(echo "$loss != 100" | bc) )); then
    status="true"
    rtt=$(printf "%s\n" "${ping[@]}" | grep rtt | awk -F"/" '{print $5}')
else
    status="false"
    rtt="0"
fi
curl -i -XPOST "http://$ip:8086/write?db=$db" --data-binary "$table,host=$host,server=$server status=$status,rtt=$rtt $date"
</code></pre>
<h3 id="wget"><a class="header" href="#wget">wget</a></h3>
<p><code>wget --spider https://download.nextcloud.com/server/releases/nextcloud-21.0.1.tar.bz2</code> проверить (--spider) работоспособность URL и узнать размер файла (Length) <br />
<code>wget -O nextcloud.tar.bz2 https://download.nextcloud.com/server/releases/nextcloud-21.0.1.tar.bz2</code> скачать с указанным именем (-O)  <br />
<code>wget -P /tmp https://download.nextcloud.com/server/releases/nextcloud-21.0.1.tar.bz2</code> скачать в указанную директорию (-P) <br />
<code>wget -b -o ~/wget.log https://download.nextcloud.com/server/releases/nextcloud-21.0.1.tar.bz2</code> загрузить в фоновом режиме (-b) и записать вывод в лог-файл (-o)</p>
<h3 id="curlie"><a class="header" href="#curlie">curlie</a></h3>
<p><code>curl -sS https://webinstall.dev/curlie | bash</code> альтернатива curl и httpie (https://github.com/rs/curlie) <br />
<code>curlie get https://jsonplaceholder.typicode.com/posts</code> возвращает заголовки ответа и отформатированный вывод JSON <br />
<code>curlie get https://jsonplaceholder.typicode.com/posts/1</code> <br />
<code>curlie get https://jsonplaceholder.typicode.com/posts -H "Authorization: Bearer YOUR_TOKEN"</code> <br />
<code>curlie post https://jsonplaceholder.typicode.com/posts -d '{"title": "foo", "body": "bar", "userId": 1}'</code></p>
<h3 id="httpie"><a class="header" href="#httpie">httpie</a></h3>
<p><code>sudo snap install httpie</code> HTTP-клиент командной строки (https://github.com/httpie/cli) <br />
<code>https httpie.io/hello</code> <br />
<code>https POST pie.dev/post X-API-Token:123 name=John</code></p>
<h2 id="json-1"><a class="header" href="#json-1">json</a></h2>
<h3 id="jq"><a class="header" href="#jq">jq</a></h3>
<p><code>apt install jq</code> установить jq (https://github.com/jqlang/jq) <br />
<code>nodes=$(curl -s -H "Accept: application/json" https://check-host.net/nodes/ips)</code> получить список node <br />
<code>echo $nodes | jq</code> обработка входных данных командой jq (вывод отображается в правильно структурированном формате, а все элементы подсвечиваются соответствующим цветом) <br />
<code>echo $nodes | jq '.nodes | length'</code> количество дочерних объектов в блоке node[] <br />
<code>echo $nodes | jq -r .nodes[1]</code> получить значение второго объекта массива в формате raw string (not JSON) <br />
<code>echo $nodes | jq -r .nodes[-1]</code> получить значение последнего объекта массива <br />
<code>hosts=$(curl -s -H "Accept: application/json" https://check-host.net/nodes/hosts)</code> получить список всех хостов <br />
<code>echo $hosts | jq -r '.nodes | to_entries[].key'</code> получить список всех вложенных ключей (адреса хостов) из объека (не является массивом) <br />
<code>echo $hosts | jq -r '.nodes | to_entries[].value'</code> получить только значения всех вложанных ключей <br />
<code>echo $hosts | jq '.nodes."bg1.node.check-host.net"'</code> получить значение дочернего ключа nodes по имени <br />
<code>echo $hosts | jq '.nodes | [.[]] | last'</code> преобразовать отдельные объекты внутри nodes в массив, и передать полученный вывод в функцию last для получения значений последнего объекта <br />
<code>echo $hosts | jq '.nodes | to_entries[].value.location[0] == "ru"'</code> проверить каждый элемент объекта в условии на true/false (вернет массив) <br />
<code>echo $hosts | jq '.nodes | to_entries[] | {Host: .key, Country: .value.location[1], City: .value.location[2]}'</code> получить данные key-value из объекта nodes и пересобрать массив с новыми значениями ключей <br />
<code>echo $hosts | jq -r '.nodes | to_entries[] | "\(.key) (\(.value.location[1]), \(.value.location[2]))"'</code> собрать массив строки из содержимого ключей <br />
<code>var="-" &amp;&amp; echo $hosts | jq --arg v "$var" -r '.nodes | to_entries[] | "\(.key) \($v) \(.value.location[1]) \($v) \(.value.location[2])"'</code> передать внешнюю переменную, которая будет использоваться внутри запроса <br />
<code>echo $hosts | jq -r '.nodes | to_entries[] | select(.value.location[0] == "ru") | .key'</code> произвести фильтрацию (select), что бы получить только нужные объекты <br />
<code>echo $hosts | jq '.nodes | to_entries[] | select(.value.location[0] != "ru") | .key'</code> вывести объекты, которые не равны значению <br />
<code>echo $hosts | jq '.nodes | length'</code> вывести общее количество объектов <br />
<code>echo $hosts | jq '.nodes | to_entries | map(select(.value.location[0] != "ru")) | length'</code> создать массив функцией map() (объеденяет отдельные объекты {}{} группируются в один массив [{},{}]) только из тех объектов, которые соответствуют условию select() и вывести количество найденных объектов <br />
<code>echo $hosts | jq -r '.nodes | to_entries[] | select(.value.location[0] == "ru" or .value.location[0] == "tr") | .key'</code> проверить два условия через or или and (для проверяемого типа данных int кавычки не используются) <br />
<code>echo $hosts | jq -r '.nodes | to_entries[] | select(.key | index("jp")) | .key'</code> вывести список хостов региона Japan, которые в названии ключа содержат ключевое слово jp (частичное совпадение в значении)</p>
<pre><code class="language-bash">host="yandex.ru"
protocol="ping"
host="yandex.ru:443"
protocol="tcp" # udp/http/dns
# Забрать id для получения результатов
check_id=$(curl -s -H "Accept: application/json" "https://check-host.net/check-$protocol?host=$host&amp;max_nodes=3" | jq -r .request_id)
# Функция получения результатов проверки по id
function check-result {
    curl -s -H "Accept: application/json" https://check-host.net/check-result/$1 | jq .
}
# Получить суммарное количество хостов, с которых производится проверка
hosts_length=$(check-result $check_id | jq length)
while true; do
    check_result=$(check-result $check_id)
    # Забираем результат и проверем, что содержимое всех проверок не равны null
    check_values_not_null=$(echo $check_result | jq -e 'to_entries | map(select(.value != null)) | length')
    if [[ $check_values_not_null == $hosts_length ]]; then
        echo $check_result | jq
        break
    fi
    sleep 1
done
</code></pre>
<p><code>echo '{"iso": [{"name": "Ubuntu", "size": 4253212899}, {"name": "Debian", "size": 3221225472}]}' | jq '.iso[] | {name: .name, size: (.size / 1024 / 1024 / 1024 | tonumber * 100 | floor / 100 | tostring + " GB")}'</code> получить ГБ из байт и округлить вывод до 2 символом после запятой <br />
<code>echo '{"iso": [{"name": "Ubuntu", "progress": 0.333}]}' | jq '.iso[] | {name: .name, progress: (.progress * 100 | floor / 100 * 100 | tostring + " %")}'</code> получить процент из дробной части (33%) <br />
<code>echo '[{"name": "Ubuntu", "added_on": 1625072400}, {"name": "Debian", "added_on": 1625158800}]' | jq '.[] | {name: .name, date: (.added_on + 3 * 3600 | strftime("%H:%M:%S %d.%m.%Y"))}'</code> получить дату</p>
<h3 id="netcheck"><a class="header" href="#netcheck">netcheck</a></h3>
<pre><code class="language-bash">sudo curl -s https://raw.githubusercontent.com/Lifailon/Check-Host/rsa/netcheck/netcheck.sh -o /usr/bin/netcheck
sudo chmod +x /usr/bin/netcheck
</code></pre>
<p><code>netcheck -t ping yandex.ru</code> <br />
<code>netcheck -n</code> <br />
<code>netcheck -t ping yandex.ru ru1.node.check-host.net</code> <br />
<code>netcheck -t dns yandex.ru</code> <br />
<code>netcheck -t http yandex.ru:443 5</code> <br />
<code>netcheck -t tcp yandex.ru:443</code></p>
<h3 id="jc"><a class="header" href="#jc">jc</a></h3>
<p><code>apt install jc</code> установить jc (https://github.com/kellyjonbrazil/jc) для преобразования вывода популярных инструментов командной строки, типов файлов и общих строк в JSON, YAML или словари Python, что позволяет передавать вывод в инструменты, такие как jq <br />
<code>dig google.com | jc --dig</code> <br />
<code>dig example.com | jc --dig | jq -r '.[].answer[].data'</code> <br />
<code>jc --pretty /proc/meminfo</code> <br />
<code>systemctl list-units --all --plain --no-legend --no-pager | jc --systemctl -p</code></p>
<h3 id="brew"><a class="header" href="#brew">brew</a></h3>
<p><code>/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</code> установить менеджер пакетов brew (https://github.com/Homebrew/brew) для macOS/Linux <br />
<code>echo 'eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"' &gt;&gt; ~/.profile</code> <br />
<code>eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"</code> <br />
<code>brew --version</code></p>
<h3 id="fx"><a class="header" href="#fx">fx</a></h3>
<p><code>brew install fx || snap install fx</code> установить fx (https://github.com/antonmedv/fx) TUI интерфейс для JSON на GoLang <br />
<code>hosts=$(curl -s -H "Accept: application/json" https://check-host.net/nodes/hosts)</code> <br />
<code>echo $hosts | fx</code> доступна навигация с раскрытием блоков и отображает ключи доступа для jq <br />
<code>source &lt;(fx --comp bash)</code> добавить autocomplete в интерпритатор bash <br />
<code>echo $hosts &gt; hosts.json</code> <br />
<code>fx hosts.json .nodes .\[\"ru1.node.check-host.net\"\] .ip</code> происходит автоматический вывод ключей и подстановка</p>
<h3 id="jid"><a class="header" href="#jid">jid</a></h3>
<p><code>brew install jid</code> установить jid (https://github.com/simeji/jid) для интерактивной фильтрации JSON данных с использованием автозавершения на GoLang <br />
<code>echo '{"info":{"date":"2016-10-23","version":1.0},"users":[{"name":"simeji","uri":"https://github.com/simeji","id":1},{"name":"simeji2","uri":"https://example.com/simeji","id":2},{"name":"simeji3","uri":"https://example.com/simeji3","id":3}],"userCount":3}}' | jid</code> .users[1].uri</p>
<h3 id="jqp"><a class="header" href="#jqp">jqp</a></h3>
<p><code>brew install noahgorstein/tap/jqp</code> установить jqp (https://github.com/noahgorstein/jqp) TUI интерфейс для отображения jq запросов на GoLang <br />
<code>curl -s https://api.github.com/repos/Lifailon/PS-Commands/contents | jqp</code> слева отображается исходный файл, справа отфильтрованный вывод <br />
<code>curl -s https://check-host.net/nodes/hosts | jqp</code> # пример для фильтрации: <code>.nodes | to_entries[] | select(.value.location[0] == "ru") | .key</code></p>
<h3 id="xmllint"><a class="header" href="#xmllint">xmllint</a></h3>
<p><code>apt-get install libxml2-utils || snap install libxml2 || brew install libxml2</code> <br />
<code>curl -s https://kinozal.tv/rss.xml -x kinozal:proxy@192.168.3.100:9090 | xmllint --xpath '//rss/channel/item/link/text()' -</code> <br />
<code>curl -s https://kinozal.tv/rss.xml -x kinozal:proxy@192.168.3.100:9090 | xmllint --xpath '//rss/channel/item[1]/link/text()' -</code></p>
<h3 id="dasel"><a class="header" href="#dasel">dasel</a></h3>
<p><code>brew install dasel</code> установить dasel (https://github.com/TomWright/dasel) для обработки JSON, YAML, TOML, XML и CSV (поддерживает преобразование между форматами) на GoLang <br />
<code>echo '{"name": "Tom"}' | dasel -r json 'name'</code> <br />
<code>echo '{"name": "Tom"}' | dasel -r json -w yaml</code> конвертировать json в yaml <br />
<code>echo '{"name": "Tom"}' | dasel -r json -w xml</code> конвертировать json в xml <br />
<code>echo '{"name": "Tom"}' | dasel put -r json -t string -v 'contact@tomwright.me' 'email'</code> добавить свойство <br />
<code>echo '{"email": "contact@tomwright.me","name": "Tom"}' | dasel delete -r json '.email'</code> удалить свойство</p>
<pre><code class="language-json">tee users.json &lt;&lt;EOF
{
    "users": [
      {
        "name": "Иван Иванов",
        "email": "ivan.ivanov@example.com"
      },
      {
        "name": "Мария Петрова",
        "email": "maria.petrova@example.com"
      }
    ]
}
EOF
</code></pre>
<p><code>dasel -f users.json -r json ".users.[0].email"</code></p>
<pre><code class="language-yaml">tee users.yaml &lt;&lt;EOF
users:
  - name: Иван Иванов
    email: ivan.ivanov@example.com
  - name: Мария Петрова
    email: maria.petrova@example.com
EOF
</code></pre>
<p><code>dasel -f users.yaml -r yaml ".users.[1].email"</code></p>
<pre><code class="language-toml">tee users.toml &lt;&lt;EOF
[[users]]
name = "Иван Иванов"
email = "ivan.ivanov@example.com"
[[users]]
name = "Мария Петрова"
email = "maria.petrova@example.com"
EOF
</code></pre>
<p><code>dasel -f users.toml -r toml ".users.[1].email"</code></p>
<pre><code class="language-xml">tee users.xml &lt;&lt;EOF
&lt;users&gt;
  &lt;user&gt;
    &lt;name&gt;Иван Иванов&lt;/name&gt;
    &lt;email&gt;ivan.ivanov@example.com&lt;/email&gt;
  &lt;/user&gt;
  &lt;user&gt;
    &lt;name&gt;Мария Петрова&lt;/name&gt;
    &lt;email&gt;maria.petrova@example.com&lt;/email&gt;
  &lt;/user&gt;
&lt;/users&gt;
EOF
</code></pre>
<p><code>dasel -f users.xml -r xml ".users.user.[0].email"</code></p>
<h3 id="xq"><a class="header" href="#xq">xq</a></h3>
<p><code>apt-get install xq || brew install xq</code> установить xq (https://github.com/sibprogrammer/xq) для XML и HTML на GoLang <br />
<code>curl -s https://kinozal.tv/rss.xml -x kinozal:proxy@192.168.3.100:9090 | xq -nx /rss/channel/item</code> вывод содержимого дочерних элементов с тегами <br />
<code>curl -s https://kinozal.tv/rss.xml -x kinozal:proxy@192.168.3.100:9090 | xq -x /rss/channel/item/link</code> вывести только содержимое (массив ссылок) <br />
<code>curl -s https://kinozal.tv -x kinozal:proxy@192.168.3.100:9090 | xq -nq "head"</code> вывести блок head целиком (с тегами) <br />
<code>curl -s https://kinozal.tv -x kinozal:proxy@192.168.3.100:9090 | xq -q "head"</code> вывести только текст из дочерних элементов выбранного тега (содержимое title) <br />
<code>curl -s https://kinozal.tv/browse.php?s=the+rookie -x kinozal:proxy@192.168.3.100:9090 | xq -nq "body &gt; div &gt; div &gt; div &gt; div &gt; table &gt; tbody &gt; tr &gt; td"</code> <br />
<code>curl -s -X POST -u "Login:Password" "http://localhost:9091/transmission/rpc" | xq -q a -a href</code> забрать X-Transmission-Session-Id для дальнейших запросов к API (обратиться к тэгу a и атрибуту href)</p>
<h3 id="htmlq"><a class="header" href="#htmlq">htmlq</a></h3>
<p><code>brew install htmlq</code> установить htmlq (https://github.com/mgdm/htmlq) like jq for HTML <br />
<code>curl -s https://kinozal.tv/browse.php?s=the+rookie -x kinozal:proxy@192.168.3.100:9090 | htmlq table tr td a -t</code> получить содержимое таблицы (вывести только текст содержимого) <br />
<code>curl -s https://kinozal.tv/browse.php?s=the+rookie -x kinozal:proxy@192.168.3.100:9090 | htmlq table tr td a -a href</code> получить только ссылки <br />
<code>curl -s -X POST -u "Login:Password" "http://localhost:9091/transmission/rpc" | htmlq a -a href</code> забрать X-Transmission-Session-Id для дальнейших запросов к API (обратиться к тэгу a и атрибуту href)</p>
<h3 id="yq"><a class="header" href="#yq">yq</a></h3>
<p><code>snap install yq || pip install yq</code> установить yq (https://github.com/kislyuk/yq) для YAML/XML/TOML на Python <br />
<code>cat /etc/netplan/*.yaml | yq .network.ethernets</code> список адаптеров netplan <br />
<code>cat /etc/netplan/*.yaml | yq .network.ethernets.eth0.nameservers.addresses[]</code> вывести массив dns адресов, настроенные на адаптере <br />
<code>curl -s https://kinozal.tv/rss.xml -x kinozal:proxy@192.168.3.100:9090 | yq -p xml .rss.channel.item[1].link</code> вывести ссылку из первого элемента <br />
<code>curl -s https://raw.githubusercontent.com/JingWangTW/dark-theme-editor/main/hugo.toml | yq -p toml .params.footer.socialLink</code> прочитать конфигурацию Hugo</p>
<h3 id="yamllint"><a class="header" href="#yamllint">yamllint</a></h3>
<p><code>apt install yamllint</code> установить yamllint (https://github.com/adrienverge/yamllint) для проверки синтаксических ошибки YAML-файла <br />
<code>yamllint /etc/netplan/*.yaml</code></p>
<h3 id="jsonlint"><a class="header" href="#jsonlint">jsonlint</a></h3>
<p><code>apt-get install -y nodejs</code> установить Node.js <br />
<code>npm install jsonlint -g</code> установить jsonlint (https://github.com/zaach/jsonlint) для проверки синтаксических ошибок JSON <br />
<code>echo '{"name":"example","value":"test",}' | jsonlint</code> <br />
<code>echo '{"name":"example","value":"test"}' | jsonlint</code></p>
<h3 id="csv-1"><a class="header" href="#csv-1">csv</a></h3>
<p><code>brew install csvlens</code> установить csvlens (https://github.com/YS-L/csvlens) для взаимодестия в csv через TUR на Rust <br />
<code>pwsh -Command "Get-Process | ConvertTo-Csv | Out-File process.csv"</code> <br />
<code>csvlens process.csv</code></p>
<h3 id="sttr"><a class="header" href="#sttr">sttr</a></h3>
<p><code>snap install sttr</code> установить sttr (https://github.com/abhimanyu003/sttr) для конвертации и работы данными на GoLang <br />
<code>curl -s curl -s -H "Accept: application/json" https://check-host.net/nodes/hosts | sttr json-yaml</code> конвертировать JSON в YAML <br />
<code>cat /etc/netplan/*.yaml | sttr yaml-json | jq</code> конвертировать YAML в JSON <br />
<code>curl -s https://raw.githubusercontent.com/Lifailon/hwstat/rsa/README.md | sttr markdown-html</code> конвертировать Markdown в HTML <br />
<code>echo "test" | sttr hex-encode</code> кодировать в HEX формат <br />
<code>echo "74657374" | sttr hex-decode</code> декодировать HEX <br />
<code>echo "Test" | sttr upper</code> поднять регистр (TEST) <br />
<code>echo "Test" | sttr lower</code> опустить регистр (test) <br />
<code>echo -e "test1\ntest1\ntest2" | sttr unique-lines</code> получить уникальные строки <br />
<code>echo -e "a\nz\nb" | sttr sort-lines</code> сортировать строки по алфавиту <br />
<code>echo -e "test1 \ntest2" | sttr remove-newlines</code> удалить новые строки <br />
<code>echo -e "test1\ntest2" | sttr count-chars</code> посчитать количество символов <br />
<code>echo -e "test1\ntest2" | sttr count-lines</code> посчитать количество строк</p>
<h2 id="grep"><a class="header" href="#grep">grep</a></h2>
<p><code>cat /var/log/auth.log | grep sshd</code> логи всех SSH-подключений <br />
<code>cat /etc/passwd | grep -w sys</code> поиск целого слова, окруженное пробелами (<code>-w</code>) <br />
<code>cat /etc/ssh/sshd_config | grep -win port</code> не учитывать регистр (<code>-i</code>) и отобразить номера строк (<code>-n</code>) <br />
<code>ss -n | grep -P ":22|:80|:443|:8080"</code> искать по нескольким шаблонам, использовать Regex (<code>-E</code>) <br />
<code>ss -n | grep -Pc ":22|:80"</code> вывести кол-во (<code>--count</code>) совпадений <br />
<code>ss -n | grep "192.168.3...:"</code> поиск любых двух символов (<code>.</code>) <br />
<code>ss -n | grep "192.168.3.*:"</code> поиск любого кол-ва (<code>*</code>) <br />
<code>cat /etc/ssh/sshd_config | grep -v "#"</code> вывести значения, не подходящие под критерии поиска (<code>-v</code>) <br />
<code>cat /etc/zabbix/zabbix_agentd.conf | grep -v "^#"</code> отсеить только в начале строки (<code>^</code>) <br />
<code>cat /etc/zabbix/zabbix_agentd.conf | grep "=$"</code> найти строки, которые кончаются <code>$</code> на символ <code>=</code> (получить все параметры) <br />
<code>cat /etc/zabbix/zabbix_agentd.conf | grep -Pv "^$|^#"</code> удалить пустые строки <code>^$</code> и комментарии (<code>^#</code>) <br />
<code>cat /etc/zabbix/zabbix_agentd.conf | grep -E "#+{5}"</code> регулярное выражение (<code>-E</code>), где последний символ <code>#</code> повторяется 5 или более раз <br />
<code>echo -e "Test\ntest\n123-45" | grep -E "[a-zA-Z\-]"</code> искать только текст (где есть буквы и тире) <br />
<code>echo 'test&lt;version&gt;1.2.3&lt;/version&gt;test' | grep -P -o "(?&lt;=&lt;version&gt;).*(?=&lt;/version&gt;)"</code> найти неизвестное значение (<code>.*</code>) между известными и вывести только найденное (<code>-o</code>) <br />
<code>echo "test&lt;version&gt;3.6.4&lt;/version&gt;test" | grep -Eo '[0-9.]+'</code> найти любую цифру и точку на конце, которые повторяются любое кол-во раз подряд <br />
<code>echo $(lshw -class bus) | grep -P -o "(?&lt;=Motherboard product: ).*(?=serial)"</code> с применение группировки (<code>-P</code>) <br />
<code>zabbix_path=$(systemctl status zabbix-agent | grep -Po "(?&lt;=-c ).*(?=.conf)" | sed "s/$/.conf/")</code> забрать путь до конфигурационного файла Zabbix агента <br />
<code>cat $zabbix_path | grep -E "^Server=|^ServerActive="</code> найти имя сервера <br />
<code>cat $zabbix_path | grep -Po "(?&lt;=^Server=).+"</code> вывести только имя сервера <br />
<code>resolvectl | grep "DNS Servers" -m 1</code> напечатать только первое совпадение (<code>-m int</code>) <br />
<code>networkctl status | grep -A 3 "DNS:"</code> найти строку и напечатать три строки после нее (<code>-A</code>) <br />
<code>networkctl status | grep -B 3 "DNS:"</code> найти строку и напечатать три строки до нее (<code>-B</code>) <br />
<code>networkctl status | grep -C 1 "DNS:"</code> найти строку и напечатать одну строки до нее и одну после (<code>-C</code>) <br />
<code>resolvectl | grep -Ex ".+DNS Servers:.+"</code> вывести строки с точным совпадение (<code>-x/like</code>), сопоставлять только целые строки <br />
<code>if echo "GET" | grep -Eq "^GET"; then echo da; else echo net; fi</code> подавлять вывод (<code>-q</code>) для проверки условия <br />
<code>curl https://api.github.com/repos/PowerShell/PowerShell/releases/latest | grep -Eom 1 "https://.+.deb"</code> забрать только первый подходящий под поиск</p>
<h3 id="ripgrep"><a class="header" href="#ripgrep">ripgrep</a></h3>
<p><code>apt-get install ripgrep</code> установить ripgrep (https://github.com/BurntSushi/ripgrep), аналог grep на Rust <br />
<code>cat /var/log/auth.log | rg sshd</code> вывести журнал логов аудентификации фильтрацией по названию <br />
<code>cat /var/log/auth.log | rg "Accepted password for \w+ from \d+\.\d+\.\d+\.\d+"</code> вывести строки, где указано <code>Accepted password for</code>, далее любое слово (имя пользователя) и IP-адрес в формате x.x.x.x <br />
<code>cat /var/log/auth.log | rg "user \w+\(uid=\d+\)"</code> вывести строки с текстом user, затем имя пользователя (любое слово), и далее <code>uid</code> с числовым значением в скобках <br />
<code>cat /var/log/auth.log | rg "192\.168\.\d+\.\d+"</code> вывести строки, где первые два октета соответствуют <code>192.168</code> <br />
<code>cat /var/log/auth.log | rg "sshd\[\d+\]: .* port \d+"</code> вывести строки, содержащие sshd с идентификатором процесса (например, <code>sshd[4188420]</code>), а затем текст <code>port</code> и номер порта <br />
<code>cat /var/log/auth.log | rg "\b12:\d{2}:\d{2}\b"</code> фильтрация по времени за последние 12 часов (время начинается с <code>12:</code>, затем две цифры для минут и две для секунд)</p>
<h3 id="sig"><a class="header" href="#sig">sig</a></h3>
<p><code>brew install ynqa/tap/sigrs</code> установить sig (https://github.com/ynqa/sig) интерактивный grep на Rust <br />
<code>curl -s https://raw.githubusercontent.com/Lifailon/hwstat/rsa/README.md &gt; README.md</code> <br />
<code>cat README.md |&amp; sig -a</code></p>
<h2 id="sed"><a class="header" href="#sed">sed</a></h2>
<p><code>cat /etc/passwd | sed -n "1,5p"</code> отобразить с первой по пятую строку (<code>p</code>) <br />
<code>cat /etc/passwd | sed "$ d"</code> удалить (<code>d</code>) последнюю строку <br />
<code>cat /etc/passwd | sed "1,3d"</code> удалить c первой по третью строку (<code>2,3d</code>) <br />
<code>echo "One 1" | sed "s/One/Two/; s/1/2/"</code> заменить One на Two и 1 на 2 <br />
<code>cat /etc/zabbix/zabbix_agentd.conf | sed "s/127.0.0.1/192.168.3.102/" #  &gt; /etc/zabbix/zabbix_agentd.conf</code> заменить (<code>s</code>) ip-адрес <br />
<code>cat /etc/zabbix/zabbix_agentd.conf | sed "/^#\|^$/d"</code> удалить пустые строки <code>^$</code> и комментарии <code>^#</code> <br />
<code>timedatectl | grep zone | sed -E "s/.+zone: //"</code> удалить любое кол-во лимволов до слова "zone: " включительно, используя Regex (<code>-E/-r</code>) <br />
<code>echo -e "test\ntest" | sed "2s/test/test2/"</code> заменить во второй строке (<code>2s</code>) <br />
<code>echo -e "test\ntest\ntest\ntest" | sed "2,3s/test/test2/"</code> заменить во второй и третей строке (<code>2,3s</code>) <br />
<code>echo -e "test\ntest\ntest\ntest" | sed "2ctest2"</code> заменить вторую строку (<code>2c</code>) <br />
<code>echo "The test and test" | sed "s/test/test2/g"</code> заменить для каждого совпадения (<code>/global</code>) <br />
<code>echo "The test and test" | sed "s/test/test2/2"</code> заменить для второго совпадения (<code>/2</code>) <br />
<code>echo "line2" | sed "i\line1"</code> добавить строку в начало (<code>i</code>) <br />
<code>echo "line1" | sed "a\line2"</code> добавить строку в конец (<code>a</code>) или в после указанной строки (<code>2a</code>) <br />
<code>echo "11 22 33 34" | sed "y/123/234/"</code> заменить 1 на 2, 2 на 3, 3 на 4 (<code>y</code>) <br />
<code>ls -R | grep ':' | sed "s/:$//; s/[^\/]*\// - /g"</code> удалить <code>:</code> в конце и заменить вначале строки <code>"/любое кол-во символов между/"</code> на <code>" - "</code> для всех (<code>/g</code> global) <br />
<code>echo "test&lt;version&gt;3.6.4&lt;/version&gt;test" | sed -r 's/[^&lt;]*&lt;(.*)&gt;.*/\1/;s/&lt;.*//;s/.*&gt;//'</code> использовать regex (<code>-r</code>) <br />
<code>ps aux | grep -E "^zabbix .+ -c" | sed -E "s/^zabbix.+-c //"</code> найти процесс zabbix с ключем <code>-c</code> и оставить путь <code>conf</code> <br />
<code>echo "MPEG-H HEVC, 88.5 Мбит/с, 3840x2160, 23.976 кадр/с, 10 бит" | sed -nr 's/.* ([0-9]+x[0-9]+).*/\1/p'</code> выводить только найденные строки (<code>-n</code>) с заменой (<code>s/</code>), ищем только цифры <code>[0-9]</code> где одно или более вхождений (<code>+</code>) и между ними <code>x</code>, вывести только первую группу поиска (то, что в скобках) на печать (<code>/p</code>)</p>
<h2 id="awk"><a class="header" href="#awk">awk</a></h2>
<p><code>cat /etc/passwd | awk -F: '{print "name: " $1 " \t Dir: " $NF}'</code> вывести содержимое первого и последнего <code>$NF</code> элемента в строке, используя разделитель ":" и табуляцию (\t) <br />
<code>echo 'one two three four' | awk '{print $(NF-1)}'</code> вывести содержимое преподследнего элемента <br />
<code>echo 'one two three four five' | awk '{print $((NF/2)+1)}'</code> вывести содержимое из середины <br />
<code>echo "One Two Three" | awk '{$3="Four"; print $0}'</code> заменить третье значение/переменную в строке <br />
<code>cat /etc/passwd | awk 'BEGIN{FS=":"; OFS=" - "} {print $1,$7}'</code> указать разделитель послей (элементов) на вход (<code>FS</code>) и заменить его на выходе (<code>OFS</code>) <br />
<code>uptime | awk 'BEGIN{RS=" "; ORS="\n"} {print $0}'</code> указать разделитель записей (строк) на входе (<code>RS</code>) и заменить его на выходе (<code>ORS</code>) <br />
<code>echo -e "12345\n54321" | awk 'BEGIN{FIELDWIDTHS="2 3"}{print $1,$2}'</code> указать фиксированное кол-во символов для разделения <br />
<code>lsof | awk '{if($7=="REG")print $0}'</code> условие для выборки по столбцу <br />
<code>cat /etc/ssh/sshd_config | awk '/Port / {print $2}'</code> условие поиска для вывода <br />
<code>cat /etc/ssh/sshd_config | awk 'length $0 &gt; 1'</code> вывести строки, которые длиннее, чем 1 символ (удалить пустые строки) <br />
<code>cat /var/log/syslog | grep "$date" | awk '{print length($6)}'</code> вывести длинну значения <br />
<code>awk 'BEGIN{x = "low"; print toupper(x)}'</code> использовать функцию для перевода в вверхний регистр <br />
<code>awk 'BEGIN{x = "LOW"; print tolower(x)}'</code> использовать функцию для перевода в нижний регистр <br />
<code>echo "1 2 3 4:5:6" | awk '{item=$4; split(item,array,":"); print array[2]}'</code> разбить 4 значение на массив (используя функцию <code>split</code>) и забрать значение по 2-му индексу <br />
<code>free | awk '{if (NR == 2) print $0}'</code> вывести только вторую строку <br />
<code>free | awk '{if (NR &gt;= 2) print $0}'</code> вывести втроую и последующие строки <br />
<code>free | awk '{if (NF &gt;= 5) print $0}'</code> вывести строки, где 5 или больше значений <br />
<code>cat /etc/passwd | awk '{ if (NR &gt;= 10 &amp;&amp; NR &lt;= 20) print $0}'</code> вывести с 10 по 20 строки <br />
<code>last | sed -n 1p | awk '$2=" ",$4=" "{print $0}'</code> вывести все, кроме 2 и 4 значения (заменить) <br />
<code>ps -A | awk '{sum=""; for(i=1;i&lt;=NF;i++) { if (i != 2) {sum=sum" "$i} } print sum}'</code> вывести все, кроме 2-го значения</p>
<p><code>cut -d',' -f2,4 file.csv</code> взять второй и четвертый столбцы <br />
<code>awk -F',' '{if (NF &gt;= 4) print $2, $4}' file.csv</code></p>
<p><code>grep "Error" logs.txt</code> <br />
<code>awk '/Error/' logs.txt</code> <br />
<code>awk '/^Error [0-9]{3}:/' logs.txt</code></p>
<p><code>grep -c "Success" logs.txt</code> посчитать количество совпадений <br />
<code>awk '/Success/ {count++} END {print count}' logs.txt</code></p>
<p><code>sed 's/Error/Success/g' file.txt</code> замена слов <br />
<code>awk '{gsub(/Error/, "Success"); print}' file.txt</code></p>
<p><code>sort file.txt | uniq</code> <br />
<code>awk '!seen[$0]++' file.txt</code> заполняем уникальный массив строк</p>
<p><code>wc -w file.txt</code> посчитать количество слов в файле <br />
<code>awk '{count += NF} END {print count}' file.txt</code></p>
<p><code>sed -n '10,20p' file.txt</code> вывести с 10 по 20 строку <br />
<code>awk 'NR&gt;=10 &amp;&amp; NR&lt;=20' file.txt</code></p>
<p><code>awk '{sum += $1} END {print sum/NR}' numbers.txt</code> получить среднее значение чисел в первом столбце <br />
<code>awk '{ if ($2 &gt; 50000) print $1, "&gt; 50K"; else print $1, "&lt; 50K" }' data.txt</code> вывести значение первого столбца, если значение второго столбца выше или ниже 50 тысяч <br />
<code>awk '{ sum = 0; for (i = 1; i &lt;= NF; i++) sum += $i; print "сумма:", sum }' data.txt</code> посчитать сумму числе в каждой строке <br />
<code>awk '{ for (i = 1; i &lt;= NF; i++) sum[i] += $i } END { for (i in sum) print "Столбец", i, "сумма:", sum[i] }' data.txt</code> посчитать сумму числе в каждом столбце</p>
<h2 id="printf"><a class="header" href="#printf">printf</a></h2>
<p><code>top=$(top -bn1)</code> <br />
<code>printf "%s\n" "${top[@]}"</code> вывести вывод массива построчно <br />
<code>printf "%.2f \n" 1.1111</code> округлить до 2 символов после запятой <br />
<code>printf "%.0f \n" 1.6</code> удалить дробную часть (округлить до 2) <br />
<code>printf "Arg1: %s\nArg2: %s\n" "10" "20"</code> принимает и выводит аргументы (%s) в виде строки</p>
<h2 id="cut"><a class="header" href="#cut">cut</a></h2>
<p><code>echo "1 2 3" | cut -c 1,5</code> вывести первый и пятый симов (<code>--bytes</code>/<code>--characters</code>) <br />
<code>echo "1 2 3" | cut -c 1-3</code> вывести с первой по третий символ <br />
<code>echo "1 2 3" | cut -c3-</code> удалить первые 2 символа <br />
<code>echo -e "test1,test2,test3\ntest1,test2,test3" | cut -d , -f 2-100</code> указать разделитель полей/столбцов (<code>--delimiter</code>) и какие столбцы вывести (<code>--fields</code>) с 2 по 100 <br />
<code>echo -e "test1,test2,test3\ntest1,test2,test3" | cut -d , -f 1,3 | sed "s/,/ /"</code> вывести 1 и 3 <br />
<code>echo -e "test1,test2,test3\ntest1 test2 test3" | cut -d , -f 1,3 -s</code> печатать строки, где есть разделитель (<code>-s</code>)</p>
<h3 id="rev"><a class="header" href="#rev">rev</a></h3>
<p><code>echo "D:\plex-content\Rick.and.Morty.S07.2023.WEBDLRip.MegaPeer" | rev | cut -d \\ -f 1 | rev</code> забрать последний элемент в пути (вначале разворачивает всю строку, забирает первый элемент и разворачивает строку обратно) <br />
<code>echo "D:\plex-content\Rick.and.Morty.S07.2023.WEBDLRip.MegaPeer" | sed -r 's/.+\\//'</code> удалить все до последнего слеша <br />
<code>echo "D:\plex-content\Rick.and.Morty.S07.2023.WEBDLRip.MegaPeer" | sed 's/.*\\\(.*\)/\1/'</code> удаляет все до последнего слеша и забирает одну группу захвата, что остается после удаления, и заменяет вывод на первую группу (1) <br />
<code>echo "D:\plex-content\Rick.and.Morty.S07.2023.WEBDLRip.MegaPeer" | awk -F '\\' '{print $NF}'</code> забрать последний элемент массива (NF)</p>
<h2 id="tr"><a class="header" href="#tr">tr</a></h2>
<p><code>echo "10 20 100 200" | tr 1 2</code> translate заменяет 1 на 2 для всех подходящих сомволов (20 20 200 200) <br />
<code>echo "1 2 3" | tr " " ","</code> заменить пробелы на запятые (1,2,3) <br />
<code>echo "1 2 3" | tr -d " "</code> удалить пробелы (123)</p>
<h2 id="man"><a class="header" href="#man">man</a></h2>
<h3 id="cheat-sh"><a class="header" href="#cheat-sh">cheat sh</a></h3>
<p><code>curl cheat.sh/curl</code> <br />
<code>curl cheat.sh/grep</code> <br />
<code>curl cheat.sh/sed</code> <br />
<code>curl cheat.sh/awk</code> <br />
<code>curl cheat.sh/jq</code> <br />
<code>curl cheat.sh/iptables</code> <br />
<code>curl cheat.sh/find</code></p>
<h3 id="tldr"><a class="header" href="#tldr">tldr</a></h3>
<p><code>pip3 install tldr</code> упрощенный вариант man с примерами использования <br />
<code>tldr curl</code> веб-версия: https://manned.org/man/curl</p>
<h2 id="debug"><a class="header" href="#debug">debug</a></h2>
<p><code>trap 'echo "$BASH_COMMAND"' DEBUG</code> построчная отладка скриптов bash, команда trap перехватывает сигнал DEBUG, посылаемый перед выполнением команды и выводит команду на экран <br />
<code>trap 'echo "$BASH_COMMAND";read' DEBUG</code> read ожидает ввода с клавиатуры (Enter или Ctrl+C) перед выполнением каждой командой <br />
<code>bash -x script.sh</code> отладка (печать команд и их аргументов по мере их выполнения) <br />
<code>bash -x -c "ls -l" | grep *.sh | awk '{print $5,$NF}'</code> запуск команды через интерпритатор bash и вывод отладки <br />
<code>bash --debug script.sh</code> проверка на ошибки <br />
<code>apt-get install shellcheck</code> установить shellcheck <br />
<code>shellcheck -S error hwstat.sh</code> error/warning/info/style <br />
<code>pip3 install thefuck</code> установить thefuck <br />
<code>bas hwstat.sh</code> запустить команду с ошибкой <br />
<code>fuck</code> автоматически исправляет последнюю ошибочную команду из выпадающего списка (up/down)</p>
<h2 id="tools"><a class="header" href="#tools">tools</a></h2>
<p><code>pip install toolong</code> <br />
<code>tl /var/log/auth.log</code> интерактивный просмотр логов в консоли с фильтрацией <br />
<code>tl access.log* --merge</code> просмотр нескольких файлов</p>
<p><code>apt install bat</code> аналог cat (https://github.com/sharkdp/bat) с подсветкой синтаксиса
<code>bat /etc/netplan/*.yaml</code></p>
<p><code>tree /var/log/</code> древовидный просмотр директорий и дочерних файлов</p>
<p><code>cargo install --locked broot</code> установить broot (https://github.com/Canop/broot), аналог tree <br />
<code>broot kinozal-bot/</code></p>
<p><code>echo 'deb http://cz.archive.ubuntu.com/ubuntu jammy main universe' &gt;&gt; /etc/apt/sources.list &amp;&amp; apt update</code> <br />
<code>apt install exa</code> установить аналог ls (https://github.com/ogham/exa) <br />
<code>exa $(pwd) -l --icons</code> отобразить иконки с подсветкой прав доступа</p>
<p><code>cargo install eza</code> аналог ls (https://github.com/eza-community/eza) на базе exa <br />
<code>eza -l --icons</code> <br />
<code>eza --tree kinozal-bot/</code></p>
<p><code>cargo install lsd</code> аналог ls (https://github.com/lsd-rs/lsd) <br />
<code>lsd -l kinozal-bot/</code></p>
<p><code>column /etc/passwd -t -s ":"</code> <br />
<code>netcheck -t ping yandex.ru us1.node.check-host.net | sed -r 's/"//g; s/,$//; s/\{|\}|\[|\]//' | column -t -s ":"</code> распарсить JSON и добавить отступ (табуляцию) для колонок</p>
<p><code>ls /home | wc -l</code> word count выводит количество строк (<code>--line</code>) <br />
<code>ls /home | wc -w</code> количество слов (<code>--words</code>) <br />
<code>ls /home | wc -m</code> количество символом (<code>--chars</code>) <br />
<code>ls /home | wc -c</code> количество символов/байт (<code>--bytes</code>)</p>
<p><code>echo "(5.5-2.2)" | bc</code> математические вычисления <br />
<code>echo "(5.5-2.2)" | bc | sed -E "s/\..+//"</code> удалить дробную часть <br />
<code>echo "1 &lt; 2" | bc</code> возвращает булевое значение (1 - да или 0 - нет) <br />
<code>echo "1 &gt; 2" | bc</code> false (0) <br />
<code>icmp_ignore=$(cat /proc/sys/net/ipv4/icmp_echo_ignore_all)</code> забрать значение <br />
<code>if (( $(echo "$icmp_ignore == 1" | bc) )); then echo "true"; else echo "false"; fi</code> проверить в условии арефметическое значение на равенство (возвращает 0 - <code>false</code> или 1 - <code>true</code>)</p>
<p><code>a=1</code> <br />
<code>b=0.55</code> <br />
<code>echo $(bc &lt;&lt;&lt; "scale=2; $a+$b")</code> <br />
<code>echo "print $a+$b" | perl</code> <br />
<code>echo "print($a+$b)" | python3</code> <br />
<code>echo "print($a+$b)" | lua</code> <br />
<code>echo "puts $a+$b" | ruby</code> <br />
<code>pwsh -Command $a+$b</code></p>
<p><code>echo -e "key1\nkey2\nkey3" &gt; 1.txt</code> <br />
<code>echo -e "value1\nvalue2\nvalue3" &gt; 2.txt</code> <br />
<code>paste 1.txt 2.txt -d :</code> объединяет два файла в один многоколоночный вывод <br />
<code>cat /etc/passwd | paste -s -d +</code> объеденить (join) многострочный файл, используя указанный delimiter</p>
<p><code>echo -e "test1\ntest2" &gt; 1.txt \  </code>echo -e "test\ntest2\ntest3" &gt; 2.txt <br />
<code>diff 1.txt 2.txt -c</code> ! есть изменения, + есть новая строка <br />
<code>diff 1.txt 2.txt -yi</code> сравнивает в две колонки (| есть изменения, + есть новая строка) и игнорировать регистр (-i) <br />
<code>diff 1.txt 2.txt -u</code> объеденяет два файла в один вывод с отображением изменений (+/) <br />
<code>diff 1.txt 2.txt -ibBEt</code> не учитывать пробелы (-b) и пустые строки (-B), игнорировать изменения в табуляциях (-E) и заменить табуляции на пробелы в выводе (-t) <br />
<code>diff -c &lt;(echo "$predu") &lt;(echo "$du")</code> сравнить содержимое переменных</p>
<p><code>snap install diff-so-fancy</code> <br />
<code>diff -u file-1.txt file-2.txt | diff-so-fancy</code></p>
<p><code>apt install jdupes</code> <br />
<code>jdupes .</code> поиск дубликатов</p>
<p><code>cat /etc/passwd | sort -r</code> отсортировать вывод по алфовиту в обратном порядке (-r) <br />
<code>du -h ~ | sort -n</code> сортировать по арифметическому значению (-n) размер файлов и директорий <br />
<code>ls -l | sed 1d | sort -nk5</code> сортировка по пятой колонке (-k) <br />
<code>cat $tmp | sort -t "." -nk4</code> сортировать по четвертой колонке, используя разделитель (-t) точку</p>
<p><code>echo -e "1 2\n1 2\n2 1\n1 2" | uniq</code> удаляет соседние одинаковые строки <br />
<code>echo -e "1 2\n1 2\n2 1\n1 2" | sort | uniq</code> удалить все дубликаты <br />
<code>echo -e "1 2\n1 2\n2 1\n1 2" | sort | uniq -c</code> добавляет в начало каждой строки кол-во повторений <br />
<code>echo -e "1 2\n1 2\n2 1\n1 2" | sort | uniq -u</code> отобразить только уникальные строки, без строк с повторениями</p>
<p><code>ls -l | fold -w 50</code> задать ширину вывода каждой строки, выпадающее за указанный предел переносится на новую строку <br />
<code>ls -l | fold -w 50 -s</code> разбивать строки только на символах пробела (--space)</p>
<p><code>cat /var/log/syslog | head -n 5</code> выводит первые 5 строк файла</p>
<p><code>cat /var/log/syslog | tail -n 5 </code> просмотр последних 5 строк файла <br />
<code>tail -f /var/log/syslog</code> просмотр содержимого файла в реальном времени</p>
<p><code>apt install multitail</code> <br />
<code>multitail -f /var/log/auth.log -f /var/log/kern.log</code> <br />
<code>multitail -l "journalctl -fu ssh" -l "journalctl -fu cron"</code></p>
<p><code>less /var/log/dmesg</code> вывести лог ядра с возможностью пролистывания</p>
<p><code>watch df -h</code> выводит на экран и обновляет состояния подключенных устройств каждые 2 секунды</p>
<p><code>echo "line1" | tee test.txt</code> перезаписать файл (&gt;) <br />
<code>ls &gt; /dev/null</code> перенаправить вывод в null <br />
<code>echo "line2" | tee -a test.txt</code> добавить (&gt;&gt;) текст новой стройокй в конец файла <br />
<code>echo -e "line3\nline4" &gt;&gt; test.txt</code> добавить две новые строки</p>
<p><code>du -a /var/log | awk '{print $2}' | xargs fincore</code> передать вывод первой команды построчно в аргументы следующей</p>
<p><code>split -l 100 input_file.txt output_prefix</code> разделить файл на части по 100 строк в каждой <br />
<code>split -b 10M input_file.txt output_prefix</code> разделить файл на части по указанному размеру (например, 10MB)</p>
<p><code>yes</code> предназначена для автоматического вывода строки или символа, повторяющегося бесконечно (для нагрузки системы), либо для автоматического подтверждения запросов в других командах</p>
<h2 id="dust"><a class="header" href="#dust">dust</a></h2>
<p><code>snap install dust</code> аналог du на Rust (https://github.com/bootandy/dust) <br />
<code>dust /home/lifailon</code> выводит график используемого пространства по директориям и файлам для анализа занятого пространства <br />
<code>dust -s</code> показывает размер файла, а не объем используемого им дискового пространства <br />
<code>dust -n 30</code> выводит 30 каталогов (по умолчанию — высота терминала) <br />
<code>dust -d 3</code> показывает 3 уровня подкаталогов <br />
<code>dust -D</code> отобразить только директории <br />
<code>dust -F</code> отобразить только файлы <br />
<code>dust -f</code> считайте файлы вместо дискового пространства <br />
<code>dust -i</code> не показывать скрытые файлы <br />
<code>dust -z 10M</code> минимальный размер, включать только файлы размером более 10 МБ <br />
<code>dust -z 40000/30MB/20kib</code> исключить выходные файлы/каталоги размером менее 40 000 байт/30 МБ/20 КБ <br />
<code>dust -o si/b/kb/kib/mb/mib/gb/gib</code> формат вывода <br />
<code>dust -e "\.png$"</code> включать только те файлы, которые соответствуют регулярному выражению (например, только файлы <code>png</code>) <br />
<code>dust -v "\.png$"</code> регулярное выражение для игнорирования файлов с разрешением <code>png</code> <br />
<code>dust -j  | jq</code> вывод в формате <code>JSON</code> <br />
<code>dust -P</code> отключить индикатор прогресса</p>
<h2 id="find"><a class="header" href="#find">find</a></h2>
<p><code>find / -name "*.sql"</code> найти файлы, начать поиск с корня (/) <br />
<code>find / -iname "mysql"</code> найти файлы не учитывая регистр (-i) <br />
<code>find ~ -name "test.*" -not -name "*.conf"</code> найти все файлы с наименование test, которые имеют любое расширение, за исключением (-not) расширения .conf <br />
<code>find ~ -amin -10</code> поиск файлов по дате последнего чтения (-amin) которые просматривались (cat/nano) за последние 10 минут <br />
<code>find ~ -type f -mmin -10</code> найти файлы (-type f), которые были модифицированны за последние 10 минут (-nmin) <br />
<code>find ~ -type f -mtime +1 -mtime -7</code> найти все файлы, модифицированные между 1 и 7 днями назад <br />
<code>find ~ -type d -mtime +1 -mtime -7</code> поиск директорий <br />
<code>find ~ -size +50M -size -100M</code> поиск файлов в Linux по их размеру, от 50 до 100 мегабайт <br />
<code>find / -perm 444</code> поиск файлов по режиму доступа (только чтение для всех) <br />
<code>find /home/lifailon/ -user root</code> поиск файлов по владельцу <br />
<code>find /home/lifailon/ -group root</code> поиск по группе <br />
<code>find /root/ -empty</code> поиск пустых файлов или директорий</p>
<h3 id="exec"><a class="header" href="#exec">exec</a></h3>
<p><code>touch -t 202306222200.15 /tmp/test.txt</code> создать файл с указанной датой создания <br />
<code>find /tmp -type f -mtime +30 -exec rm -f {} \;</code> удалить все файлы, котоыре не изменялись больше 30 дней <br />
<code>find /tmp -type f -name "*.txt" -exec rm -f {} \;</code> удалить все текстовые файлы в директории tmp <br />
<code>dd if=/dev/zero of=/var/log/test.log count=11 bs=1M</code> создать файл заполненный нулями указанного размера <br />
<code>find /var/log -type f -name "*.log" -size +10M -exec rm -f {} \;</code> удалить все лог-файлы, объёмом больше 10 Мбайт</p>
<h3 id="locate"><a class="header" href="#locate">locate</a></h3>
<p><code>apt install plocate</code> <br />
<code>updatedb</code> обновить индексы базы данных <br />
<code>locate .torrent</code> найти по частичному совпадению в имени или расширению <br />
<code>locate .torrent -c</code> отображает количество найденных результатов <br />
<code>locate -n 10 .torrent</code> вывести 10 результатов <br />
<code>locate -i Kinozal-Bot</code> игнорировать регистр <br />
<code>locate -r "\.log$"</code> использовать регулярные выражения</p>
<pre><code class="language-bash">sudo curl -s https://github.com/pr4k/locate/releases/download/v0.1.1/locate-linux -o /usr/bin/locate -o /usr/bin/locate
sudo chmod +x /usr/bin/locate
</code></pre>
<p><code>locate-linux -p /home/lifailon/ -q /qbittorrent</code> <br />
<code>locate-linux -p /home/lifailon/.bash_history -q /qbittorrent</code></p>
<h3 id="fd"><a class="header" href="#fd">fd</a></h3>
<p><code>apt install fd-find</code> установка (https://github.com/sharkdp/fd) <br />
<code>fdfind</code> без аргументов заменяет ls -R для рекурсивного поиска в текущем каталоге <br />
<code>fdfind pass /etc</code> ищет в указанной директории по частичному совпадению <br />
<code>fdfind -H pre-commit</code> поиск скрытых файлов <br />
<code>fdfind .yaml / | fzf</code> ищет все файлы с корня с выводов в fzf <br />
<code>sudo fdfind .yaml / | fzf</code> отобразит все результаты поиска <br />
<code>fdfind --type f -e pdf . $HOME | rofi -keep-right -dmenu -i -p FILES -multi-select | xargs -I {} xdg-open {}</code> интеграция с rofi (графическое меню) <br />
<code>fd -e zip -x unzip</code> рекурсивно найти все zip-архивы и распаковать их</p>
<h2 id="bashrc"><a class="header" href="#bashrc">bashrc</a></h2>
<p><code>nano ~/.bashrc</code></p>
<pre><code class="language-bash"># Псевдонимы для команды или набора команд с флагами для сокращения ввода 
alias tspin=tailspin
alias ts=tailspin

function Out-TailSpin() {
     "$@" | ts
}
alias cot="Out-TailSpin cat"

# Забиндить очистку ввода на Ctrl+C
bind '"\C-l": "^\C-u\C-mclear\C-m"'

# Определить переменную окружения, доступную для дочерних процессов, запущенных в текущей сессии
# Игнорировать запись в историю команд, которые начинаются с пробела
export HISTCONTROL=ignorespace
# Добавить фильтрацию по введеному тексту в истории команд при испоьзовании стрелочек вверх и вниз
if [[ "$-" == *i* ]]; then
    bind '"\e[A": history-search-backward'
    bind '"\e[B": history-search-forward'
fi
</code></pre>
<p><code>source ~/.bashrc</code> применить политики</p>
<h3 id="oh-my-bash"><a class="header" href="#oh-my-bash">oh-my-bash</a></h3>
<p>Установить <code>oh-my-bash</code> (обновляет профиль, делая рядом резервную копию старого файла в <code>.bashrc.omb-TIMESTAMP</code>):</p>
<p><code>bash -c "$(curl -fsSL https://raw.githubusercontent.com/ohmybash/oh-my-bash/master/tools/install.sh)"</code></p>
<p>Настроить динамический профиль:</p>
<pre><code class="language-bash">function sysStat() {
    top=$(top -bn1)
    cpu=$(echo "$top" | grep "%Cpu(s)" | awk '{printf "%.0f%%", 100-$8}')
    # sys=$(echo "$top" | grep "%Cpu(s)" | awk '{printf "%.0f%%", $4}')
    # usr=$(echo "$top" | grep "%Cpu(s)" | awk '{printf "%.0f%%", $2}')
    avg=$(echo "$top" | grep "load average" | awk -F ': ' '{print $2}' | awk -F ', ' '{print $1"/"$2"/"$3}')
    mem=$(echo "$top" | grep "MiB Mem" | awk '{printf "%.1fG/%.1fG", ($8)/1024, $4/1024}')
    disk=$(df -h | awk '$NF=="/"{print $3"/"$2}')
    echo "📊 $cpu ($avg) $mem 💾 $disk"
}

function gitStatus() {
    status=$(git status --porcelain 2&gt;/dev/null)
    if [ -z "$status" ]; then
        echo ""
        return
    fi
    branch=$(git rev-parse --abbrev-ref HEAD)
    result="🔸 ($branch) "
    added=$(echo "$status" | grep -c '^?')
    modified=$(echo "$status" | grep -c '^ M')
    deleted=$(echo "$status" | grep -c '^ D')
    [ "$added" -gt 0 ] &amp;&amp; result+="\e[32m+${added} \e[0m"
    [ "$modified" -gt 0 ] &amp;&amp; result+="\e[33m~${modified} \e[0m"
    [ "$deleted" -gt 0 ] &amp;&amp; result+="\e[31m-${deleted} \e[0m"
    echo "$result"
}

export PROMPT_COMMAND+='
    SYSSTAT=$(sysStat);
    GITSTATUS=$(gitStatus);
'

PS1='\[\e[34m\]$SYSSTAT \[\e[0m\]'
PS1+='\[\e[32m\]👤 \u \[\e[0m\]'
PS1+='\[\e[33m\]📁 \w \[\e[0m\]'
PS1+='$(echo -e "$GITSTATUS")'
PS1+='\[\e[34m\]&gt; \[\e[0m\]'
</code></pre>
<h3 id="fzf"><a class="header" href="#fzf">fzf</a></h3>
<p><code>apt install fzf</code> установить <a href="https://github.com/junegunn/fzf">fzf</a> <br />
<code>history | fzf</code> интерактивный поиск с фильтрацией <br />
<code>eval $(history | fzf | awk '{print $2}')</code> выполнить (eval) выбранную команду из списка (добавить в макрос) <br />
<code>find / -name "*.yaml" | fzf | xargs cat</code> найти в системе все файлы yaml и запустить по ним поиск</p>
<pre><code class="language-bash">tee -a "$HOME/.bashrc" &lt;&lt; 'EOF'
# Поиск по истории команд с помощью команды h и комбинации Ctrl+R через fzf
export PROMPT_COMMAND='history -a;'
if command -v fzf &gt; /dev/null; then
    function hstr {
        local current_input="$READLINE_LINE"
        command=$(tac $HOME/.bash_history | sed '/^#/d' | awk '!seen[$0]++' |  fzf --height 20 --reverse --query="$current_input" | sed -r "s/^\s+[0-9]+\s+[0-9]{4}-[0-9]{2}-[0-9]{2}\s+[0-9]{2}:[0-9]{2}:[0-9]{2}\s//")
        if [[ -n "$command" ]]; then
            READLINE_LINE="$command"
            READLINE_POINT=${#READLINE_LINE}
        fi
    }
    alias h=hstr
    bind -x '"\C-r": h'
fi
# Kill jobs over fzf
if command -v fzf &gt; /dev/null; then
    function jobKill {
        pid=$(jobs -l | fzf --height 20 --reverse --preview "echo {}" --preview-window down | awk '{print $2}')
        if [[ -n "$pid" ]]; then
            READLINE_LINE="kill -9 $pid"
            READLINE_POINT=${#READLINE_LINE}
        fi
    }
    bind -x '"\C-j": jobKill'
fi
EOF
</code></pre>
<h3 id="fzf-obc"><a class="header" href="#fzf-obc">fzf-obc</a></h3>
<p>Установить <a href="https://github.com/rockandska/fzf-obc">fzf over bash complete</a> (выпадающий список автодополнения команд) и добавить в профиль <code>bash</code>:</p>
<pre><code class="language-bash">git clone https://github.com/rockandska/fzf-obc $HOME/.local/opt/fzf-obc
echo "source $HOME/.local/opt/fzf-obc/bin/fzf-obc.bash" &gt;&gt; $HOME/.bashrc
</code></pre>
<h3 id="hstr"><a class="header" href="#hstr">hstr</a></h3>
<p><code>sudo apt install hstr</code> установить hstr (https://github.com/dvorka/hstr) <br />
<code>hstr -f</code> избранное (Ctrl+F добавить в избранное) <br />
<code>hstr -n bash log</code> вывести на экран отфильтрованную историю</p>
<pre><code class="language-bash">if command -v hstr &gt; /dev/null; then
    bind -x '"\C-r": hstr'
fi
</code></pre>
<h3 id="mcfly"><a class="header" href="#mcfly">mcfly</a></h3>
<p>Установить <a href="https://brew.sh">homebrew</a> и <a href="https://github.com/cantino/mcfly">mcfly</a>, который заменяет поиск истории через <code>Ctrl-R</code> на интеллектуальную поисковую систему, которая учитывает рабочий каталог и контекст недавно выполненных команд:</p>
<pre><code class="language-bash">/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
echo 'eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"' &gt;&gt; ~/.bashrc
eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
source ~/.bashrc
brew install mcfly
echo 'eval "$(mcfly init bash)"' &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<h2 id="compgen"><a class="header" href="#compgen">compgen</a></h2>
<p><code>compgen -c</code> выводит все команды, доступные в текущей оболочке <br />
<code>compgen -a</code> выводит все алиасы, определенные в текущей оболочке <br />
<code>compgen -b</code> выводит все встроенные команды Bash <br />
<code>compgen -k</code> выводит все зарезервированные слова Bash <br />
<code>compgen -v</code> выводит все переменные, определенные в текущей оболочке <br />
<code>compgen -A export</code> выводит все экспортированные переменные <br />
<code>compgen -A function</code> выводит все функции, определенные в текущей оболочке <br />
<code>compgen -A arrayvar</code> выводит все массивы, определенные в текущей оболочке (echo ${BASH_ALIASES[@]}) <br />
<code>compgen -A hostname</code> выводит все известные хосты <br />
<code>compgen -A job</code> выводит все активные задания (ping ya.ru &gt; /dev/null &amp;) <br />
<code>compgen -A service</code> выводит все службы (для систем, поддерживающих службы, например, через systemd) <br />
<code>compgen -d</code> выводит все директории в текущем каталоге <br />
<code>compgen -f</code> выводит все файлы и директории в текущем каталоге <br />
<code>compgen -u</code> выводит всех пользователей системы <br />
<code>compgen -g</code> выводит все группы системы <br />
<code>compgen -W "start stop status restart" st</code> выводит список слов из wordlist, которые начинаются с prefix "st"</p>
<h2 id="cron"><a class="header" href="#cron">cron</a></h2>
<p><code>ls /etc/cron.d/</code> директория хранения задач различных пакетов (atop, sysstat) <br />
<code>ls -l /etc/cron.hourly &amp;&amp; ls -l /etc/cron.daily &amp;&amp; ls -l /etc/cron.weekly &amp;&amp; ls -l /etc/cron.monthly</code> директории для скриптов, которые надо выполнять раз в час, день, неделю и месяц <br />
<code>crontab -l</code> просмотр задач <br />
<code>crontab -l | grep -Pv "^$|^#"</code> отобразить только активные задания <br />
<code>crontab -u lifailon -l</code> отобразить задачи пользователя root <br />
<code>crontab -e</code> создать задачу от текущего пользователя <br />
<code>sudo crontab -u root -e</code> создать задачу от пользователя root <br />
<code>crontab -r</code> очистить все задачи</p>
<p><code>cat /etc/crontab</code></p>
<pre><code>#### # .---------------- минута (0 - 59)
#### # |  .------------- час (0 - 23)
#### # |  |  .---------- мень месяца (1 - 31)
#### # |  |  |  .------- месяц (1 - 12) или jan,feb,mar,apr...
#### # |  |  |  |  .---- день недели (0 - 6) (Воскресень 0 или 7) или sun,mon,tue,wed,thu,fri,sat
#### # |  |  |  |  |
#### # *  *  *  *  * user-name command to be executed
####  17  *  *  *  *   root    cd / &amp;&amp; run-parts --report /etc/cron.hourly
####  25  6  *  *  *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )
####  47  6  *  *  7   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )
####  52  6  1  *  *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )
</code></pre>
<p><code>0,14,29,44 * * * *</code> каждые 15 минут <br />
<code>*/15 * * * *</code> каждые 15 минут</p>
<p><code>00 23 * * * systemctl restart zabbix-agent &amp;&amp; echo $(date): Reboot Zabbix Agent use cron &gt;&gt; /var/log/reboot.log</code> выполнять перезапуск службы каждый день в 23:00 и писать в лог <br />
<code>00 03 * * 6 echo $(date): Reboot Operating System use cron &gt;&gt; /var/log/reboot.log &amp;&amp; /sbin/reboot</code> выполнять перезагрузку системы один раз в субботу в 3 часа ночи <br />
<code>@reboot date &gt;&gt; ~/date-reboot.log</code> выполнять один раз после перезагрузки</p>
<p><code>journalctl -eu cron</code> <br />
<code>cat /var/log/syslog | grep -i cron</code></p>
<pre><code class="language-bash">#!/bin/bash
addr="google.com"
path="/var/log/icmp-test.log"
date=$(date | awk '{print $3,$2,$4}')
loss=$(ping -c 2 $addr | grep -Ewo "[0-9]+%")
if [ $loss = "100%" ]; then
    echo "$date: $addr - unavailable" &gt;&gt; $path
else
    echo "$date: $addr - available" &gt;&gt; $path
fi
</code></pre>
<p><code>echo "*/1 * * * * bash /root/google-icmp-test.sh" &gt;&gt; /var/spool/cron/crontabs/root</code> добавить задачу в планироващик на выполнение скрипта каждую минуту</p>
<p><code>cp /etc/hosts /etc/hosts.bak</code> backup файла <br />
<code>echo "11.11.11.11 google.com" &gt;&gt; /etc/hosts</code> изменить адрес для недоступности хоста <br />
<code>cp /etc/hosts.bak /etc/hosts</code> восстановить файл <br />
<code>cat /var/log/icmp-test.log | grep unavailable</code> отфильтровать лог по unavailable</p>
<h2 id="systemctl"><a class="header" href="#systemctl">systemctl</a></h2>
<p><code>systemctl reload ssh</code> обновить конфигурацию сервиса из файла юнита (если у юнита есть эта функция) <br />
<code>systemctl status ssh</code> отображает состояние системы, юнитов (в том числе Failed) и запущенные процессы пользователей <br />
<code>systemctl status sshd | grep -P "Active.+;" | sed -r "s/.+; | ago//g"</code> время работы службы <br />
<code>systemctl start ssh</code> запустить юнит (до перезагрузки) <br />
<code>systemctl stop ssh</code> остановить юнит (до перезагрузки) <br />
<code>systemctl restart ssh</code> перезапустить сервис <br />
<code>systemctl enable ssh</code> добавить в автозагрузку <br />
<code>systemctl disable ssh</code> удалить из автозагрузки <br />
<code>systemctl mask ssh</code> выключить юнит, который нельзя будет запустить вручную или как зависимость (создает симлинк на /dev/null) <br />
<code>systemctl unmask ssh</code> включить юнит (удалить симлинк) <br />
<code>systemctl daemon-reload</code> перезапустить юнит systemd <br />
<code>systemctl cat ssh</code> отобразить путь и содержимое unit-файла <br />
<code>systemctl edit --full ssh</code> открыть для редактирования файл юнита <br />
<code>systemctl list-dependencies ssh</code> дерево зависимостей <br />
<code>systemctl list-dependencies ssh --reverse</code> зависящие сервисы от указанного юнита <br />
<code>systemctl list-units --type service --all</code> отображение статуса всех сервисов <br />
<code>systemctl list-unit-files | sed "1d;$ d" | sed "$ d" | wc</code> отобразить кол-во всех файлов конфигурации сервисов на диске <br />
<code>systemctl list-unit-files | grep zabbix</code> отфильтровать по имени <br />
<code>systemctl list-unit-files --type=service</code> список всех сервисов <br />
<code>systemctl list-unit-files --type=service --state=enabled</code> список сервисов, добавленных в автозагрузку <br />
<code>systemctl list-units --all --type=service --plain --no-legend --no-pager --output=json</code> <br />
<code>--all</code> выводить все типы юнитов, включая активные, неактивные и остановленные <br />
<code>--type=service</code> выводить только системные службы управляемые systemd (не ключает в вывод другие типы юнитов, такие как socket или device) <br />
<code>--plain</code> вывод в текстовом формате без форматирования <br />
<code>--no-legend</code> отключает вывод заголовков для столбцов <br />
<code>--no-pager</code> отключает использование постраничного вывода (less) <br />
<code>ls /usr/lib/systemd/system</code> юниты поставляемые вместе с системой и устанавливаемыми приложениями <br />
<code>ls /run/systemd/system</code> юниты созданные динамически в runtime <br />
<code>ls /etc/systemd/system</code> юниты системного администратора</p>
<h3 id="systemctl-tui"><a class="header" href="#systemctl-tui">systemctl-tui</a></h3>
<p><code>cargo install systemctl-tui --locked</code> быстрый и простой TUI-интерфейс для взаимодействия с службами и журналами systemd на Rust (https://github.com/rgwood/systemctl-tui), от создателя NuShell <br />
<code>systemctl-tui</code></p>
<h3 id="unit"><a class="header" href="#unit">unit</a></h3>
<pre><code class="language-bash">#!/bin/bash
while true; do
    addr="google.com"
    path="/var/log/icmp-test.log"
    date=$(date | awk '{print $3,$2,$4}')
    loss=$(ping -c 2 $addr | grep -Ewo "[0-9]+%")
    if [ $loss = "100%" ]; then
        echo "$date: $addr - unavailable" &gt;&gt; $path
    else
        echo "$date: $addr - available" &gt;&gt; $path
        tail -n 1 $path
    fi
    sleep 5
done
</code></pre>
<p><code>nano /etc/systemd/system/icmp-test-log.service</code></p>
<pre><code class="language-conf">[Unit]
Description=icmp test output to log
After=network.target

[Service]
ExecStart=/bin/bash "/root/google-icmp-test.sh"
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
Type=simple

[Install]
WantedBy=multi-user.target
</code></pre>
<p><code>systemctl daemon-reload</code> <br />
<code>systemctl enable icmp-test-log.service</code> <br />
<code>systemctl start icmp-test-log</code> <br />
<code>systemctl status icmp-test-log</code> <br />
<code>tail -f /var/log/icmp-test.log</code></p>
<h2 id="journalctl"><a class="header" href="#journalctl">journalctl</a></h2>
<p><code>journalctl --system</code> отобразить системный журнал <br />
<code>journalctl --user</code> отобразить пользовательский журнал текущего пользователя <br />
<code>journalctl -m</code> отобразить записи из всех доступных журналов (--merge) <br />
<code>journalctl -ek</code> отобразить только сообщения ядра (kernel, --dmesg) из текущей загрузки <br />
<code>journalctl -t systemd</code> показать записи с указанным идентификатором системного журнала <br />
<code>journalctl _PID=3972315</code> отобразить сообщения по PID процесса <br />
<code>journalctl -eu ssh</code> отобразить сообщения с конца (--pager-end) для выбранного сервиса (--unit)</p>
<p><code>g</code> перейти в начало листинга <br />
<code>G</code> перейти в конец</p>
<p><code>journalctl -fu ssh</code> выводить новые сообщения в реальном времени (-f/--follow) <br />
<code>journalctl -fu ssh</code> выводить новые сообщения в реальном времени (-f/--follow) <br />
<code>journalctl -ru ssh</code> вывести сообщения с конца (сверху новые записи, --reverse) <br />
<code>journalctl -n 100 -u ssh --no-pager</code> вывести 100 строк (--lines) из журнала и не передавать вывод на автоматический скроллинг <br />
<code>journalctl -p 3</code> вывести записи с указанным приоритетом, например, только ошибки и выше по важности: неработоспособность(0), alerts(1), critical(2), errors(3), warning(4), notice(5), info(6), debug(7) <br />
<code>journalctl -S "2023-09-01 12:00:00" -U "2023-09-01 15:00:00"</code> отобразить сообщения от (--since) 1 сентября c 12:00:00 по (--until) 15:00:00 <br />
<code>journalctl --since today</code> отобразить сообщения за сегодня <br />
<code>journalctl -b</code> отобразить сообщения с момента последней загрузки системы (boot) <br />
<code>journalctl --list-boots</code> показать список сохраненных загрузок системы <br />
<code>journalctl -b ba6b2292a0e84d83a81cedfaa221926f</code> показать сообщения с момента конкретной загрузки системы (--boot) <br />
<code>journalctl --quiet</code> не показывать информационные сообщения и предупреждения о привилегиях <br />
<code>journalctl --no-hostname</code> подавить вывод поля имени хоста <br />
<code>journalctl -n 1 --no-pager --output=json-pretty</code> вывод в формате JSON (json-sse, json-seq) <br />
<code>journalctl -n 1 --no-pager --output=json-pretty --output-fields=PRIORITY,MESSAGE</code> отфильтровать вывод</p>
<p><code>journalctl --fields</code> вывести список всех используемых полей (UNIT, USER_UNIT, _SYSTEMD_UNIT, _SYSTEMD_USER_UNIT и т.д.)</p>
<p><code>journalctl --field=UNIT &gt; system_units.log</code> вывести список всех юнитов в системе <br />
<code>journalctl --field=USER_UNIT &gt; user_units.log</code> вывести список всех пользовательских юнитов в системе <br />
<code>comm -12 &lt;(sort system_units.log) &lt;(sort user_units.log)</code> построчное сравнение двух отсортированных файлов со списком журналов без вывода общих строк в 1 и 2 файлах (-12)</p>
<p><code>journalctl --disk-usage</code> вывести общее использование диска всеми файлами журнала (Archived and active journals take up 2.3G in the file system) <br />
<code>journalctl --flush</code> очистить все данные журнала из директорий /run в /var <br />
<code>journalctl --vacuum-time=1month</code> удалить файлы журнала, старше указанного времени (1-го месяца) <br />
<code>journalctl --vacuum-size=100M</code> очистить логи, чтобы размер хранилища соответствовал указанному размеру <br />
<code>journalctl --vacuum-files=100</code> оставить только указанное количество файлов журнала <br />
<code>journalctl --rotate</code> запустить немедленную ротацию файлов журнала <br />
<code>journalctl --sync</code> синхронизировать незаписанные сообщения журнала на диск <br />
<code>journalctl --relinquish-var</code> прекратить запись на диск, войти во временную файловую систему <br />
<code>journalctl --verify</code> проверить целостность файла журнала</p>
<p><code>journalctl --header</code> вывести список журналов <br />
<strong>File path</strong> - путь к файлу журнала на диске <br />
<strong>Incompatible flags</strong> - несовместимые флаги с этим журналом <br />
<strong>Rotate suggested</strong> - применяется ли ротация к журналу <br />
<strong>Tail sequential number</strong> - последовательный номер для конца журнала (указывает на последнее событие в журнале) <br />
<strong>Head realtime timestamp</strong> - время первого события в журнале <br />
<strong>Tail realtime timestamp</strong> - время последнего события в журнале <br />
<strong>Objects</strong> - количество объектов, находящихся в журнале (таких как записи, и не только) <br />
<strong>Entry objects</strong> - количество объектов, представляющих записи в журнале <br />
<strong>Data objects</strong> - количество объектов данных, хранящихся в журнале <br />
<strong>Field objects</strong> - Количество объектов полей (список полей можно получить через --fields) <br />
<strong>Disk usage</strong> - используемое пространство на диске для этого журнала</p>
<p><code>nano /etc/systemd/journald.conf</code></p>
<pre><code class="language-conf">Storage=auto # журналы сохраняются в /var/log/journal на диске (если доступно достаточно места), или в памяти (/run/log/journal) при недостатке места на диске
Storage=persistent # журналы всегда сохраняются на диске
Storage=volatile # журналы хранятся только в памяти (не сохраняются на диск)
Storage=none # журналы не сохраняются
Seal=yes # включает подписание журналов для обеспечения их целостности. Это добавляет цифровую подпись в журналы, чтобы защитить их от изменений
SyncIntervalSec=5m # интервал между синхронизациями журнала с диском (5 минут)
RateLimitIntervalSec=30s # временной интервал, в течение которого будет ограничено количество записей журнала, если они приходят слишком часто
RateLimitBurst=10000 # максимальное количество записей, которое можно сделать в журнал за интервал RateLimitIntervalSec
SystemMaxUse=500M # ограничивает максимальное количество дискового пространства, которое могут занимать системные журналы, если пространство превышает этот лимит, старые журналы будут удаляться
SystemKeepFree=1G # минимальное количество свободного места на диске, которое должно оставаться для других системных задач, если места на диске становится меньше, система начнет удалять старые журналы
SystemMaxFileSize= # ограничивает размер одного файла журнала на диске. Если файл превышает этот размер, он будет разделен
SystemMaxFiles=100 # максимальное количество файлов журнала, которые могут быть созданы, старые файлы будут удаляться, чтобы освободить место для новых
MaxRetentionSec=1month # максимальный срок хранения журналов (например, журналы будут храниться не более месяца)
ForwardToSyslog=yes # должны ли записи журнала перенаправляться в системный журнал (syslog), это позволяет перенаправлять журнал в другие системы, например, rsyslog
orwardToKMsg=no # должны ли записи журнала перенаправляться в буфер ядра (KMsg)
ForwardToConsole=no # должны ли записи журнала отображаться на консоли работающего в системе через TTY (не в терминал других пользователей)
ForwardToWall=yes # должны ли записи журнала отображаться всем пользователям, работающим в системе (уведомления будут выводиться всем пользователям через команду wall)
MaxLevelStore=debug # максимальный уровень журналируемых записей, которые будут сохраняться (emerg, alert, crit, error, warning, notice, info, debug)
MaxLevelSyslog=debug # максимальный уровень журналируемых записей, которые будут отправляться в syslog
MaxLevelWall=emerg # максимальный уровень журналируемых записей, которые будут выводиться всем пользователям через команду wall
LineMax=48K # максимальный размер строки, которая может быть записана в журнал (по умолчанию 48 КБ)
Audit=no # журналировать события аудита (связанных с безопасностью, например, вход в систему, попытки доступа к файлам и изменения файловых прав, Запуск и завершение процессов и т.п.)
</code></pre>
<p><code>sudo systemctl restart systemd-journald</code></p>
<h2 id="dmesg"><a class="header" href="#dmesg">dmesg</a></h2>
<p><code>dmesg -Tx</code> прочитать логи буфера сообщений ядра (/var/log/dmesg), используется для записи во время загрузки системы пока сервис Syslog ещё не запущен <br />
<code>dmesg -Tx -l crit,err</code> отфильтровать вывод <br />
<code>dmesg -E</code> включить логирвоание ядра в консоль (--console-on) <br />
<code>dmesg -D</code> отключить (--console-off)  <br />
<code>dmesg -n 1</code> изменить уровень логирования для печати в консоль <br />
<code>dmesg -u</code> отображать вывод из программ окружения пользователя <br />
<code>dmesg -w</code> выводить журнал в реальном времени (ждать новых сообщений)</p>
<h2 id="hardware"><a class="header" href="#hardware">hardware</a></h2>
<p><code>systemd-analyze</code> отображает статистику времени загрузки ОС (Kernel - время загрузки ядра) и userspace <br />
<code>systemd-analyze blame</code> отобразить все процессы и отсортировать по времени загрузки <br />
<code>systemd-analyze blame | grep zabbix</code> <br />
<code>systemd-analyze plot &gt; graph.svg</code> создать векторный отчет в формате Scalable Vector Graphics описанный XML</p>
<p><code>history</code> история команд <br />
<code>history -c</code> очистить историю</p>
<p><code>who -b</code> время последнего включения <br />
<code>last</code> история авторизации <br />
<code>last -n 5 reboot</code> история перезагрузки <br />
<code>last shutdown</code> история выключений</p>
<p><code>arch</code> архитектура системы <br />
<code>lsb_release -a</code> версия дистрибутива <br />
<code>uname -srv</code> версия ядра <br />
<code>cat /proc/version</code> версия ядра и дистрибутива <br />
<code>cat /etc/os-release</code> описание дистрибутива и версия ОС <br />
<code>hostnamectl</code> подробная информация (Operating System, Kernel, Architecture, Hardware Vendor/Model)</p>
<p><code>uptime</code> время работы системы, кол-во залогиненных пользователей, Load average - средняя загрузка системы за последние 1, 5 и 15 минут (2.00 - это 100% на два ядра) <br />
<code>dmidecode -t bios</code> информация о системе (system/baseboard/processor/memory) <br />
<code>dmidecode -s bios-vendor</code> информация о системе (bios-version/bios-release-date/baseboard-manufacturer/system-manufacturer/processor-version) <br />
<code>dmidecode -t baseboard</code> версия материнской платы, Video и Sound и их статус</p>
<p><code>nproc</code> кол-во ядер <br />
<code>lscpu</code> информация о процессоре <br />
<code>cat /proc/cpuinfo</code> информация о процессоре <br />
<code>cat /proc/cpuinfo | grep "core id" | wc -l</code> количество уникальных ядер (без учета потоков) <br />
<code>cat /proc/partitions</code> перечисляет все устройства хранения и разделы на этих устройствах хранения <br />
<code>cat /proc/asound/cards</code> Audio PCI <br />
<code>cat /proc/cmdline</code> содержит имя файла образа ядра и его параметры запуска, которые были указаны в приглашении загрузчика GRUB (позволяет идентифицировать параметры загрузки, которые были введены вручную) <br />
<code>cat /etc/default/grub</code> содержит конфигурацию, которую использует команда update-grub для создания файла /boot/grub/grub.cfg <br />
<code>cat /boot/grub/grub.cfg</code> команда update-grub генерирует этот файл автоматически в соответствии с настройками, заданными в файле /etc/default/grub <br />
<code>cat /proc/loadavg</code> среднее количество процессов или потоков, которые выполняются, находятся в очереди на выполнение или ждут завершения операций ввода/вывода за последние 1, 5 и 15 минут. 4-е значение, это количество процессов выполняемых в данный момент/общее количество процессов в системе. Последнее значение, это PID последнего созданного процесса.</p>
<p><code>lspci</code> информация о устройствах, подключенные к материнской плате компьютера по шине PCIe <br />
<code>lspci | grep -i vga</code> узнать какая используется видеокарта (VGA controller) <br />
<code>lspci | grep -i audio</code> Audio controller <br />
<code>lspci | grep -i ethernet</code> Ethernet controller <br />
<code>lspci | grep -i scsi</code> SCSI storage controller <br />
<code>lspci | grep -i sata</code> SATA storage controller <br />
<code>lspci | grep "USB controller"</code> <br />
<code>lspci | grep 02:00.0</code> фильтровать информацию по слоту устройства <br />
<code>lspci -vv | grep -iE "driver"</code> отобразить список загруженных драйверов ядра для устройств <br />
<code>lsusb -vt</code> информация о USB устойствах (принтеры, Bluetooth адаптер, мышка, клавиатура)</p>
<p><code>lshw -short</code> информацию по каждому устройству <br />
<code>lshw -class bus</code> Motherboard/USB <br />
<code>lshw -class display</code> VGA controller <br />
<code>lshw -class network</code> <br />
<code>lshw -class disk</code> информация о жестком диске (product, vendor, size, capabilities: 7200rpm) <br />
<code>lshw | grep product</code></p>
<p><code>ls /sys/class/net</code> список сетевых интерфейсов <br />
<code>cat /proc/net/dev</code> список сетевых интерфейсов и их статистика (bytes, packets, errs, drop) для Receive (Прием) и Transmit (Передача) <br />
<code>ethtool -S ens33</code> статистика сетевого интерфейса (для сброса статистики нужно ip down и выгрузить модуль ядра с драйверов modprobe -r module и вернуть обратно) <br />
<code>ethtool ens33 | grep -Ei "wake-on|speed"</code> поддержка Wake-on-Lan и скорость сетевого интерфейса <br />
<code>ethtool -i ens33</code> драйвер сетевой карты <br />
<code>ethtool ens33 -p 100</code> включить светодиод на сетевой карте на 100 секунд</p>
<p><code>cat /sys/block/sda/stat</code> статистика диска sda <br />
<code>lsmod</code> список всех загруженных модулей ядра вместе с зависимостями <br />
<code>/proc/modules</code> содержится список всех загруженных модулей ядра <br />
<code>modinfo ip_tables</code> информация о конкретном модуле <br />
<code>ls /etc/*modprobe*</code> содержит конфигурационные файлы со списками модулей ядра <br />
<code>cat /etc/modprobe.d/mdadm.conf \  </code>/etc/modules-load.d/` директория, которая содержит файлы со списками модулей, которые должны быть загружены при запуске системы</p>
<p><code>ls -l /var/lib/apt/periodic/update-success-stamp</code> дата последнего выполнения apt update <br />
<code>ls -l /var/cache/apt/pkgcache.bin</code> местоположение кэша пакетов apt <br />
<code>HISTTIMEFORMAT="%d/%m/%y %T " history | grep "apt update"</code> история команды обновления с точкой времени</p>
<p><code>cat /etc/hostname</code> имя хоста <br />
<code>cat /etc/services | grep -iE "ntp|zabbix"</code> список всех сервисов и сопоставленных им портов в системе <br />
<code>cat /etc/mime.types | grep -Ew "json|csv"</code> список сопосталвения файлов и их программ для открытия в системе</p>
<p><code>cat /etc/hosts</code> локальная таблица преобразовани ip в имя <br />
<code>cat /etc/hosts.allow &amp;&amp; cat /etc/hosts.deny</code> ограничить доступ к внешним сервисам <br />
<code>cat /etc/hosts.{allow,deny} | grep -Pv "^$|^#"</code> <br />
<code>echo "in.telnetd: 192.168.3., .domain.ru" &gt;&gt; /etc/hosts.allow</code> разрешить соединение только для указанной подсети и домена</p>
<p><code>ls -l /dev | grep sd</code> вывести список всех дисков и разделов в файловой системе <br />
<code>ls -l /dev | grep -wo sd.</code> вывести только список дисков <br />
<code>cat /proc/diskstats</code> статистика дисков <br />
<code>cat /proc/stat</code> cpu user/nice/system/idle/iowait/irq/softirq/steal_time, ctxt - общее количество переключений контекста на всех процессорах, btime - время загрузки системы в секундах с начала эпохи unix, processes -  указывается количество созданных процессов и потоков, включая (но не ограничиваясь ими) те, которые созданы вызовами системных вызовов fork() и clone(), procs_blocked - количество процессов, заблокированных в данный момент и ожидающих завершения ввода-вывода <br />
<code>stat -f /dev/sda</code> <br />
<code>cat /proc/buddyinfo</code> информация о фрагментации памяти в ядре Linux, спользуется для диагностики проблем с фрагментацией памяти <br />
<code>cat /proc/cgroups</code> система контейнеризации и управления ресурсами доступными для процессов cgroups, позволяет ограничить доступ к любым ресурсам для процесса, а также контролировать его поведение в системе</p>
<h2 id="sysctl"><a class="header" href="#sysctl">sysctl</a></h2>
<p><code>sysctl -a</code> отобразить все параметры/настройки ядра Linux (Kernel), где представленны все параметры в виде переменных, имена переменных соответствуют пути файла в директории /proc/sys (вместо слеша в переменной используется точка) <br />
<code>sysctl net.ipv6.conf.all</code> <br />
<code>sysctl net.ipv6.conf.all.disable_ipv6=1</code> отключить протокол IPv6 (&gt; /proc/sys/net/ipv6/conf/ens33/disable_ipv6) <br />
<code>sysctl net.ipv6.conf.ens33.disable_ipv6=1</code> для интерфейса ens33 <br />
<code>sysctl --system</code> обновление информации из файлов/вернуть значения переменных до состояния сохраненного в файлах (удалить временные изменения из sysctl) <br />
<code>sysctl -w net.ipv6.conf.ens33.disable_ipv6=1</code> сохранить настройку после перезагрузки (-w записать в файл) <br />
<code>sysctl fs.file-nr</code> кол-во открытых файловых дескрипторов в текущий момент, открытые файлы которые сейчас не используются, максимальное количество для открытия <br />
<code>sysctl -a | grep fs.file-max</code> максимальное количество открытых файлов (дескрипторов), которые могут быть открыты в файловой системе всеми процессами на уровне ядра ОС <br />
<code>nano /proc/sys/fs/file-max</code> изменить значение кол-ва дескрипторов <br />
<code>echo "fs.file-max=500000" &gt;&gt; /etc/sysctl.conf</code> добавить в конфигурацию sysctl.conf <br />
<code>sysctl -p</code> применить настройки <br />
<code>sysctl fs.nr_open</code> лимит открытия файлов для каждого процесса отдельно <br />
<code>ls /proc/1/fd/ | wc -l</code> узнать кол-во открытых дескрипторов у процессора с PID 1 <br />
<code>sysctl fs.aio-nr</code> количество асинхронных операций ввода и вывода файловой системе в масштабе всей системы (Asynchronous IO number requests) <br />
<code>sysctl fs.aio-max-nr</code> максимальное количество асинхронных операций ввода-вывода, рекомендуемое минимальное значение для fs.aio-max-nr — 1048576, но в загруженной среде ASE со многими ядрами может потребоваться настроить большее число <br />
<code>sysctl fs.inotify.max_queued_events</code> подсистема ядра inotify позволяет следить за изменениями в файловой системе, устанавливает максимальное количество событий, которые могут находиться в очереди, перед тем как их обработает программа <br />
<code>sysctl fs.inotify.max_user_watches</code> максимальное количество файлов и директорий, за которыми может наблюдать один объект inotify <br />
<code>sysctl fs.inotify.max_user_instances</code> максимальное количество объектов inotify, которые может создать один пользователь <br />
<code>sysctl fs.mqueue.queues_max</code> максимальное количества очередей сообщений POSIX, разрешенных в системе, которые позволяют процессам (и их потокам) обмениваться данными в виде сообщений (создаются и открываются с помощью функции mq_open) <br />
<code>sysctl fs.mqueue.msg_max</code> максимального количества сообщений в значении очереди <br />
<code>sysctl fs.mqueue.msgsize_max</code> максимальный размера сообщения <br />
<code>sysctl vm.min_free_kbytes</code> минимальный размер свободной оперативной памяти который необходимо поддерживать <br />
<code>sysctl vm.swappiness</code> процент свободной памяти, по достижении которого данные начинают переноситься на SWAP раздел <br />
<code>sysctl -w vm.swappiness=80</code> при 80% свободной памяти (свыше 20% занятой оперативной памяти) начнет использоваться SWAP, в котоый помещяются неиспользуемые процессами страницы памяти на текущий момент, если приложению потребуются эти страницы, процесс их перенесения из раздела подкачки обратно в оперативную память (данные нужно обратно считать с диска в память) <br />
<code>sysctl -w vm.swappiness=10</code> файл подкачки (выгрузка в виртуальную память) активируется только в том случае, если свободно 10% оперативной памяти <br />
<code>sysctl vm.vfs_cache_pressure</code> скорость удаления dentry и inode из кэша (100 по умолчанию) <br />
<code>sysctl vm.dirty_background_ratio</code> процент от общей оперативной памяти который может быть заполнен страничным кэшем, по достижении которой демон pdflush (dirty page flush) начинает сбрасывать данные из кэша оперативной памяти на диск. Когда объем свободной памяти становится меньше этого порога, ядро вызывает функцию wakeup_bdflush() для перевода в состояние выполнения потока pdflush, который выполняет функцию обратной записи измененных страниц памяти background_writeout() на диск, эта функция получает один параметр количества страниц, которые функция должна попытаться записать на диск. <br />
<code>sysctl -w vm.dirty_background_ratio=5</code> <br />
<code>sysctl vm.dirty_ratio</code> вернхний предел объема оперативной памяти в процентах от free Available который может быть выделен под PageCache до их записи на диск, на этом уровне все новые операции ввода-вывода приостанавливаются до тех пор, пока на диск не будут записаны грязные (Dirty) страницы, значение должно быть выше чем dirty_background_ratio <br />
<code>sysctl vm.dirty_expire_centisecs</code> время хранения грязных (Dirty) страниц в кэше в сотых долях секунд (3000 = 30 секунд) для их записи на диск с целью. Функция wb_kupdate() демона pdflush выполняет обратную запись данных на диск, которые были изменены более чем dirty_expire_centisecs для синхронизации страничного кэша с данными на диске, т.к. при сбое, т.к. содержимое памяти после перегрузки не сохраняется. <br />
<code>sysctl vm.dirty_writeback_centisecs</code> интервал процесса проверки данных, которые подлежат записи на диск (500 - 5 секунд) <br />
<code>sysctl abi.vsyscall32</code> разрешает выполнение 32 битных программ в 64 битной системе (по умолчанию 1 - разрешает) <br />
<code>sysctl kernel.hostname</code> изменить имя компьютера без перезагрузки <br />
<code>sysctl kernel.printk</code> уровень логирования <br />
<code>sysctl -w kernel.printk="2 4 1 7"</code> <br />
<code>sysctl net.ipv4.ip_default_ttl</code> значение по-умолчанию для величины Time To Live исходящих пакетов (продолжительность жизни пакета в Internet - каждый раз, когда пакет попадает на очередной роутер, брандмауэр и т.п. величина TTL пакета уменьшается на 1) <br />
<code>sysctl net.ipv4.ip_no_pmtu_disc</code> запрещает поиск Path Maximum Transfer Unit (максимальный размер пакета для выбранного пути, это не MTU), когда система будет пытаться определить максимальный размер пакета, при котором не потребуется выполнять их фрагментацию, для передачи на заданный хост <br />
<code>sysctl net.ipv4.tcp_mem</code> векторная переменная (минимум, режим нагрузки, максимум), которая cодержит общие настройки потребления памяти для протокола TCP, измеряется в страницах (обычно 4Кб), а не байтах. Пока общий размер памяти для целей протокола TCP ниже минимального количества страниц, операционная система ничего не делает с памятью используемой различными TCP сокетами, в режиме нагрузки TCP начинает быстро освобождать память, и последний максимальный - объем памяти, который может использоваться для нужд TCP и при его достижении, начинаются потери пакетов. <br />
<code>sysctl net.ipv4.tcp_rmem</code> векторная величина размера буфера сокетов TCP для приема. Каждый сокет TCP имеет право использовать минимальную память по факту своего создания (по умолчанию – 4096 байт, 4 Кб) и его не стоит увеличивать, т.к. при высокой нагрузки займут много памяти. Значение по умолчанию применяется взамен параметра rmem_default (который используется другими протоколами), второй параметр - по умолчанию имеет удвоенное значение, 87380 * 2 bytes, или 174760 байт (170 Кб). Максимально возможный размер приемного буфера, это значение не отменяет максимума, заданного в rmem_max <br />
<code>sysctl net.ipv4.tcp_wmem</code> векторная величина размера буфера сокетов TCP для передачи <br />
<code>sysctl net.core.rmem_default</code> значение по умолчанию (имеет ниже приоритет, чем tcp_rmem) <br />
<code>sysctl net.core.wmem_default</code> значение по умолчанию <br />
<code>sysctl net.core.rmem_max</code> максимальный размер буфера на сокете получения данных в байтах (глобальный параметр, имеет выше приоритет, чем tcp_rmem) <br />
<code>sysctl net.core.wmem_max</code> максимальный размер буфера на сокете передачи данных в байтах <br />
<code>sysctl net.core.optmem_max</code> максимальный объём опциональных буферов памяти <br />
<code>sysctl -w net.core.rmem_max=26214400 &amp;&amp; sysctl -w net.core.rmem_default=26214400</code> увеличить до 25 МБайт <br />
<code>sysctl -w net.core.wmem_max=26214400 &amp;&amp; sysctl -w net.core.wmem_default=26214400</code> увеличить до 25 МБайт <br />
<code>sysctl net.ipv4.tcp_no_metrics_save</code> по умолчанию (0) TCP сохраняет различные метрики соединения в кэше маршрута при закрытии соединения, при включении (1) TCP не будет кэшировать метрики при закрытии соединений <br />
<code>sysctl net.ipv4.icmp_echo_ignore_all</code> если включено, ядро будет игнорировать все icmp запросы (рекомендуется для защиты от DOS атак) <br />
<code>sysctl net.ipv4.icmp_echo_ignore_broadcasts</code> игнорировать запросы ICMP ECHO, переданные широковещательными пакетами <br />
<code>sysctl net.ipv4.icmp_ignore_bogus_error_responses</code> игнорировать ошибочные ICMP запросы <br />
<code>sysctl net.ipv4.conf.all.accept_source_route</code> разрешать маршрутизацию от источников, при включении, позволяет отправителю определить путь, по которому пакет должен пройти по сети Internet, чтобы достигнуть пункта назначения. Это удобно для изучения и отладки работы сети, но нарушитель получает возможность подмены адресов компьютеров локальной сети и может попытаться подсунуть поддельные маршруты для того, чтобы перенаправить весть трафик через узел, который он контролирует (атака Man In The Middle). <br />
<code>sysctl net.ipv4.conf.all.accept_redirects</code> запретить(0)/разрешить(1) принимать и отправлять ICMP пакеты перенаправления <br />
<code>sysctl net.ipv4.conf.all.send_redirects</code> <br />
<code>sysctl net.ipv4.conf.all.secure_redirects</code> <br />
<code>sysctl net.ipv4.ip_forward</code> разрешает (1) или запрещает (0) маршрутизацию пакетов через текущий хост <br />
<code>sysctl net.ipv4.conf.default.forwarding</code> включить форвардинг пакетов - разрешить ядру операционной системы осущетсвлять проброс трафика с одного интерфейса на другой <br />
<code>sysctl net.ipv4.ip_local_port_range</code> диапазон локальных портов, доступных для установки исходящих подключений (создания локальных клиентских сокетов) <br />
<code>sysctl net.ipv4.tcp_max_tw_buckets</code> максимальное число сокетов, находящихся в состоянии TIME-WAIT одновременно, для предотвращения простейших разновидностей DoS-атак <br />
<code>sysctl net.ipv4.tcp_tw_recycle</code> разрешает/запрещает быструю утилизацию сокетов, находящихся в состоянии TIME-WAIT <br />
<code>sysctl net.ipv4.tcp_tw_reuse</code> позволять повторное использование TIME-WAIT сокетов в случаях, если протокол считает это безопасным <br />
<code>sysctl net.ipv4.tcp_rfc1337</code> защита от TIME-WAIT атак <br />
<code>sysctl net.ipv4.tcp_max_orphans</code> максимальное число "осиротевших" TCP сокетов, не связанных каким-либо идентификатором пользовательского файла (user file handle), при достижение этого значения, соединения сбрасываются. Этот порог помогает предотвращать простые атаки DoS и увеличение параметра влияет на ОЗУ, каждое orphan-соединение поглощает около 64 Кбайт не сбрасываемой на диск (unswappable) памяти и не может быть сброшена в SWAP. При возникновении проблем, связанных с этим ограничением – в системный журнал будет подобное сообщение: TCP: too many of orphaned sockets, и это может служить поводом пересмотреть значения tcp_fin_timeout или tcp_orphan_retries. <br />
<code>sysctl -w net.ipv4.tcp_max_orphans=65536</code> <br />
<code>sysctl net.ipv4.tcp_orphan_retries</code> число попыток закрыть соединение перед тем как оно будет разорвано принудительно и уничтожается TCP соединение, закрытое на локальной стороне сервера. По умолчанию используется значение 7, соответствующее приблизительно периоду от 50 секунд до 16 минут в зависимости от RTO (Retransmission Timeout). <br />
<code>sysctl net.ipv4.tcp_fin_timeout</code> задает максимальное время пребывания сокета в состоянии FIN-WAIT-2 и используется если другая сторона не закрыла соединение со своей стороны. Каждый сокет занимает в памяти 1.5 Кб, что может привести к значительным утечкам памяти в некоторых случаях. <br />
<code>sysctl net.ipv4.tcp_syncookies</code> помогает защититься от атак SYN flood, срабатывает только при достижении значения net.ipv4.tcp_max_syn_backlog, если количество SYN пакетов забивает всю очередь, включается механизм Syn cookies. SYN cookies вообще не использует очередь SYN, вместо этого ядро отвечает на каждый SYN пакет, как обычно SYN/ACK, но туда будет включено специально сгенерированное число на основе IP адресов и портов источника и получателя, а также времени посылки пакета. Атакующий никогда не получит эти пакеты, а поэтому и не ответит на них. При нормальном соединении, будет послан третий пакет, содержащий число, а сервер проверит был ли это ответ на SYN cookie и, если да, то разрешит соединение даже в том случае, если в очереди SYN нет соответствующей записи. <br />
<code>sysctl net.ipv4.tcp_fastopen</code> помогает уменьшить задержки в сети, позволяя начать передачу данных сразу при отправке клиентом первого TCP SYN (3 - включает для входящих и исходящих) <br />
<code>sysctl net.ipv4.tcp_max_syn_backlog</code> размер очереди (максимальное число) запоминаемых запросов на попытку установки TCP соединений (SYN-пакета в состоянии Waiting Acknowledgment) при отправки клиентом TCP SYN пакета, для которых не было получено сервером подтверждения от клиента (полуоткрытых соединений) <br />
<code>sysctl -w net.ipv4.tcp_max_syn_backlog=4096</code> увеличить, если на сервере возникают перегрузки <br />
<code>sysctl net.core.somaxconn</code> размер очереди (максимальное число) полуоткрытых соединений (открытых сокетов) ожидающих установки соединения. Если в ответ на SYN-пакета (synchronize) клиентом был получен от сервера пакет SYN-ACK (acknowledges), сервер ожидает от клиента отправки ACK пакета, после чего соединение считается установленным. <br />
<code>sysctl net.ipv4.tcp_syn_retries</code> количество попыток передачи SYN-пакета при установлении нового соединения, на каждую попытку отводится примерно 30-40 секунд. Значение по-умолчанию 5 = 180 секундам. <br />
<code>sysctl net.ipv4.tcp_synack_retries</code> количество попыток передачи SYN-ACK-пакета в ответ на SYN-запрос для установки пассивного TCP-соединение, инициированное другим хостом, если уменьшить до одного, будет примерно 9 секунд <br />
<code>sysctl net.core.netdev_max_backlog</code> регулирует размер очереди пакетов между сетевой картой и ядром, если ядро не успевает обрабатывать пакеты (если сетевой интерфейс получает пакеты быстрее, чем ядро может их обработать) и очередь переполняется, то новые пакеты отбрасываются, если увеличить значение, можно справиться с пиковыми нагрузками <br />
<code>sysctl -a | grep net.ipv4.tcp_keepalive</code> после неактивности сокета посылает пакет keepalive на второую сторону, содержащий нулевые данные, после отправки первого пакета через время, указанное в tcp_keepalive_time отправляет повторно пакеты через каждые tcp_keepalive_intvl секунд tcp_keepalive_probes раз, если другая сторона не отвечает, сокет автоматически закрывается <br />
<code>tcp_keepalive=$(sysctl -a | grep net.ipv4.tcp_keepalive | grep -Po "(?&lt;=\=\s)[0-9]+")</code> забрать массив значений <br />
<code>echo $tcp_keepalive | awk '{print $3+($1*$2)}'</code> 7200+(75*7) <br />
<code>sysctl net.ipv4.conf.all.rp_filter</code> 1 - строгий режим проверки и 2 - свободный режим проверки, включает фильтр обратного пути (reverse path filter) или защита от подмены адресов (спуфинга), все что поступает на сервер, проходит проверку на соответствие исходящего адреса с таблицей маршрутизации и такая проверка считается успешной, если принятый пакет предполагает передачу ответа через тот же самый интерфейс. Например, когда входящий трафик идет через один маршрутизатор, а исходящий через другой, могут теряться пакеты, поскольку обратный маршрут в таблице маршрутизации, задан через другой интерфейс. <br />
<code>sysctl -w net.ipv4.conf.ens33.rp_filter=1</code> включает строгую проверку на интерфейсе ens33 <br />
<code>sysctl net.ipv4.conf.all.log_martians</code> включает/отключает логирование пакетов <br />
<code>sysctl net.ipv4.tcp_window_scaling</code> разрешает/запрещает масштабирование TCP-окна, как определено в RFC 1323. При передаче TCP-пакетов по толстым каналам возникают потери пропускной способности из-за того, что они не загружены полностью во время ожидания подтверждения о приеме предыдущего TCP-окна. Основная проблема состоит в том, что окно не может иметь размер больше, чем 216 байт (65 Кб). Разрешая масштабирование TCP-окна можно увеличить его размер и таким образом уменьшить потери пропускной способности. <br />
<code>sysctl net.ipv4.tcp_retries2</code> <br />
<code>sysctl net.ipv4.tcp_abort_on_overflow</code> заставляет ядро отвергать новые соединения, если их поступаемое количество выше, с чем система в состоянии справиться <br />
<code>sysctl net.ipv4.ip_nonlocal_bind</code> позволяет отдельным локальным процессам выступать от имени внешнего (чужого) IP адреса, может потребоваться, когда необходимо прослушивать внешние IP адреса, например, сниффинг чужого траффика <br />
<code>net.ipv4.ipfrag_low_thresh</code> максимальный объем памяти, выделяемый под очередь фрагментированных пакетов в диапазоне от 0 до 2147483647, когда длина очереди достигает этого порога, то обработчик фрагментов будет отвергать все фрагментированные пакеты и после уменьшения очереди они должны быть повторно переданы узлом-отправителем. <br />
<code>sysctl net.ipv4.netfilter.ip_conntrack_max</code> максимальное количество соединений для работы механизма connection tracking (используется в iptables)</p>
<h2 id="limits"><a class="header" href="#limits">limits</a></h2>
<p><code>cat /etc/security/limits.conf | grep -Ev "^$|^#"</code></p>
<pre><code>&lt;user/@group&gt;  &lt;soft/hard&gt;  &lt;core/rss/as/nproc/cpu&gt;  &lt;value&gt;
@zabbix           soft              nofile          65535 # установить soft ограничение на кол-во открытых файлов (nofile) для группы zabbix (можно менять в любую сторону, пока оно не превышает hard)
@zabbix           hard              nofile          65535 # ограничение hard можно менять только в меньшую сторону от имени обычного пользователя
*                 soft              nofile          2048 # ограничение для всех пользователей (-n)
*                 hard              nofile          8192
zabbix            soft              as              100 # максимальное кол-во оперативной памяти в КБ (-m)
zabbix            hard              as              100
*                 soft              msgqueue        unlimited # снятие ограничения очереди сообщений памяти (-q)
*                 hard              msgqueue        unlimited
*                 soft              nproc           unlimited # ограничение на количество процессов для всех пользователей (-u)
*                 hard              nproc           unlimited
user              hard              maxlogins       1 # ограничить количество SSH-соединений/сессий для конкретного пользователя (максимальное количество сеансов SSH под одним и тем же пользователем)
*                 hard              maxsyslogins    1 # ограничить общее количество сеансов/активных соединений SSH (за исключением root)
</code></pre>
<p><code>ulimit -a</code> отобразить список ограничений</p>
<pre><code>core file size              (blocks, -c) 0
data seg size               (kbytes, -d) unlimited
scheduling priority                 (-e) 0
file size                   (blocks, -f) unlimited
pending signals                     (-i) 15052
max locked memory           (kbytes, -l) 496180
max memory size             (kbytes, -m) unlimited
open files                          (-n) 1024
pipe size                (512 bytes, -p) 8
POSIX message queues         (bytes, -q) 819200
real-time priority                  (-r) 0
stack size                  (kbytes, -s) 8192
cpu time                   (seconds, -t) unlimited
max user processes                  (-u) 15052
virtual memory              (kbytes, -v) unlimited
file locks                          (-x) unlimited
</code></pre>
<p><code>ulimit -Sn</code> отобразить значение текущего ограничения Soft (-S) для nofile (-n) <br />
<code>ulimit -Hn</code> ограничение Hard (-H) <br />
<code>ulimit -n 3000</code> изменить ограничение количества открытых файлов для одного процесса (до перезагрузки) <br />
<code>ulimit -Sm 1500000</code> ограничение soft (-S) оперативной памяти (-m) в 1500 Мб для пользователя <br />
<code>ulimit -u 5000</code> ограничение максимального количества запущенных пользовательских процессов (-u) <br />
<code>ulimit -s</code> ограничение места для размера аргументов (stack size) команды/скрипта (bash: /usr/bin/diff: Argument list too long) <br />
<code>ulimit -m</code> максимальный объем оперативной памяти <br />
<code>ulimit -v</code> максимальный объем виртуальной памяти <br />
<code>ulimit -f</code> максимальный размер создаваемых файлов <br />
<code>ulimit -t</code> максимальное количество процессорного времени</p>
<p><code>systemctl edit rsyslog</code> ограничения на уровне Unit для конкретного сервиса</p>
<pre><code>[Service]
LimitNOFILE=1617596
LimitNOFILESoft=1617596
</code></pre>
<p><code>systemctl restart rsyslog</code> <br />
<code>pid=$(ps -A | grep rsyslogd | awk '{print $1}')</code> получить pid процесса <br />
<code>cat /proc/$pid/limits</code> проверить применение ограничений после перезапуска сервиса</p>
<h2 id="quota"><a class="header" href="#quota">quota</a></h2>
<p><code>nano /etc/fstab</code> примонтировать раздел на который необходимо установить квоту с указанными опциями</p>
<pre><code>/dev/sda  /  ext4  defaults,usrquota,grpquota  0 0
</code></pre>
<p><code>mount -o remount,rw /</code> перемонтировать файловую систему в режиме read and write <br />
<code>mount | grep quota</code> <br />
<code>quotacheck -favugm</code> выполнить проверку наличия служебных файлов aquota.user и aquota.group — если их нет, команда их создаст автоматически <br />
<code>quotaon -avug</code> включить квоту <br />
<code>edquota -u lifailon</code> создать квоту для пользователя или для группы (-g) на размер данных и кол-во файлов</p>
<pre><code>Disk quotas for user lifailon (uid 1000):
  Filesystem                            blocks       soft       hard     inodes     soft     hard
  /dev/mapper/ubuntu--vg-ubuntu--lv     397112       400M       500M      3004       0        0
</code></pre>
<p><code>edquota -p lifailon user</code> скопировать квоту на другого пользователя <br />
<code>edquota -t</code> изменить период отсрочки soft квоты до момента, когда она станет hard (по умолчанию 7 дней) <br />
<code>quota lifailon -s</code> отобразить квоты для пользователя <br />
<code>repquota -us /</code> отчет для пользователей и групп (-u/-g), текущий used и soft/hard для Space limits и File limits, +-/-+/++ означает, что один из пределов достигнут максимума</p>
<pre><code>lifailon  --     388M     400M     500M     3004     0     0
</code></pre>
<p><code>su lifailon</code> <br />
<code>dd if=/dev/zero of=/tmp/test.file bs=1024000 count=400</code> создать файл размером 400MB</p>
<pre><code>dd: error writing '/tmp/test.file': Disk quota exceeded
117645312 bytes (118 MB, 112 MiB) copied, 0.158031 s, 744 MB/s
</code></pre>
<p><code>ls -lh /tmp/test.file</code></p>
<pre><code>-rw-rw-r-- 1 lifailon lifailon 113M Sep 26 14:37 /tmp/test.file
</code></pre>
<h2 id="fetch"><a class="header" href="#fetch">fetch</a></h2>
<p>Набор скриптов, для быстрого получения информации о системе без установки:</p>
<p><code>curl -s https://raw.githubusercontent.com/dylanaraps/neofetch/refs/heads/master/neofetch | bash</code> <br />
<code>curl -s https://raw.githubusercontent.com/dylanaraps/pfetch/refs/heads/master/pfetch | bash</code> <br />
<code>curl -s https://raw.githubusercontent.com/KittyKatt/screenFetch/refs/heads/master/screenfetch-dev | bash</code> <br />
<code>curl -s https://raw.githubusercontent.com/ThatOneCalculator/NerdFetch/refs/heads/main/nerdfetch | bash</code> <br />
<code>curl -s https://raw.githubusercontent.com/m0zgen/system-checks/master/system-check.sh | sudo bash</code> <br />
<code>curl -s https://raw.githubusercontent.com/Lifailon/hwstat/refs/heads/rsa/hwstat.sh | bash</code></p>
<pre><code class="language-bash">curl -s -L "https://github.com/fastfetch-cli/fastfetch/releases/download/2.40.1/fastfetch-linux-amd64.deb" -o /tmp/fastfetch.deb
sudo dpkg -i /tmp/fastfetch.deb &amp;&amp; rm /tmp/fastfetch.deb
fastfetch
</code></pre>
<h2 id="networkmanager"><a class="header" href="#networkmanager">networkmanager</a></h2>
<p><code>apt install network-manager</code> <br />
<code>systemctl status NetworkManager</code> <br />
<code>nmcli device status</code> состояние интерфейсов <br />
<code>nmcli general status</code> <br />
<code>nmcli connection show</code> список доступных подключений (ethernet, vpn и WiFi-сетей) <br />
<code>nmcli device wifi list</code> список доступных Wi-Fi-сетей <br />
<code>nmcli connection show "Проводное соединение 2"</code> информация о сети <br />
<code>nmcli connection up "Проводное соединение 2"</code> подключиться <br />
<code>nmcli conn down "Проводное соединение 2"</code> отключиться <br />
<code>nmcli radio wifi</code> состояние Wi-Fi <br />
<code>nmcli connection add con-name "dhcp" type ethernet ifname ens33</code> создать подключение, передать тип устройства ethernet (Проводное соединение) и ifname, название сетевого интерфейса <br />
<code>nmcli conn modify "dhcp" ipv4.dns 8.8.8.8</code> настройки подключения (modify) <br />
<code>nmcli radio wifi on</code> включить или выключить (off) Wi-Fi <br />
<code>nmcli device wifi connect "TP-Link" password 12345678 name "TP-Link Wifi"</code> подключиться к Wi-Fi сети <br />
<code>nmcli networking off</code> отключить сеть через (если управление через Network Manager, указывается в блоке конфигурации renderer для netplan) <br />
<code>nmcli networking on</code> включить сеть <br />
<code>systemctl restart NetworkManager</code></p>
<h2 id="wireless"><a class="header" href="#wireless">wireless</a></h2>
<p><code>apt install wireless-tools</code> <br />
<code>iwconfig</code> <br />
<code>apt install iw</code> <br />
<code>iw list</code> <br />
<code>apt install wavemon</code> <br />
<code>wavemon</code> отобразить качество соединения и мощность передатчика</p>
<h2 id="networking"><a class="header" href="#networking">networking</a></h2>
<p><code>nano /etc/network/interfaces</code></p>
<p><code>auto ens33</code> активировать интерфейс при загрузке <br />
<code>iface ens33 inet static</code> статический <br />
<code>address 192.168.1.50/24</code> <br />
<code>#netmask 255.255.255.0</code> <br />
<code>gateway 192.168.1.254</code> <br />
<code>dns-nameservers 8.8.8.8 1.1.1.1</code></p>
<p><code>auto ens33</code> <br />
<code>iface ens33 inet dhcp</code> динамический</p>
<p><code>service networking restart</code> перезагрузка сети <br />
<code>systemctl restart networking.service</code></p>
<h2 id="netplan"><a class="header" href="#netplan">netplan</a></h2>
<p><code>netplan --debug generate</code> проверка конфигурации на ошибки <br />
<code>netplan apply</code> применить изменения (перезапускает сеть) <br />
<code>netplan get</code> прочитать конфигурацию</p>
<p><code>nano /etc/netplan/*.yaml</code></p>
<ul>
<li>Динамический адрес (использовать два сетевых интерфейса):</li>
</ul>
<pre><code class="language-yaml">network:
  version: 2
  ethernets:
    ens33:
      dhcp4: yes
    ens36:
      dhcp4: yes
</code></pre>
<ul>
<li>Статический адрес:</li>
</ul>
<pre><code class="language-yaml">network:
  version: 2
  renderer: networkd
  ethernets:
    ens33:
      dhcp4: no
      addresses: [192.168.3.105/24]
      routes:
        - to: default
          via: 192.168.3.1
      nameservers:
        addresses: [192.168.3.101, 8.8.8.8, 1.1.1.1]
        search: [domain.local]
</code></pre>
<p>renderer указывает, кому передать управление сетью NetworkManager (nmcli) в средах с графическим интерфейсом или networkd (networkctl)</p>
<p><code>netplan status</code> в релизе netplan 0.106 от февраля 2023 (Ubuntu 23.04) может получить статус используемого renderer</p>
<ul>
<li>MAC и MTU:</li>
</ul>
<pre><code class="language-yaml">network:
  ethernets:
    ens33:
      dhcp4: no
      match:
        macaddress: 54:43:32:21:10:09
        mtu: 1500
</code></pre>
<ul>
<li>Подключение к WiFi:</li>
</ul>
<pre><code class="language-yaml">network:
  version: 2
  wifis:
    wlp33:
      dhcp4: yes
      dhcp6: no
      nameservers:
        addresses: [8.8.8.8]
      access-points:
        "wifi-ssid":
          password: "12345678"
</code></pre>
<ul>
<li>Bonding для объединения физических сетевых интерфейсов в один логический:</li>
</ul>
<pre><code class="language-yaml">network:
  version: 2
  ethernets:
    ens33: {}
    ens36: {}
  bonds:
    bond0:
      dhcp4: no
        interfaces:
          - ens33
          - ens36
          parameters:
            mode: active-backup # используется только один интерфейс, второй активируется в случае неработоспособности первого
            mode: broadcast # задействуются оба интерфейса одновременно, пакеты передают все интерфейсы
            mode: balance-rr # задействуются оба интерфейса по очереди с распределением пакетов
            mode: balance-tlb # задействуются оба интерфейса по очереди, пакеты распределяются в соответствии с текущей нагрузкой
            mode: balance-xor # задействуются оба интерфейса по очереди, распределение пакетов на основе политики хеширования
          addresses:
            - 192.168.1.150/24
          gateway4: 192.168.1.1
          mtu: 1500
          nameservers:
            addresses:
              - 8.8.8.8
</code></pre>
<h2 id="ip"><a class="header" href="#ip">ip</a></h2>
<p><code>ip a</code> ip addr show <br />
<code>ip -s link</code> вывести ститстику всех сетевых интерфейсов <br />
<code>ip -br a show</code> вывести только название интерфейса, статус работы и ip-адрес <br />
<code>ip link set dev ens33 up</code> включить сетевой интерфейс <br />
<code>ip link set dev ens33 down</code> выключить сетевой интерфейс  <br />
<code>ip link set mtu 1550 dev ens33</code> изменить mtu <br />
<code>ip link set dev ens33 address AA:BB:CC:DD:EE:FF</code> изменить mac-адрес (предварительно нужно отключить интерфейс, работает до перезагрузки) <br />
<code>ip addr add 192.168.3.106/24 broadcast 192.168.3.255 dev ens33</code> добавить адрес <br />
<code>ip addr del 192.168.3.106/24 dev ens33</code> удалить адрес <br />
<code>ip route show</code> отобразить таблицу маршрутизации <br />
<code>ip route add 192.168.4.0 via 192.168.3.100</code> добавить маршрут <br />
<code>ip route del 192.168.4.0 via 192.168.3.100</code> удалить маршрут <br />
<code>ip route add 192.168.4.0 dev ens33</code> указать сетевой интерфейс, через который отправлять пакеты в определенную подсеть <br />
<code>ip neigh show</code> отобразить ARP-таблицу <br />
<code>ip neigh add 192.168.3.110 lladdr b0:be:76:43:21:41 dev ens33</code> <br />
<code>ip neigh del dev end33 192.168.3.110</code> <br />
<code>ip neigh flush</code> очистить ARP-таблицу</p>
<h3 id="net-tools"><a class="header" href="#net-tools">net-tools</a></h3>
<p><code>ifconfig ens33</code> up/down <br />
<code>ifdown -a</code> выключить все сетевые интерфейсы (пропадут из списка ifconfig) и включить (ifup -a) <br />
<code>ifconfig ens33 192.168.3.106 netmask 255.255.255.0 broadcast 192.168.3.255</code> <br />
<code>ifconfig -s || netstat -i</code> список сетевых интерфейсов <br />
<code>netstat -atu</code> ALL (-a) tcp (-t) и udp (-u) <br />
<code>netstat -lntup</code> LISTEN (-l) dont resolve names (-n) и сканирует директорию /proc для вывода PID/Program name (-p) <br />
<code>arp -a</code> таблица сопоставления ip и mac адресов <br />
<code>route -e</code> отобразить таблицу маршрутизации <br />
<code>route add -net 192.168.4.0 netmask 255.255.255.0 gw 192.168.3.100</code> добавить маршрут в подсеть 192.168.4.0 через шлюз 192.168.3.100 <br />
<code>route del -net 192.168.4.0 netmask 255.255.255.0</code> удалить маршрут</p>
<h3 id="networkd"><a class="header" href="#networkd">networkd</a></h3>
<p><code>systemctl status systemd-networkd</code> <br />
<code>networkctl list</code> список всех адаптеров, тип и состояния <br />
<code>networkctl status</code> статус службы, Address и Gateway адаптера, DNS-адреса и лог systemd-networkd <br />
<code>networkctl status ens33</code> характеристики адаптера (Network File, Driver, Vendor, Model, MTU, Speed)</p>
<h2 id="ss"><a class="header" href="#ss">ss</a></h2>
<p><code>ss -a</code> All отобразить все сокеты <br />
<code>ss -l</code> показать только прослушиваемые сокеты (LISTEN) <br />
<code>ss -t</code> отобразить только установленные TCP соединения (ESTAB/ESTABLISHED) <br />
<code>ss -ua</code> отобразить все открытые UDP сокеты <br />
<code>ss -da</code> DHCP сокеты <br />
<code>ss -x</code> отобразить только локальные UNIX соединения <br />
<code>ss -r</code> Resolve, определять сетевые имена адресов с помощью DNS <br />
<code>ss -p</code> Processes, показать процессы, использующие сокет <br />
<code>ss -n</code> Numeric не определять имена служб (отображать только номер порта в числовом формате) <br />
<code>ss -ltp | grep 8080</code> <br />
<code>ss -tna | grep 22</code></p>
<h2 id="dns"><a class="header" href="#dns">dns</a></h2>
<h3 id="resolv"><a class="header" href="#resolv">resolv</a></h3>
<p><code>cat /etc/resolv.conf | grep nameserver</code> <br />
<code>nano /etc/resolv.conf</code> работает до перезагрузки <br />
<code>domain domain.local</code> <br />
<code>search domain.local</code> <br />
<code>nameserver 8.8.8.8</code> <br />
<code>nameserver 1.1.1.1</code></p>
<h3 id="resolved"><a class="header" href="#resolved">resolved</a></h3>
<p><code>networkctl status</code> отображает список всех настроенные DNS-серверов в системе через netplan (или другое) для всех адаптеров <br />
<code>resolvectl status</code> в systemd 239 (ubuntu 22.04) systemd-resolve переименован в resolvectl, выводит настроенные сервера для global и список все адресов для конкретного сетевого интерфейса Link (ens33) <br />
<code>resolvectl status | grep "Current DNS"</code> отображает текущие используемые DNS-сервер <br />
<code>systemd-resolve --status</code> служба локального DNS сервера <br />
<code>resolvectl flush-caches &amp;&amp; systemd-resolve --flush-caches</code> очистить локальный кэш DNS <br />
<code>journalctl -u systemd-resolved | grep -E "IN A|IN PTR|IN AAAA|IN PTR|IN MX"</code> логи кэша DNS <br />
<code>systemctl status systemd-resolved</code> статус службы и его лог <br />
<code>cat /run/systemd/resolve/stub-resolv.conf</code> файл-заглушка для демона systemd-resolved, по умолчанию nameserver 127.0.0.53, который перенаправляет обращения к локальному DNS серверу, а он, в свою очередь уже получает информацию от других серверов в интернете</p>
<p><code>nano /etc/systemd/resolved.conf</code> конфигурационный файл, отвечающий за настройку DNS-серверов</p>
<p>Включить кэширование:</p>
<pre><code>[Resolve]
DNS=8.8.8.8, 192.168.3.101
Cache=yes
</code></pre>
<p><code>ln -svi /run/systemd/resolve/resolv.conf /etc/resolv.conf</code> создать симлинк для совместимости с приложениями, которые не используют библиотечные вызовы, а обращаются к DNS серверам напрямую, получая их из <code>/etc/resolv.conf</code> <br />
<code>ls -la /etc/resolv.conf</code></p>
<p><code>nano /etc/resolv.conf</code> не управляется напрямую службой systemd-resolved, а иногда с помощью использования initscripts или NetworkManager, и любые пользовательские изменения могут быть изменены через время или после перезагрузки</p>
<pre><code>nameserver 8.8.8.8
</code></pre>
<p><code>apt install resolvconf</code> сервис для обновления списа адресов в /etc/resolv.conf (что бы он не перезаписывался) <br />
<code>systemctl status resolvconf</code></p>
<p><code>nano /etc/resolvconf/resolv.conf.d/head</code></p>
<pre><code>nameserver 8.8.8.8
nameserver 1.1.1.1
</code></pre>
<h3 id="dig"><a class="header" href="#dig">dig</a></h3>
<p><code>dig</code> <br />
<code>dig google.com</code> <br />
<code>dig @1.1.1.1 google.com a</code> использовать DNS сервер Cloudflare для преобразования имени <br />
<code>dig @9.9.9.9 google.com mx</code> использовать DNS сервер Quad9 для получения MX записи (A, NS, TXT) <br />
<code>dig -x 8.8.8.8 @9.9.9.9</code> разрешить ip в имя</p>
<h3 id="mtr"><a class="header" href="#mtr">mtr</a></h3>
<p><code>mtr google.com</code> объединяет traceroute и ping каждого узла в трассеровке <br />
<code>mtr -I ens33 google.com</code> указать интерфейс для проверки <br />
<code>mtr -b google.com</code> отображать имя и ip <br />
<code>mtr --tcp google.com</code> использовать TCP SYN-пакеты или UDP-дейтаграммы (--udp) <br />
<code>mtr -s 1000 google.com</code> указать размер пакета <br />
<code>mtr -r -c 1 google.com --json</code> указать кол-во ping пакетов (-c 1 и -i 2 изменить интервал) и вывести в виде отчета (--report) в формате json/xml/csv/raw</p>
<h3 id="doggo"><a class="header" href="#doggo">doggo</a></h3>
<p><code>curl -sS https://raw.githubusercontent.com/mr-karan/doggo/main/install.sh | sh</code> DNS cli client (https://github.com/mr-karan/doggo) <br />
<code>doggo yandex.ru</code> запросить домен, используя настройки по умолчанию <br />
<code>doggo yandex.ru MX</code> запросить MX записи домена <br />
<code>doggo yandex.ru MX @8.8.8.8</code> использует указанный сервер для преобразования имен DNS <br />
<code>doggo -q yandex.ru -t MX --nameserver 1.1.1.1</code> <br />
<code>doggo yandex.ru --aa --ad</code> запрос с установленными флагами авторитетного ответа и аутентифицированных данных <br />
<code>doggo yandex.ru --cd --do</code> запрос с отключенной проверкой и установленными флагами <code>DNSSEC OK</code> <br />
<code>doggo yandex.ru --gp-from Germany</code> Запрос с использованием API Globalping из указанной локации</p>
<h2 id="vnstat"><a class="header" href="#vnstat">vnstat</a></h2>
<p><code>apt install vnstat</code> журнал часового, ежедневного и ежемесячного сетевого трафика <br />
<code>systemctl status vnstat</code> проверить службу <br />
<code>vnstat -l</code> мониторинг в реальном режиме <br />
<code>vnstat -h</code> ежедневная почасовая история</p>
<h2 id="netcat"><a class="header" href="#netcat">netcat</a></h2>
<p><code>nc -zv 192.168.3.100 5985</code> проверить порт без попытки соединения (-z) в подробном режиме (-v) <br />
<code>nc -zvn 192.168.3.100 1-1000</code> сканирование tcp-портов, не используя преобразование DNS (-n) <br />
<code>nc -zvn 192.168.3.100 1-1000 2&gt;&amp;1 | grep succeeded</code> перенаправить вывод ошибок в stdout и отфильтровать вывод <br />
<code>nc -zvnu 192.168.3.100 5550-5560</code> сканирование udp-портов (-u) <br />
<code>nc -lp 8081</code> открыть сокет (чат сервер) в режиме прослушивания (-listen) с указанием номера порта (-p) <br />
<code>nc 192.168.3.101 8081</code> подключиться к сокету (чат-клиент) <br />
<code>nc -lp 8081 &gt; out.txt</code> все поступившие данные на сокет записываются в файл (вместо вывода в консоль) <br />
<code>cat /etc/passwd | nc -N 192.168.3.101 8081</code> передать содержимое файла на удаленный сокет принимающей стороны (содержимое /etc/passwd запишется в out.txt) и закрыть удаленный сокет (-N) <br />
<code>nc -l -w 1 -p 8081</code> задать timeout (-w) ожидания, в течении которого сервер слушает запрос, если будет 0, может не успеть считать запрос, на стороне клиента timeout должен быть не ниже <br />
<code>nc -w 5 -Uvl server.sock &gt; out.txt</code> создать UNIX-сокет и передать вывод в файл, сокет закроется через 5 секунд (-w 5) или если будет задан параметр -N на стороне клиента <br />
<code>lsblk | nc -Uv server.sock</code> подключиться к локальному сокету с второго терминала и отправить вывод команды в файл сокета приема <br />
<code>while true; do echo -e "HTTP/1.1 200 OK\n\n$(systemd-analyze plot)" | nc -l -w 1 -p 8085; done</code> HTTP-сервер с выводом анализа загрузки системы</p>
<h3 id="socket-api"><a class="header" href="#socket-api">socket api</a></h3>
<pre><code class="language-bash">port=8085
while true
do
    request=$(nc -l -w 1 -p $port)
    request=$(echo "$request" | head -n 1)
    method=$(echo "$request" | cut -d " " -f 1)
    endpoint=$(echo "$request" | cut -d " " -f 2)
    if [[ $endpoint == "/api/date" ]]
        then
        response="HTTP/1.1 200 OK\nContent-Type: application/text\n\n$(date)"
    elif [[ $endpoint == "/api/disk" ]]
        then
        response="HTTP/1.1 200 OK\nContent-Type: application/json\n\n$(lsblk -e7 --json)"
    else
        response="HTTP/1.1 404 Not Found\n\n404 Not Found\n"
    fi
    echo -e "$response" | nc -l -w 1 -p $port
done
</code></pre>
<p>curl -s http://192.168.3.101:8085/api/date <br />
curl -s http://192.168.3.101:8085/api/disk | jq .blockdevices[]</p>
<h3 id="socket-proxy"><a class="header" href="#socket-proxy">socket proxy</a></h3>
<p><code>ncat -l 8080 -k --sh-exec "ncat 192.168.3.101 80"</code> <br />
<code>socat TCP-LISTEN:8080,fork,reuseaddr TCP:192.168.3.101:80</code></p>
<h2 id="proxy"><a class="header" href="#proxy">proxy</a></h2>
<pre><code class="language-bash">sudo apt-get install -y dotnet-runtime-8.0
arch="x64" # или "arm64"
sudo curl -s -L "https://github.com/Lifailon/froxy/releases/download/0.4.0/froxy-0.4.0-linux-$arch" -o /usr/local/bin/froxy
sudo chmod +x /usr/local/bin/froxy
</code></pre>
<p><code>froxy --socks 1080</code> запустить SOCKS прокси на порту 1080 <br />
<code>froxy --forward 8080</code> запустить HTTP/HTTPS прокси на порту 1080 <br />
<code>froxy --forward 8080 &gt;&gt; froxy.log &amp;</code> запустить фоновый процесс и передать вывод логов в файл <br />
<code>froxy --local 5514 --remote 192.168.3.100:514</code> запустить обратный прокси сервер на порту 5514, который перенаправляет на хост 192.168.3.100 и порт 514 (syslog) <br />
<code>froxy --local 192.168.3.100:2121 --remote 192.168.3.101:21</code> TCP туннелирование для RDP <br />
<code>froxy --local 127.0.0.1:8443 --remote https://example.com</code> принимать HTTPS трафик на порту 8443 и переадресовать на указанный URL (поддерживаются GET и POST запросы с передачей заголовков и тела запроса от клиента, для использования API запросы и прохождения авторизации на сайтах) <br />
<code>froxy --local *:8443 --remote https://example.com --user admin --pass admin</code> слушать на всех интерфейсах и использовать авторизацию</p>
<h2 id="nmap"><a class="header" href="#nmap">nmap</a></h2>
<p><code>nmap localhost</code> узнать какие локальные порты прослушиваются <br />
<code>nmap -sV localhost</code> определить какое какая ОС и ПО работает на портах и их версия <br />
<code>nmap -sL 192.168.3.0/24</code> список хостов с разрешением имен без пинга <br />
<code>nmap -sP 192.168.3.0/24</code> ping метод host discovery (TCP ACK SYN пакет, используя системныей вызов connect) с отображением производителя сетевой платы <br />
<code>nmap -F 192.168.3.0/24</code> fast mode port <br />
<code>nmap -A 192.168.3.100</code> подробное сканирование ОС и ПО (ssh на другом порту, version, ad sites, rdp-ntlm-info) <br />
<code>nmap -sA 192.168.3.100</code> обнаружить фильтрацию пакетов fw (filtered/unfiltered) с помощью TCP ACK <br />
<code>nmap -PN 192.168.3.100</code> сканировании защищенного хоста без ping <br />
<code>nmap -sO 192.168.3.100</code> определить какие именно IP-протоколы доступны и их статус, если отсутствует, значит фильтруется <br />
<code>nmap -PU 192.168.3.100</code> обойти межсетевой экран с помощью UDP-пинга <br />
<code>nmap -sS 192.168.3.100</code> выполнить полуоткрытое сканирование (TCP SYN) без установки подключения <br />
<code>nmap -sU 192.168.3.100</code> проверка только UDP-портов</p>
<h3 id="masscan"><a class="header" href="#masscan">masscan</a></h3>
<p><code>apt install masscan</code> асинхронный (отправляет пакеты SYN) сканер TCP портов (https://github.com/robertdavidgraham/masscan) <br />
<code>masscan 192.168.3.100 -p80</code> <br />
<code>masscan 192.168.3.100 -p0-65535 --rate 100</code> <br />
<code>masscan 192.168.3.100 -p0-65535 --rate 100 --ping-timeout 1000</code> <br />
<code>masscan 192.168.3.1-100 -p80</code> <br />
<code>masscan 192.168.3.0/24 -p80,443</code> <br />
<code>masscan 192.168.3.100 -p80 --output-format json --output-file result.json</code></p>
<h3 id="rustscan"><a class="header" href="#rustscan">rustscan</a></h3>
<p><code>wget https://github.com/RustScan/RustScan/releases/download/2.0.1/rustscan_2.0.1_amd64.deb \  </code>snap install nmap<code>требуется установить пакет зависимости \ </code>apt-get install -f<code>разрешить зависимости \ </code>dpkg --install rustscan_2.0.1_amd64.deb<code>\ </code>rustscan -a 127.0.0.1<code>\ </code>rustscan -a 192.168.3.100` 32400/tcp open plex</p>
<h3 id="tcp"><a class="header" href="#tcp">tcp</a></h3>
<pre><code class="language-bash">function tcp-scan () {
  if [ "$1" == "" ]; then
      exit 1
  fi
  START_PORT=$2; [ -z "$START_PORT" ] &amp;&amp; START_PORT=1
  END_PORT=$3; [ -z "$END_PORT" ] &amp;&amp; END_PORT=65535
  PORT_PROTOCOL="tcp"
  scan_port(){
      PORT_NUMBER=$1
      PORT_SCAN_RESULT=`2&gt;&amp;1 echo "" &gt; /dev/$PORT_PROTOCOL/$TARGET_NAME_OR_IP/$PORT_NUMBER | grep connect`
      [ "$PORT_SCAN_RESULT" == "" ] &amp;&amp; echo -e $PORT_NUMBER\/$PORT_PROTOCOL' \t 'open' \t\t '`grep $PORT_NUMBER/$PROTOCOL /etc/services | head -n1 | awk '{print $1}'`
  }
  TARGET_NAME_OR_IP=$1
  echo -e 'PORT \t\t STATE \t\t SERVICE'
  for PORT_NUMBER in `seq $START_PORT $END_PORT`; do
      scan_port $PORT_NUMBER
  done
}
</code></pre>
<p><code>tcp-scan 192.168.3.100 1024 5000</code></p>
<h2 id="tcpdump"><a class="header" href="#tcpdump">tcpdump</a></h2>
<p><code>tcpdump -D</code> список доступных сетевых интерфейсов <br />
<code>tcpdump -n -i ens33 icmp</code> слушать icmp-пакеты от всех на указанном интерфейсе (-i) без отображения доменных имен (-n) <br />
<code>tcpdump -n -i ens33 udp -e</code> слушать udp-пакеты и отображать MAC-адреса (-e) <br />
<code>tcpdump -n -i ens33 port 8080</code> слушать трафик 8080 порта <br />
<code>tcpdump -n -i ens33 port 80 or 443</code> <br />
<code>tcpdump -n -i ens33 portrange 21-80</code> <br />
<code>tcpdump -n -i ens33 ip src 192.168.3.99 and dst 192.168.3.103</code> отобразить ip пакеты, которые отправлены с указанного (src) ip-адреса на указанный (dst) ip-адрес <br />
<code>tcpdump -n -i ens33 -X host 192.168.3.100 and port 32400</code> отобразить содержимое пакетов (-X) для хоста и порта</p>
<h2 id="tshark"><a class="header" href="#tshark">tshark</a></h2>
<p><code>apt install tshark</code> <br />
<code>apt install termshark</code> terminal UI for tshark (https://github.com/gcla/termshark) <br />
<code>tshark -D</code> список интерфейсов <br />
<code>tshark -i 1</code> <br />
<code>disown</code> <br />
<code>tshark -i 1 -Y "syslog"</code> захват пакетов syslog (udp.port == 514) <br />
<code>tshark -i 1 host 192.168.3.104</code> захват пакетов для конкретного IP-адреса <br />
<code>tshark -i 1 net 192.168.3.0/24</code> захват пакетов указанной подсети <br />
<code>tshark -i 1 src host 192.168.3.104</code> захват исходящих пакетов <br />
<code>tshark -i 1 dst host 192.168.3.104</code> захват входящих пакетов <br />
<code>tshark -i 1 dst host 192.168.3.104 and port 8086</code> отфильтровать по входящему хосту и порту <br />
<code>tshark -i 1 dst host 192.168.3.104 and port 8086 and src host 192.168.3.99</code> отфильтровать по исходящему хосту <br />
<code>tshark -i 1 -x dst host 192.168.3.104 and port 8086 and src host 192.168.3.101</code> прочитать пакеты в шестнадцатеричном формате (-x) <br />
<code>tshark -i 1 -O TCP dst host 192.168.3.104 and port 8086 and src host 192.168.3.101</code> прочитать TCP-заголовки <br />
<code>tshark -i 1 -a duration:10 -w ~/192.168.3.0.pcap</code> сохранить захват <br />
<code>tshark -Y 'ip.addr == 192.168.3.106' -r ~/192.168.3.0.pcap</code> прочитать файл захвата с использованием фильтра <br />
<code>tshark -Y "(ip.addr == 192.168.3.106) or (ip.addr == 192.168.3.107)" -r ~/192.168.3.0.pcap</code> отфильтровать по двум адресам (или) <br />
<code>tshark -Y "(ip.addr == 192.168.3.104) and (tcp.port == 8086)" -r ~/192.168.3.0.pcap</code> отфильтровать по двум параметрам (и) <br />
<code>tshark -Y "!(ip.addr == 192.168.3.104)" -r ~/192.168.3.0.pcap</code> исключить <br />
<code>tshark -Y "not arp and not (udp.port == 53)" -r ~/192.168.3.0.pcap</code> отобразить весь udp-трафик, исключив ping и dns пакеты</p>
<h2 id="ping"><a class="header" href="#ping">ping</a></h2>
<h3 id="fping"><a class="header" href="#fping">fping</a></h3>
<p><code>fping yandex.ru google.com</code> параллельная проверка доступности двух хостов <br />
<code>fping -p 5 yandex.ru google.com</code> 5 параллельных запросов к каждому хосту <br />
<code>fping -ag 192.168.3.0/24</code> icmp проверка все подсети <br />
<code>fping &lt; hosts.txt</code> произвести ping всех хостов указанных в файле с новой строки</p>
<h3 id="netping"><a class="header" href="#netping">netping</a></h3>
<p><code>sudo curl -s https://raw.githubusercontent.com/Lifailon/net-tools/rsa/netping.sh -o /usr/bin/netping</code> <br />
<code>sudo chmod +x /usr/bin/netping</code> <br />
<code>netping 192.168.3.0</code></p>
<h2 id="firewall-1"><a class="header" href="#firewall-1">firewall</a></h2>
<h3 id="ufw"><a class="header" href="#ufw">ufw</a></h3>
<p><code>systemctl status ufw</code> <br />
<code>ufw status</code> <br />
<code>ufw enable</code> включить ufw (Uncomplicated Firewall) <br />
<code>ufw disable</code> отключить <br />
<code>ufw reload</code> перезапустить/применить настройки <br />
<code>ufw reset</code> сбросить настройки (отключить ufw и удалить все правила) <br />
<code>ufw default deny incoming</code> все входящие пакеты отклонять (политика по умолчанию, какие действия будут применяться к пакетам, если они не подпадают под созданные правила) <br />
<code>ufw default allow outgoing</code> все исходящие разрешать <br />
<code>ufw allow in 22</code> разрешить входящий трафик на порт 22 <br />
<code>ufw allow out 22</code> разрешить исходящий трафик на порт 22 <br />
<code>ufw deny in 80/tcp</code> запретить входящий TCP-трафик на 80 порт <br />
<code>ufw delete deny in 80/tcp</code> удалить правило <br />
<code>ufw allow 161,10050,10051/tcp</code> открыть несколько портов <br />
<code>ufw allow proto tcp from 0.0.0.0/24 to 192.168.3.100 port 3389</code> разрешить доступ со всех IP-адресов по TCP-протоколу к IP-адресу и порту 3389 <br />
<code>ufw allow from 192.168.3.0/24 to 192.168.3.110</code> разрешить подключение всем с подсети 192.168.1.0 к интерфейсу 192.168.1.2 (для Proxmox MGW) <br />
<code>ufw allow 25/tcp</code> открыть для всех направлений 25 порт <br />
<code>ufw limit ssh</code> лимт подключений к определенному порту с одного IP-адреса (для защиты от перебора), по умолчанию подключения блокируются, если пользователь пытается создать шесть и больше подключений за 30 секунд (настроить время и количество запросов можно только через iptables) <br />
<code>ufw logging on</code> включить логирование <br />
<code>ufw logging medium</code> выбрать уровень логирования (low/medium/high) <br />
<code>cat /var/log/ufw</code> директория хранения логов. Синтаксис: [UFW ALLOW/BLOCK/AUDIT] IN=интерфейс OUT=итерфейс SRC=ip_источника DST=ip_назначения LEN=размер_пакета TOS=0x10 PREC=0x00 TTL=64 ID=728 DF PROTO=протокол SPT=порт_источника DPT=порт назначения LEN=размер_пакета</p>
<h3 id="show"><a class="header" href="#show">show</a></h3>
<p><code>ufw show listening</code> отображает все прослушиваемые порты и правила для них (с указанием очередного номера в списке: [20] allow 161,10050,10051/tcp) <br />
<code>ufw show raw</code> все активные правила в формате iptables <br />
<code>ufw show added</code> недавно добавленные правила <br />
<code>ufw show builtins</code> правила, добавленные по умолчанию <br />
<code>ufw show user-rules</code> правила, добавленные пользователем <br />
<code>ufw show before-rules</code> правила, которые выполняются перед принятием пакета <br />
<code>ufw show after-rules</code> правила, которые выполняются после принятия пакета <br />
<code>ufw show logging-rules</code> правила логгирования пакетов</p>
<h3 id="firewalld"><a class="header" href="#firewalld">firewalld</a></h3>
<p><code>apt install firewalld</code> <br />
<code>systemctl status firewalld</code> <br />
<code>systemctl start firewalld</code> <br />
<code>pkill -f firewalld</code> убить процесс, если при запуске failed <br />
<code>firewall-cmd --state</code> статус работы <br />
<code>firewall-cmd --reload</code> применить настройки (перечитать) <br />
<code>firewall-cmd --list-all</code> список созданных правил (для services и ports) <br />
<code>firewall-cmd --list-port</code> только открытые порты <br />
<code>firewall-cmd --list-service</code> только открытые службы <br />
<code>firewall-cmd --list-all-zones</code> отобразить список зон <br />
<code>firewall-cmd --get-active-zones</code> список используемых зон <br />
<code>firewall-cmd --list-all --zone=public</code> информация о конкретной зоне <br />
<code>firewall-cmd --permanent --add-port=22/tcp</code> открыть 22 порт <br />
<code>firewall-cmd --permanent --add-port=8000-8080/udp</code> открыть диапазон портов <br />
<code>firewall-cmd --get-services | grep ssh</code> отобразить список доступных служб <br />
<code>firewall-cmd --permanent --add-service=ssh</code> разрешить порты для сервиса ssh <br />
<code>firewall-cmd --permanent --new-service=speedtest</code> добавить службу <br />
<code>firewall-cmd --permanent --service=speedtest --add-port=80/tcp</code> добавить порт к службе <br />
<code>firewall-cmd --info-service=speedtest</code> информация о службе <br />
<code>firewall-cmd --permanent --add-rich-rule 'rule family="ipv4" source address="192.168.3.0/24" service name="speedtest" accept'</code> открыть доступ для подсети <br />
<code>firewall-cmd --permanent --add-rich-rule 'rule family="ipv4" source address="192.168.3.0/24" port port="22" protocol="tcp" accept'</code> <br />
<code>firewall-cmd --permanent --add-rich-rule="rule family='ipv4' source address='192.168.21.0/24' reject"</code> закрыть доступ для подсети <br />
<code>firewall-cmd --list-rich-rules</code> список правил с условиями <br />
<code>firewall-cmd --permanent --remove-port=22/tcp</code> удалить правило</p>
<h3 id="iptables"><a class="header" href="#iptables">iptables</a></h3>
<p><code>iptables -L -v</code> выводит все существующие правила для каждой цепочки <br />
<code>iptables -L | grep -E "tcp|udp"</code> <br />
<code>if (( $(iptables -L | wc -l | bc) == 8)); then echo active; else echo inactive; fi</code> <br />
<code>iptables -A INPUT -p tcp --dport 22 -j ACCEPT</code> открыть входящий порт ssh <br />
<code>iptables -A INPUT -p tcp -s !192.168.3.99 --dport 22 -j DROP</code> закрыть входящий порт ssh, исключить 192.168.3.99 <br />
<code>iptables-save</code> сохранить настройки, что бы они были активны после перезагрузки <br />
<code>iptables -F</code> удалить все правила текущей таблицы</p>
<h3 id="nftables"><a class="header" href="#nftables">nftables</a></h3>
<p><code>nft -a list ruleset</code> список существующих правил <br />
<code>nft list tables</code> список существующих таблиц <br />
<code>nft flush ruleset</code> очистить правила <br />
<code>nft add table inet filter</code> создать таблицу filter <br />
<code>nft add chain inet filter input { type filter hook input priority 0\; }</code> добавить цепочку input <br />
<code>nft add rule inet filter input ct state related,established counter accept</code> <br />
<code>nft add rule inet filter input iifname "lo" counter accept</code> <br />
<code>nft add rule inet filter input ip protocol icmp counter accept</code> разрешить icmp <br />
<code>nft add rule inet filter input tcp dport {80, 443} counter accept</code> открыть порты <br />
<code>nft add rule inet filter input ip saddr { 192.168.100.0/24, 1.1.1.1/32 } tcp dport 22 counter accept</code> открыть 22 порт для подсетей <br />
<code>nft chain inet filter input { policy drop \; }</code> остальное блокировать <br />
<code>echo "flush ruleset" &gt; /etc/nftables.conf</code> очистить все правила <br />
<code>nft -s list ruleset &gt;&gt; /etc/nftables.conf</code> добавить правила в конфигурацию <br />
<code>systemctl enable nftables.service</code> <br />
<code>nft delete rule inet filter input handle 5</code> удалить правило по номеру <br />
<code>nft add rule inet filter input position 5 tcp dport 22 counter accept</code> добавить правило в конкретное место с номером в списке</p>
<h2 id="ssh"><a class="header" href="#ssh">ssh</a></h2>
<p><code>w</code> отобразить активные сессии и их активность (время/дата входа, IDLE время простоя и последняя выполняемая команда) <br />
<code>who</code> отобразить активные сессии, время/дата входа и ip с которого подключен пользователь <br />
<code>last -a</code> история всех последних входов пользователей в систему <br />
<code>lastlog</code> дата последнего входа каждого пользователя в систему <br />
<code>last reboot</code> история перезагрузки <br />
<code>id -G</code> получить список id крупп в которых состоит текущий пользователь</p>
<p><code>apt install xclip xsel</code> буфер обмена <br />
<code>cat /etc/ssh/sshd_config | xclip</code> <br />
<code>xsel &gt; sshd_config.bak</code> <br />
<code>nano /etc/ssh/sshd_config</code> <br />
<code>Port 2121</code> изменить порт <br />
<code>PermitRootLogin yes</code> включить возможность подключения пользователем root <br />
<code>PasswordAuthentication no</code> отключить аудентификацию по паролю <br />
<code>X11Forwarding yes</code> включить X11 <br />
<code>TCPKeepAlive yes</code> отвечает за проверку активности соединения (отправка пустых keep-alive пакетов для сохранения соединения) <br />
<code>ClientAliveInterval 60</code> задать интервал ожидания в секундах, через который sshd запросит ответ от клиента <br />
<code>ClientAliveCountMax 3</code> количество запросов без ответа до завешрения сеанса (ClientAliveInterval * ClientAliveCountMax = 180 секунд) <br />
<code>systemctl restart sshd</code> <br />
<code>systemctl status sshd</code></p>
<h3 id="keygen"><a class="header" href="#keygen">keygen</a></h3>
<p><code>ssh-keygen -t rsa -b 4096</code> сгенерировать пару ключей <br />
<code>id_rsa</code> приватный/закрытый ключ хранится на клиенте, от кого происходит подключение (для подключения без пароля имя файла должно быть по умолчанию) <br />
<code>cat ~/.ssh/id_rsa.pub | xclip</code> публичный/открытый ключ, для передачи на сервер, куда будем подключаться3 <br />
<code>xsel &gt; ~/.ssh/authorized_keys</code> передать содержимое публичного ключа (id_rsa.pub) на сервер, куда подключаться</p>
<h3 id="x11"><a class="header" href="#x11">x11</a></h3>
<p><code>apt-get install virt-manager ssh-askpass</code> <br />
<code>virt-manager</code> <br />
<code>export DISPLAY=username-VirtualBox:10.0 &amp;&amp; firefox</code></p>
<h3 id="scp"><a class="header" href="#scp">scp</a></h3>
<p><code>ssh-copy-id root@192.168.3.105 -p 2121</code> скопировать публичный ключ на удаленный сервер (добавить новой строкой), утилита будет искать в директории текущего локального пользователя файл публичного ключа и скопирует содержимое файла ключа ~/.ssh/id_rsa.pub указанному при подключение пользователю на удаленный компьютер в файл authorized_keys <br />
<code>scp -P 2121 /home/lifailon/files/* lifailon@192.168.3.105:/home/lifailon/downaload/</code> скопировать содержимое каталога files на удаленный компьютер в директорию downaload <br />
<code>scp -P 2121 -r kup@192.168.3.105:/home/lifailon/downaload /home/lifailon/files/</code> скачать (-r) данные с удаленного сервера на локальный</p>
<h3 id="sshpass"><a class="header" href="#sshpass">sshpass</a></h3>
<pre><code class="language-bash">hosts=(192.168.3.101 192.168.3.102 192.168.3.103 192.168.3.104)
username="lifailon"
port=2121
read -s -p "Введите пароль пользователя $username: " password
echo
for host in ${hosts[@]}; do
    sshpass -p $password ssh -p $port $username@$host "echo $(uname -n) $(free -m | grep Mem: | awk '{print $3"/"$2}')"
done
</code></pre>
<h2 id="sudoers"><a class="header" href="#sudoers">sudoers</a></h2>
<p><code>cat /etc/sudoers</code> конфигурационный файл настройки прав доступа утилиты sudo <br />
<code>visudo</code> открыть sudoers в режиме проверки синтаксиса <br />
<code>Defaults env_reset, timestamp_timeout=10</code> задать ограничение времени для sudo на 10 минут <br />
<code>echo "lifailon ALL=(ALL) NOPASSWD:ALL" &gt; /etc/sudoers.d/lifailon</code> создать конфигурацию пользователя для использования sudo без пароля <br />
<code>chmod 644 /etc/sudoers.d/lifailon</code> <br />
<code>lifailon ALL=NOPASSWD: /usr/bin/service memcahched restart, /usr/bin/apt-get update, /usr/bin/apt-get upgrade</code> разрешить перезапуск определенного сервиса, обновление списка пакетов и установку обновлений системы <br />
<code>%powerusers ALL=NOPASSWD: /usr/bin/service memcahched restart</code> доступ на группу <br />
<code>visudo --check</code> проверка синтаксиса и всех прав доступа (0440) <br />
<code>sudo -l</code> проверка прав доступа (выводит список команд, которые текущий пользователь может выполнять с использованием sudo)</p>
<h2 id="strace"><a class="header" href="#strace">strace</a></h2>
<p><code>strace -c top -n 1 &gt; /dev/null</code> показывает статистику системных вызовов программы (time - процент от времени общего выполнения, call - кол-во обращений и ошибки) <br />
<code>pid=$(pidof dd)</code> узнать pid процесса по имени <br />
<code>strace -p $pid</code> показывает системные вызовы процесса (читает данные из одного места с помощью вызова read и записывает в другое через write) <br />
<code>strace -f -p $(pgrep -o sshd) -o ~/passwd.txt -v -e trace=write -s 64</code> следим за всеми процессами sshd (-f), ищем все PID sshd процессов (-p), триггер только на запись данных (-e) и ограничиваем вывод 64 байтами <br />
<code>cat ~/passwd.txt | grep "[1-32][1-32]) = [1-32][1-32]"</code></p>
<h2 id="apt"><a class="header" href="#apt">apt</a></h2>
<p><code>apt-mark showauto</code> список установленных автоматически пакетов <br />
<code>apt-mark showmanual</code> список установленных пакетов вручную <br />
<code>echo $(($(apt-mark showauto | wc -l) + $(apt-mark showmanual | wc -l)))</code> количество всех установленных пакетов <br />
<code>apt list --installed</code> список установленных пакетов apt (Advanced Package Tool) <br />
<code>apt update</code> обновить список всех установленных пакетов системы из источников, указанных в файле конфигурации /etc/apt/sources.list <br />
<code>cat /etc/apt/sources.list | grep -Ev "^#"</code> список источников <br />
<code>apt list --upgradable</code> отобразить список, для каких пакетов доступны обновления <br />
<code>apt list --upgradable -a</code> upgradable from, installed и все доступные версии <br />
<code>apt install --only-upgrade powershell</code> обновить один выбранный пакет <br />
<code>apt --fix-broken install</code> исправить проблемы и ошибки с зависимостями <br />
<code>apt full-upgrade</code> обновляет все пакеты, которые уже установлены в системе, доставляет новые пакеты зависимости и удаляет пакеты, которые устанавливались в систему и уже не используются <br />
<code>apt install net-tools</code> установить пакет <br />
<code>apt download net-tools</code> скачать пакет без установки <br />
<code>apt install net-tools --reinstall</code> переустановить пакет <br />
<code>apt remove net-tools</code> удалить пакет (конфигурационные файлы, которые были изменены в системе удалены не будут) <br />
<code>apt purge net-tools</code> полностью удалить пакет, вместе со всеми его конфигурационными файлами <br />
<code>apt policy net-tools</code> какая версия установленна и какие доступны <br />
<code>apt install net-tools=number ver.</code> установить конкретную версию <br />
<code>apt autoremove</code> очистить ненужные пакеты, которые система не использует <br />
<code>apt autoclean</code> очистить кэш пакетов</p>
<h2 id="snap"><a class="header" href="#snap">snap</a></h2>
<p>Содержат саму программу (deb-пакет), а также все её зависимости и библитотеки необходимых версий для данной программы. <br />
<code>ls /snap</code> директория пакетов <br />
<code>ls /var/lib/snapd/snaps</code> расположение загруженных пакетов .snap <br />
<code>snap install snap-store</code> установка магазина приложений <br />
<code>snap find nmap</code> поиск приложения в магазине snap <br />
<code>snap info nmap</code> информация о пакете (его наличии, версия, дата релиза и размер) <br />
<code>snap list</code> список установленных в системе пакетов <br />
<code>snap list | sed 1d | wc -l</code> количество установленных пакетов <br />
<code>snap list --all nmap</code> все доступные версии определенного пакета <br />
<code>snap refresh nmap</code> обновить пакет до последней версии <br />
<code>snap revert nmap</code> откатить версию до предыдущей <br />
<code>snap install nmap --stable</code> установить конкретную версию пакета <br />
<code>snap connections nmap</code> посмотреть доступность приложения к интерфейсам системы <br />
<code>snap remove nmap</code> удалить пакет</p>
<h2 id="dpkg"><a class="header" href="#dpkg">dpkg</a></h2>
<p><code>dpkg -i spark.deb</code> установить пакет <br />
<code>dpkg -l</code> список установленных deb-пакетов <br />
<code>dpkg -l | wc -l</code> количество установленных пакетов <br />
<code>dpkg -l spark</code> проверить, установлен ли пакет в системе и его версию <br />
<code>dpkg -s spark</code> проверить статус пакета <br />
<code>dpkg -r spark</code> удалить (--remove) .deb пакет <br />
<code>dpkg -P spark</code> удалить пакет вместе с фаилами конфигурации <br />
<code>dpkg -L spark</code> куда установлен пакет (opt/Spark)</p>
<h2 id="ntp"><a class="header" href="#ntp">ntp</a></h2>
<h3 id="time"><a class="header" href="#time">time</a></h3>
<p><code>timedatectl</code> текущее время <br />
<code>timedatectl set-timezone 'Europe/Moscow'</code> изменить временную зону на MSK, +0300 (изменится Local time) <br />
<code>timedatectl list-timezones</code> список часовых поясов <br />
<code>timedatectl set-ntp no</code> отключить NTP service <br />
<code>timedatectl set-time "13:00:00"</code> после отключения NTP указать время в ручную <br />
<code>timedatectl set-ntp yes</code> включить NTP service (NTP service: active)</p>
<h3 id="language"><a class="header" href="#language">language</a></h3>
<p><code>locale</code> установленные в системе локализации <br />
<code>update-locale LANG=en_US.UTF-8</code> изменить локализацию <br />
<code>apt-get install language-pack-en language-pack-en-base</code> установить пакет локализаций <br />
<code>nano /etc/default/locale</code> <br />
<code>LANG=en_US.UTF-8</code> <br />
<code>dpkg-reconfigure locales</code></p>
<h3 id="timesyncd"><a class="header" href="#timesyncd">timesyncd</a></h3>
<p><code>systemctl status systemd-timesyncd</code> <br />
<code>systemctl status systemd-timesyncd | grep "Status": | sed -E "s/^.+server //; "s/.\"//""</code> узнать адрес сервера синхронизации времени <br />
<code>apt install systemd-timesyncd</code> установить службу, если unit не запускается <br />
<code>apt-get remove ntp ntpstat --purge &amp;&amp; apt autoremove</code> удалить ntpd (если был установлен) <br />
<code>nano /etc/systemd/timesyncd.conf</code> <br />
<code>NTP=192.168.3.233</code> DC (Domain Controller) <br />
<code>NTP=0.debian.pool.ntp.org 1.debian.pool.ntp.org 2.debian.pool.ntp.org 3.debian.pool.ntp.org</code> <br />
<code>FallbackNTP=ntp.ubuntu.com</code> резерв <br />
<code>systemctl restart systemd-timesyncd</code> <br />
<code>timedatectl set-ntp true</code> включить использование systemd-timesyncd для синхронизации времени (вместо ntpd) <br />
<code>timedatectl status</code></p>
<h3 id="ntpd"><a class="header" href="#ntpd">ntpd</a></h3>
<p><code>apt install ntp</code> установить NTP-сервер/клиент, при установке будет удален пакет systemd-timesyncd <br />
<code>systemctl status ntp</code> <br />
<code>sntp --version</code> <br />
<code>ufw allow 123/udp &amp;&amp; ufw reload</code> <br />
<code>timedatectl set-ntp false</code> отключить синхронизацию через systemd-timesyncd на клиенте <br />
<code>nano /etc/ntp.conf</code> <br />
<code>pool 0.ubuntu.pool.ntp.org</code> указать пул серверов <br />
<code>server 0.ru.pool.ntp.org</code> указать на конкретный сервер (если это pool, возьмет один) <br />
<code>restrict default kod notrap nomodify nopeer noquery limited</code> настройки/ограничения для локального NTP сервера <br />
<code>systemctl restart ntp</code> <br />
<code>systemctl status ntp</code> <br />
<code>timedatectl status</code> <br />
<code>ntpq -p</code> проверка синхронизации времени (+ сервер можно использовать для сверки часов, * синхронизирует сейчас, - не рекомандован, st - уровень stratum, when — когда последний раз сверялось время, delay - время задержки, offset - разница между локальным временем и временем на сервере - отстают от сервера или спешат)</p>
<h2 id="top"><a class="header" href="#top">top</a></h2>
<p><code>top -c</code> выводит полный путь к исполняемым файлам с ключами, вместо названия <br />
<code>top -H</code> выводит потоки процессов <br />
<code>top -i</code> не выводит процессы, которые не используют ресурсы процессора <br />
<code>top -o %CPU</code> отсортировать по CPU <br />
<code>top -o %MEM</code> отсортировать по Memory</p>
<h3 id="htop"><a class="header" href="#htop">htop</a></h3>
<p><code>space</code> выделить несколько процессов (отменить Shift+U) <br />
<code>u</code> выбрать конкретного пользователя <br />
<code>l</code> посмотреть файлы, которые использует процесс <br />
<code>s</code> отобразить статистику системных вызовов (strace PID attached) F8 - AutoScroll, F4 - Filter, F9 - Stop/Start Tracing <br />
<code>F4</code> фильтр по ключевому слову (например, cron) <br />
<code>F5</code> древовидная структура <br />
<code>F6</code> сортировка (PERCENT_CPU/PERCENT_MEM/USER/PRIORITY/TIME) <br />
<code>F7</code> повысить приортите (до -20), чем меньше приоритет, тем больше процессорного времени отводится процессу <br />
<code>F8</code> понизить приоритет (до 19) <br />
<code>F9/K</code> действие с процессом (сигналы), для завершения процесса: 15, 2, 3, 9 или 19 <br />
<code>S (STATE)</code> состояние процесса <br />
<code>R</code> [running or runnable] запущенные или находятся в очереди на запуск <br />
<code>S</code> [interruptible sleep] прерываемый сон (не исполняется процессором и ждет события или условия для запуска) <br />
<code>D</code> [uninterruptible sleep] непрерываемый сон (кратковременное состояние, которое невозможно остановить сигналом, т.к. процесс не может на него ответить) <br />
<code>Z</code> [zombie] завершенный процесс, ожидающий пока родительский процесс примет результат <br />
<code>T</code> остановленный сигналом SIGSTOP (-19/CTRL+Z) <br />
<code>X</code> мертвый (не должен показываться)</p>
<h3 id="bpytop"><a class="header" href="#bpytop">bpytop</a></h3>
<p><code>sudo apt install bpytop</code> <br />
<code>pip3 list | grep psutil</code> проверить пакет <br />
<code>pip3 install psutil --break-system-packages</code> установить пакет в обход ограничений <br />
<code>python3 -m venv myenv</code> создать виртуальное окружение <br />
<code>source myenv/bin/activate</code> активировать виртуальное окружение <br />
<code>pip install psutil</code> установить библиотеку для получения информации о системе <br />
<code>bpytop</code> <br />
<code>deactivate</code></p>
<h3 id="atop"><a class="header" href="#atop">atop</a></h3>
<p><code>apt install atop</code> <br />
<code>nano /etc/default/atop</code> <br />
<code>LOGINTERVAL=10</code> <br />
<code>systemctl restart atop</code> <br />
<code>atop -g</code> показать общую информацию о процессе (по умолчанию) <br />
<code>atop -m</code> показать информацию о процессах, связанных с памятью <br />
<code>atop -d</code> показать информацию о процессах, связанных с дисками <br />
<code>atop -n</code> показать информацию о процессах, связанных с сетью <br />
<code>atop -v</code> показывать различную информацию о процессах (PPID родителя, пользователь/группа, дата/время) <br />
<code>atop -c</code> показать командную строку для каждого процесса <br />
<code>atop -A</code> сортировать процессы в порядке наибольшей активности ресурсов (автоматический режим) <br />
<code>atop -C</code> сортировать процессы в порядке потребления процессора (по умолчанию) <br />
<code>atop -M</code> сортировать процессы в порядке потребления памяти <br />
<code>atop -D</code> сортировать процессы в порядке дисковой активности <br />
<code>atop -N</code> сортировать процессы в порядке сетевой активности <br />
<code>atop -E</code> сортировать процессы в порядке активности GPU</p>
<h3 id="iftop"><a class="header" href="#iftop">iftop</a></h3>
<p><code>apt install iftop</code> установить пакет <br />
<code>iftop -ti ens33</code> использовать текстовый интерфейс без ncurses <br />
<code>iftop -ts 1 -i ens33</code> печать одного единственного текстового вывода (-s) через 1 секунд, затем выход из системы <br />
<code>iftop -tL 0 -s 1 -i ens33</code> количество строк (-L) для печати <br />
<code>iftop -ni ens33</code> не преобразовывать имена хостов <br />
<code>iftop -Ni ens33</code> не преобразовывать номера портов в сервисы <br />
<code>iftop -pi ens33</code> работать в режиме promiscuous (показывать трафик между другими хостами в одном сегменте сети) <br />
<code>iftop -bi ens33</code> не отображать гистограмму трафика <br />
<code>iftop -Bi ens33</code> отображать пропускную способность в байтах <br />
<code>iftop -o 10si ens33</code> сортировка по второму столбцу (среднее значение трафика за 10 секунд, значение по умолчанию)</p>
<h3 id="iotop"><a class="header" href="#iotop">iotop</a></h3>
<p><code>apt install iotop</code> <br />
<code>iotop -o</code> показывать только процессы или потоки, фактически выполняющие ввод-вывод <br />
<code>iotop -ou mysql</code> показывать активные процессы от пользователя <br />
<code>iotop -P</code> показывать только процессы, без потоков <br />
<code>iotop -p PID</code></p>
<h3 id="top-other"><a class="header" href="#top-other">top other</a></h3>
<p><code>pip install --user glances</code> кроссплатформенный инструмент мониторинга системы на Python (https://github.com/nicolargo/glances) <br />
<code>glances</code></p>
<p><code>snap install bashtop</code> монитор ресурсов на Bash (https://github.com/aristocratos/bashtop) <br />
<code>bashtop</code></p>
<p><code>npm install gtop -g</code> панель мониторинга системы для терминала на JavaScript (https://github.com/aksakalli/gtop) <br />
<code>gtop</code></p>
<p><code>snap install bottom</code> кроссплатформенный графический монитор системы и процессов на Rust (https://github.com/ClementTsang/bottom) <br />
<code>bottom</code></p>
<p><code>curl -sL https://raw.githubusercontent.com/wimpysworld/deb-get/main/deb-get | sudo -E bash -s install deb-get &amp;&amp; deb-get install zenith</code> как top, но с масштабируемыми графиками, а также использованием CPU, GPU, сети и дисков на Rust (https://github.com/bvaisvil/zenith) <br />
<code>zenith</code></p>
<h2 id="ps"><a class="header" href="#ps">ps</a></h2>
<p><code>apt-get install -y procps</code> установить пакет procps <br />
<code>pstree -a</code> отобразить все (-a) работающие процессы (демоны) и их дочерние в виде дерева <br />
<code>ps -FA</code> отобразить подробный вывод (-F, PPID - родительский процесс) всех (-A) работающих процессов <br />
<code>ps -LFC mysqld</code> отобразить потоки (-L) в колонках LWP и NLWP конкретного процесса по имени (-C) <br />
<code>ps -Fl</code> отобразить приостановленные процессы (фоновые задания &amp;) <br />
<code>ps f -F</code> отображает активные процессы текущего пользователя <br />
<code>ps f -u root</code> активные процессы указанного пользователя <br />
<code>ps -o pid -u lifailon</code> вывести только pid процессов запущенных конкретным пользователем <br />
<code>ps -p 3618275</code> найти процесс по его PID (-p/-s) <br />
<code>ps -aux --sort -rss</code> выбрать все процессы, кроме фоновых (-a), сопоставлять с именем пользователя (-u), все процессы вне терминала (-x) и отсортировать по RSS, добавляется %CPU и %MEM <br />
<code>ps -lax</code> не сопоставляются идентификаторы процессов с именами пользователей, к выводу добавляется WCHAN - ресурс, которого ожидает процесс <br />
<code>ps -FA --sort time</code> сортировать по времени работы процесса <br />
<code>ps -Ao comm,user,rss,vsz,command</code> отфильтровать вывод по потреблению памяти, названию команды/процесса и полному вызову команды с ключами <br />
<code>PRI</code> приоритет процесса <br />
<code>NI</code> уступчивость процесса (nice value от 19 до -20) <br />
<code>(($PRI+$NI))=((39+-20))=19</code> <br />
<code>TTY</code> терминал, из под которого запущен процесс <br />
<code>TIME</code> общее время процессора, затраченное на работу процесса (bsdtime/cputime/time) или накопленное процессорное время (пользовательское + системное) <br />
<code>STIME</code> время запуска команды (bsdstart), если процесс был запущен менее 24 часов назад, то формат вывода будет HH:MM, если больше, то Mmm:SS (Sep 18) <br />
<code>C</code> целочисленное значение процента времени процессора (%CPU) за время жизни процесса <br />
<code>%CPU</code> процент времени центрального процесса выделенного процессу или использование процессорного времени деленное на время работы процесса (pcpu) <br />
<code>%MEM</code> процент реальной памяти, используемой процессом или отношение размера резидентного набора процесса к объему физической памяти на машине (pmem) <br />
<code>SZ</code> размер в физических страницах образа ядра процесса.  Сюда входят текст, данные и пространство стека <br />
<code>RSS</code> постоянное потребление физической памяти (Resident Set Size non-swapped), реальный размер процесса в оперативной памяти, которую процесс занял (то есть что-то сохранил в память) <br />
<code>VSZ</code> виртуальная память (Virtual Memory Size) в килобайтах (1024-байтных единицах), которую выделили процессу, но это не означает, что он успел в эту память что-то записать <br />
<code>LWP</code> идентификатор дочернего потока (Light-Weight Process), будет выведен текущий ID если один или первый поток <br />
<code>NLWP</code> количество (Number) дочерних потоков (ps -LFC mysqld | sed 1d | wc -l) <br />
<code>PSR</code> ядро процессора, на котором выполняется процесс <br />
<code>STAT</code> R - выполняется, D - ожидает записи на диск, S - неактивен (&lt;20 с), T - приостановлен, Z - зомби, с дополнительными флагами (W - процесс выгружен на диск, &lt; - процесс имеет повышенный приоритет, N - процесс имеет пониженный приоритет, L - некоторые процессы блокированы в ядре, s - процесс является лидером сеанса) <br />
<code>maj_flt</code> количество крупных страничных ошибок, произошедших с данным процессом <br />
<code>min_flt</code> количество мелких ошибок страниц <br />
<code>ps -Ao comm,user,cputime,pcpu,pmem,sz,rss,vsz,nlwp,psr,pri,ni --sort cputime</code></p>
<h3 id="kill"><a class="header" href="#kill">kill</a></h3>
<p><code>kill -INT (-2) PID</code> прерывания с терминала, bash пошлёт сигнал SIGINT процессу (аналогично CTRL+C) <br />
<code>kill -KILL (-9) PID</code> принудительно завершить процесс <br />
<code>kill -STOP (-19) PID</code> остановить процесс, bash пошлёт сигнал SIGSTOP процессу (аналогично CTRL+Z) <br />
<code>kill -CONT (-18) PID</code> продолжить остановленный процесс</p>
<h3 id="procs"><a class="header" href="#procs">procs</a></h3>
<p><code>snap install procs</code> современная замена ps, написанная на Rust (https://github.com/dalance/procs) <br />
<code>procs</code></p>
<h2 id="jobs-1"><a class="header" href="#jobs-1">jobs</a></h2>
<p><code>(ping google.com) &amp;</code> запустить задачу в фоне (отображается [job] - номер задачи и PID процесса) <br />
<code>jobs</code> отобразить список фоновых задач (+ задача активна) <br />
<code>jobs -l | wc -l</code> получить список всех запущенных заданий <br />
<code>fg 1</code> открыть задачу по номеру <br />
<code>disown</code> завершить все фоновые задачи (удалить/очистить всю очередь заданий) <br />
<code>disown %1</code> завершить последнию (если она первая) запущенную задачу <br />
<code>kill %1</code> завершить последнию запущенную задачу</p>
<h3 id="nohub"><a class="header" href="#nohub">nohub</a></h3>
<p><code>nohup ping ya.ru &gt; ping.log &amp;</code> используется для запуска процесса, который продолжает работать, даже если пользователь выйдет из сеанса (например, при закрытии терминала) <br />
<code>ps -ef | grep "ping ya.ru"</code> найти процесс <br />
<code>kill $(pgrep ping)</code> завершить процесс</p>
<h2 id="mem"><a class="header" href="#mem">mem</a></h2>
<p><code>free -m</code> объем оперативной памяти и SWAP в МБайт <br />
<code>swapon</code> точка монтирования SWAP, type, size, used, priority (берет информацию из /proc/swaps) <br />
<code>ipcs -lm</code> объем страниц разделяемой памяти (shared memory) <br />
<code>cat /proc/meminfo | grep Dirty</code> отобразить объем грязных (Dirty) страниц в кэше (еще не записанных на диск) <br />
<code>sync</code> записать все кэшированные, но еще не записанные данные на диск (вместо кэша данные будут читаться из диска) <br />
<code>cat /proc/meminfo | grep -iE "^cache|^buff"</code> объем кэша и буфера <br />
<code>echo 1 &gt; /proc/sys/vm/drop_caches</code> отправить сигнал на вход drop_caches для очистки страничного кэша (free buff/cache) - PageCache (сигнал 1) <br />
<code>echo 2 &gt; /proc/sys/vm/drop_caches</code> очистка кэша структуры файловой системы - inode, dentrie (сигнал 2)</p>
<h3 id="fincore"><a class="header" href="#fincore">fincore</a></h3>
<p><code>fincore /var/log/*</code> отобразить все файлы, которые находятся в кэше страниц оперативной памяти (page cache) <br />
<code>fincore /var/log/syslog</code> 4.3M (данные файла, хранящиеся в памяти) 1100 (кол-во страниц хранящиеся в памяти PageCache) 199.7M (размер файла) <br />
<code>fincore /var/log/syslog -J</code> вывод в JSON (--raw вывод без табулияции, --noheadings без заголовков, --byte размер файла в байтах) <br />
<code>apt install vmtouch</code> <br />
<code>vmtouch /var/log/syslog</code> узнать какой процент указанного файла находится в страничном кеше (Resident Pages: 1100/51119  4M/199M  2.15%)</p>
<h3 id="lspage"><a class="header" href="#lspage">lspage</a></h3>
<p><code>fc=$(du -a $1 2&gt; /dev/null | awk '{print $2}' | xargs fincore 2&gt; /dev/null)</code> <br />
<code>echo -e "PAGE\tSIZE\tPATH"</code> <br />
<code>printf "%s\n" "${fc[@]}" | grep -wvE "0B|SIZE" | awk 'BEGIN {OFS="\t"}; {print $1,$3,$4}'</code></p>
<h2 id="lsof"><a class="header" href="#lsof">lsof</a></h2>
<p><code>PID</code> идентификационный номер процесса, который открыл файл <br />
<code>TID</code> идентификационный номер задачи/потока, пустой столбец означает, что это не задача а процесс <br />
<code>FD</code> файловый дескриптор файла (r - доступ для чтения, w - доступ для записи, u - доступ для чтения и записи, -r - режим неизвестен и есть символ блокировки на чтение часть файла, R - на весь файл) <br />
<code>TYPE</code> тип узла, связанного с файлом (REG - обычный файл файловой системы, DIR - директория, CHR - символьный файл, BLK - блочный файл, INET - Интернет-сокет, unix - доменный сокет UNIX, IPv4 - IPv4 сокет, sock - неизвестный сокет, DEL - указатель Linux для удалённого файла, LINK - файл символьной ссылки, PIPE: — способ обмена данными между процессами) <br />
<code>SIZE/OFF</code> размер файла или смещение файла в байтах <br />
<code>lsof | sed 1d | wc -l</code> кол-во открытых файлов/дескрипторов <br />
<code>cat /proc/sys/fs/file-nr</code> кол-во открытых файловых дескрипторов в текущий момент, открытые файлы которые сейчас не используются, максимальное количество для открытия <br />
<code>lsof +D /var/log/</code> отобразить каким процессом и пользователем используются файлы в каталоге (+D dir) FD: r/w/u <br />
<code>dd if=/dev/zero of=~/dd-zero-file</code> занять файл процессом dd и Ctrl+Z остановить процесс (отправить в jobs) <br />
<code>ls -lh ~/dd*</code> <br />
<code>lsof ~/dd-zero-file</code> отобразить каким процессом занят файл (List Open Files) <br />
<code>lsof -c dd</code> отобразить все файлы запущенные по имени процесса/команды (в формате wildcard) <br />
<code>lsof -p 1832509</code> отобразить все открытые файлы по номеру PID-процесса (-p) <br />
<code>lsof -c mysql</code> отобразить все файлы которые держит открытыми процесс по названию процесса (-c) <br />
<code>lsof -c bash | grep "\.sh"</code> найти все запущенные скрипты <br />
<code>kill -9 $(lsof -t ~/dd-zero-file)</code> отфильтровать для вывода уникальных номеров PID-процесса (-t) использующие файл, для их завершения (kill) <br />
<code>kill -9 $(lsof -t +D /smb/backup)</code> убить все процессы использующие файлы в директории для дальнейшего umount /smb/backup <br />
<code>lsof -u root</code> отобразить все файлы открытые пользователем  <br />
<code>lsof -u^root | wc -l</code> исключить пользователя (^) из поиска и отобразить кол-во открытых файлов <br />
<code>lsof -i:8080</code> проверить открыт ли порт (-i:)</p>
<h3 id="descriptor"><a class="header" href="#descriptor">descriptor</a></h3>
<p><code>lsof -a -p $$ -d 0,1,2</code> отобразить дескрипторы текущего интерпритатора <code>ps $$</code> <br />
<code>0u</code> STDIN — стандартный поток ввода (с клавиатуры) <br />
<code>1u</code> STDOUT — стандартный поток вывода (на экран/в файл) <br />
<code>2u</code> STDERR — стандартный поток ошибок <br />
<code>cat test.txt 1&gt; out.txt 2&gt; error.txt</code> перенаправить успешный вывод (если файл существует) в out.txt, если ошибка в error.txt <br />
<code>cat test2.txt 2&gt; /dev/null</code> не выводить ошибки <br />
<code>cat=$(cat test 2&gt;&amp;1)</code> используется для перенаправления стандартного вывода ошибок (stderr - standard error) в стандартный вывод (stdout - standard output) с указанием файлового дескриптора (&amp;) вместо файла</p>
<h2 id="vmstat"><a class="header" href="#vmstat">vmstat</a></h2>
<p><code>cat /proc/vmstat</code> отображает nr_free_pages, inactive/active anon, file <br />
<code>cat /proc/zoneinfo</code> с разбиением на зоны памяти в зависимости от ее назначения <br />
<code>vmstat -V</code> procps-ng 3.3.17 (разработчик top) <br />
<code>vmstat -s</code> статистика memory/swap/io/system/cpu <br />
<code>vmstat -d | grep sda</code> статистика диска <br />
<code>vmstat -D</code> суммарная статистика дисков <br />
<code>vmstat -t 1 2</code> отобразить 2 отчета (суммарный и текущий) с частатой обновления 1 секунда и timestamp (-t) <br />
<code>r</code> количество запущенных процессов (работающих или ожидающих выполнения) <br />
<code>b</code> количество спящих процессов <br />
<code>swpd</code> объем используемой виртуальной памяти <br />
<code>free</code> объем свободной памяти <br />
<code>buff</code> количество памяти, используемой в качестве буферов <br />
<code>cache</code> объем памяти, используемой в качестве кеша <br />
<code>inact</code> количество неактивной памяти (-a) <br />
<code>active</code> количество активной памяти (-a) <br />
<code>si</code> объем памяти, выгруженный с диска (/s) <br />
<code>so</code> объем памяти, перенесенный на диск (/s) <br />
<code>bi</code> IOPS (Input/Output Operations Per Second) блоки, полученные от блочного устройства (block input/sec) <br />
<code>bo</code> IOPS блоки, отправленные на блочное устройство (block output/sec) <br />
<code>in</code> количество прерываний в секунду, включая часы <br />
<code>cs</code> количество переключений контекста в секунду <br />
<code>us</code> время, потраченное на запуск кода, не относящегося к ядру (время пользователя) <br />
<code>sy</code> время, потраченное на выполнение кода ядра (системное время) <br />
<code>id</code> время бездействия <br />
<code>wa</code> время, проведенное в ожидании ввода/вывода <br />
<code>st</code> время, украденное из виртуальной машины</p>
<h2 id="sysstat"><a class="header" href="#sysstat">sysstat</a></h2>
<p><code>apt install sysstat</code></p>
<h3 id="iostat"><a class="header" href="#iostat">iostat</a></h3>
<p><code>iostat -h</code> выводить данные в kb/mb/gb (avg-cpu: %user %system %idle, tps - количество запросов на чтение и запись к устройству в секунду) <br />
<code>iostat -hp</code> вывести статистику по устройству и всех его разделам (-p) <br />
<code>iostat -ky /dev/sd* 1 1 | grep -w sd.</code> выводить статистику в КБайт (-k), при отображении нескольких записей с заданным интервалом первый отчет со статистикой с момента загрузки системы опускается (-y) <br />
<code>iostat -h /dev/sda3 -o JSON</code> вывод в формате JSON</p>
<h3 id="mpstat"><a class="header" href="#mpstat">mpstat</a></h3>
<p><code>mpstat</code> отобразить подробную статистику по использованию процессора по каждому ядру, и куда используются ресурсы <br />
<code>mpstat -P ALL</code> отобразить отдельно для каждого ядра. <br />
<code>mpstat 2 10</code> отобразить 10 раз с обновлением каждые 2 секунды <br />
<code>%user</code> процент использования процессора программами, запущенными на уровне пользователя <br />
<code>%nice</code> процент использования процессора программами запущенными в пространстве пользователя, с изменённым приоритетом <br />
<code>%system</code> процент использования процессора ядром <br />
<code>%iowait</code> процент времени затраченного на ожидание завершения операций ввода/вывода, если значение параметра слишком большое, значит много времени тратится на ожидание завершения ввода/вывода <br />
<code>%steal</code> процент простоя виртуального процессора, пока гипервизор отдаёт мощность другому виртуальному процессору <br />
<code>%idle</code> процент времени пока процессор не занят ничем</p>
<h3 id="pidstat"><a class="header" href="#pidstat">pidstat</a></h3>
<p><code>pidstat</code> используется для мониторинга родительских и дочерних процессов и текущих потоков <br />
<code>pidstat -p ALL</code> вывести все активные и неактивные задачи</p>
<h2 id="stress"><a class="header" href="#stress">stress</a></h2>
<p><code>stress --cpu 2 --timeout 10</code> загрузить выбранное количество ядер в течении 10 секунд <br />
<code>stress -v N</code> нагрузить виртуальную память <br />
<code>stress --io 100 &amp;</code> количество процессов нагрузки на ввод-вывод <br />
<code>iostat -d /dev/sda 1</code> <br />
<code>stress --hdd 100 &amp;</code> нагрузка на диск <br />
<code>vmstat 1 100</code></p>
<h3 id="stress-ng"><a class="header" href="#stress-ng">stress-ng</a></h3>
<p><code>apt-get install stress-ng</code> <br />
<code>stress-ng --sequential 0 --class io --timeout 60s --metrics-brie</code> тест ввода вывода <br />
<code>stress-ng --hdd 5 --hdd-ops 100000</code> будет запущено 5 стрессоров для жёстких дисков, которые будут остановлены по завершении 100 тыс. bogo-операций <br />
<code>stress-ng --cpu 1 --cpu-method matrixprod --metrics --timeout 60</code> <br />
<code>stress-ng --sequential 0 --class memory --timeout 60s --metrics-brief</code> <br />
<code>stress-ng --cpu 2 --io 4 --vm 1 --vm-bytes 1G --timeout 60s --metrics-brief</code></p>
<h2 id="smart"><a class="header" href="#smart">smart</a></h2>
<h3 id="smartmontools"><a class="header" href="#smartmontools">smartmontools</a></h3>
<p><code>apt install smartmontools</code> <br />
<code>smartctl -a /dev/sda</code> тест диска и информация о модели и температуре <br />
<code>smartctl -H /dev/sda</code> SMART Health Status</p>
<h3 id="sensors"><a class="header" href="#sensors">sensors</a></h3>
<p><code>apt install lm-sensors</code> <br />
<code>sensors-detect</code> сканировать датчики температуры <br />
<code>sensors</code> отобразить датчики</p>
<h3 id="badblocks"><a class="header" href="#badblocks">badblocks</a></h3>
<p><code>badblocks -s /dev/sda</code> тест на наличие нечитаемых/битых блоков/секторов на диске</p>
<h3 id="hdparm"><a class="header" href="#hdparm">hdparm</a></h3>
<p><code>hdparm -I /dev/sda | grep -i model</code> модель жесткого диска (Model Number, Serial Number, Firmware Revision) <br />
<code>hdparm -v /dev/sda</code> кол-во секторов и настройки <br />
<code>hdparm -tT /dev/sda</code> тест скорости работы без кэша (-t) и с кэшем (-T) <br />
<code>hdparm -D /dev/sda</code> включение/отключение управления дефектами дисков <br />
<code>hdparm -r /dev/sda</code> включает режим read only для диска <br />
<code>hdparm -A /dev/sda</code> включает режим read-look-ahead, когда диск просматривается перед чтением, включена по умолчанию <br />
<code>hdparm -a /dev/sda</code> включает режим read-ahead, когда чтение выполняется в первую очередь, позволяет улучшить производительность чтения больших объемов данных <br />
<code>hdparm -b /dev/sda</code> остановить жесткий диск до следующего к нему обращения <br />
<code>hdparm -S 1 /dev/sda</code> остановить вращение мотора диска до следующего к нему обращения <br />
<code>hdparm -B 120 /dev/sda</code> настройка управления питанием Advanced Power Management (APM), чем ниже значение, тем лучше энергосбережение (255 - для отключения) <br />
<code>hdparm -Z /dev/sda</code> отключает режим энергосбережения <br />
<code>hdparm -M 128 /dev/sda</code> управление уровнем шума (принимает значения от 128 - более тихую работу, до 254 - высокую)</p>
<h2 id="disk"><a class="header" href="#disk">disk</a></h2>
<p><code>du -sh /home</code> отобразить общий размер указанной директории (-s) <br />
<code>du -Sh /home</code> отобразить общий размер всех дочерних (-S) директорий по пути <br />
<code>du -h /home</code> отображает общий размер указанной директории и подкаталогов внутри директории <br />
<code>du -ah /home</code> отобразить общий размер директории и всех дочерних файлов (-a) и директорий</p>
<p><code>lsblk</code> отображает список всех подключенных блочных устройств (/dev), их SIZE, TYPE (disk/part/lvm) и точку монтирования (MOUNTPOINTS) <br />
<code>lsblk -e7</code> вывод без loop <br />
<code>lsblk -f</code> отображает используемую FSTYPE, UUID, FSAVAIL - сколько свободно на диске и FSUSE - сколько занято на диске в процентах <br />
<code>lsblk -o NAME,MODEL,SERIAL,SIZE,STATE --nodeps | grep running</code> отображает модель, размер и статус без структуры разделов/lvm (--nodeps) <br />
<code>lsblk -E NAME</code> исключить дублирование вывода по колонке <br />
<code>lsblk -S</code> вывод информации о SCSI-устройствах (--scsi) <br />
<code>lsblk -b</code> выводить SIZE в байтах (--bytes) <br />
<code>lsblk -J</code> вывод в формате JSON (--json) <br />
<code>lsblk -P</code> использовать формат вывода key="value" <br />
<code>lsblk -m</code> выводить информацию о правах доступа</p>
<p><code>df -h</code> выводит информацию примонтированных файловых системах. Отображает общий объём (Size), занятого (Used) и свободно (Avail) пространства <br />
<code>df -h -T</code> отобразить Type файловой системы (ext4/cifs)</p>
<p><code>apt install duf</code> установить duf <br />
<code>duf</code> аналог df</p>
<p><code>mount | grep /dev/</code> отобразить все примонтированные файловые системы <br />
<code>mount | grep -P "mapper|lv|vg"</code> примонтированные lvm</p>
<p><code>findmnt</code> отобразить список смонтированных файловых систем в древовидном формате <br />
<code>findmnt -l</code> в формате списка <br />
<code>findmnt -t ext4</code></p>
<p><code>e2label /dev/sda3</code> узнать метку диска <br />
<code>blkid</code> отобразить список подключённых дисков, их UUID и TYPE <br />
<code>lsscsi</code> отобразить параметры SCSI устройств подключенных к системе</p>
<h3 id="parted"><a class="header" href="#parted">parted</a></h3>
<p><code>parted -l</code> отобразить список всех разделов на дисках <br />
<code>parted -l | grep -i model</code> <br />
<code>dd if=/dev/zero of=/tmp/disk.img count=1000 bs=1M</code> создать образ диска заполненный нулями размером 1Гб <br />
<code>parted /tmp/disk.img</code> передать parted созданный файл-образ для управления ФС <br />
<code>parted /dev/sdc</code> передать parted диск <br />
<code>mktable gpt</code> создать таблицу разделов GPT <br />
<code>print</code> отобразить тип таблицы (Partition Table: GPT) и список разделов на устройстве, если они были созданы <br />
<code>print free</code> отобразить свободное место и все разделы <br />
<code>mkpart primary ext4 0 500M</code> создать первый, первичный (primary) раздел с ФС ext4 размером 500Мб. <br />
<code>mkpart primary ext4 500 1000M</code> создать второй раздел (начало и конец) <br />
<code>resizepart 2 600M</code> уменьшить 2-й раздел до 100МБ (указывается end-конец) <br />
<code>resizepart 2 100%</code> увеличить до всего свободного размера <br />
<code>rm 2</code> удалить раздел</p>
<h3 id="fdisk"><a class="header" href="#fdisk">fdisk</a></h3>
<p><code>fdisk -l</code> отображает список всех подключенных устройств построчно с размером секторов для каждого раздела <br />
<code>fdisk -x</code> подробный вывод (узнать UUID разделов) <br />
<code>fdisk -l | grep /dev/sd</code> <br />
<code>fdisk -l | grep -E "/dev/sd.[1-9]"</code> <br />
<code>fdisk -l | grep -E "lv|vg"</code> <br />
<code>fdisk /dev/sdc</code> <br />
<code>m</code> список команд <br />
<code>p</code> отобразить размер диска и список разделов (/dev/sdc1) <br />
<code>n</code> создать новый раздел (p), указать номер раздела - partition number (4-128, default 4), начало и конце сектора - enter (оставить по умолчанию) <br />
<code>i</code> информация о выбранном разделе разделе (начало, конец, общий размер сектора и размер диска) <br />
<code>t</code> задать тип раздела - 30/8E (Linux LVM) или 20/83 (Linux filesystem) <br />
<code>l</code> отобразить список всех типов <br />
<code>w</code> сохранить <br />
<code>q</code> выход <br />
<code>partprobe /dev/sdc</code> информирует ядро ОС об изменениях таблицы разделов, запрашивая у системы, чтобы она перечитала таблицу разделов</p>
<h3 id="sfdisk"><a class="header" href="#sfdisk">sfdisk</a></h3>
<p><code>sfdisk -d /dev/sdc &gt; sdc.partition.table.txt</code> backup (аналогично dump cfdisk) <br />
<code>sfdisk -f /dev/sdc &lt; sdc.partition.table.txt</code> восстановить</p>
<p><code>sfdisk -d /dev/sda | sfdisk -f /dev/sdd</code> для восстановления MD RAID1 (sda в sdd) <br />
<code>mdadm --manage /dev/md1 --add /dev/sdd1</code> восстановление копирования <br />
<code>watch cat /proc/mdstat</code> отображать прогресс синхронизации</p>
<ul>
<li>Новый диск для расширения LVM:</li>
</ul>
<p><code>ls /dev/sd*</code> отобразить все диски в файловой системе <br />
<code>fdisk -l</code> отобразить все диски через fdisk <br />
<code>cfdisk /dev/sda</code> разметка диска на разделы (новый вариант) <br />
<code>cfdisk /dev/sdb</code> инициализировать новый диск, выбрать таблицу разделов (gpt) <br />
<code>new - sda4</code> создать новый раздел sda4 или sdb1 <br />
<code>Free space - Partition size: 100G</code> <br />
<code>write - yes</code> <br />
<code>pvcreate /dev/sda4</code> создать физический виртуальный том из раздела <br />
<code>vgextend ubuntu-vg /dev/sda4</code> добавить новый раздел в группу <br />
<code>lvextend -l +100%FREE /dev/ubuntu-vg/ubuntu-lv</code> добавить свободное место в группе для логического раздела ubuntu-lv <br />
<code>lsblk</code> <br />
<code>df -h</code> система будет видеть старый объем диска, необходимо выполнить команду по изменению размера файловой системы <br />
<code>df -T -h</code> отобразить тип ФС <br />
<code>resize2fs -f /dev/ubuntu-vg/ubuntu-lv</code> для ext* <br />
<code>btrfs filesystem resize +100g /</code> для btrfs</p>
<ul>
<li>Новый диск для нового раздела:</li>
</ul>
<p><code>cfdisk /dev/sdс</code> создать раздел (cfdisk/fdisk/parted) <br />
<code>mkfs.ext4 /dev/sdc1</code> форматировать раздел <br />
<code>mkdir /mnt/sdc1 &amp;&amp; mount /dev/sdc1 /mnt/sdc1</code> примонтировать раздел, -o -r - монтировать только на чтение (--options --read-only) <br />
<code>df -h &amp;&amp; lsblk</code> раздел нового диска должен быть в статусе Mounted on или MOUNTPOINTS <br />
<code>chmod 0777 /mnt/sdc1</code> разрешить всем пользователям доступ к диску <br />
<code>df -h -T</code> отображает тип файловой системы примонтированных разделов <br />
<code>nano /etc/fstab</code> сохранить монтирование после перезагрузкиы <br />
<code>/dev/sdc1 /mnt/sdc1 ext4 rw,relatime 0 0</code> добавить по наименованию или UUID устройства <br />
<code>umount /dev/sdc1</code> отмантировать раздел</p>
<h3 id="swap"><a class="header" href="#swap">swap</a></h3>
<p><code>fallocate -l 4G /swapfile.img</code> создать файл для swap <br />
<code>dd if=/dev/zero of=/swapfile.img count=1024 bs=1M</code> создать файл для swap <br />
<code>chmod 600 /swapfile.img</code> дать права <br />
<code>mkswap /swapfile.img</code> создать swap-пространство из файла или используя весь объём раздела (mkswap /dev/sda4) <br />
<code>swapon /swapfile.img</code> активировать swap-пространство <br />
<code>echo '/swapfile.img none swap sw 0 0' | sudo tee -a /etc/fstab</code> примонтировать <br />
<code>free -m</code> отобразить объём <br />
<code>swapoff -a</code> отключить <br />
<code>rm /swapfile.img</code> удалить файл</p>
<h2 id="lvm"><a class="header" href="#lvm">lvm</a></h2>
<p><strong>Logical Volume Management</strong> - управление логическими томами, это дополнительный слой абстракции от железа, позволяющий собрать несколько разных дисков в один, и затем разбить его на группы и разделы. Позволяет использовать программный RAID 0 и 1 (зеркалирование) с управляемым пространством, снапшотами и импортированием томов в другую систему.</p>
<ul>
<li>PV (Physical Volume) — физические тома</li>
</ul>
<p><code>pvs</code> отображает список Physical Volume <br />
<code>pvdisplay</code> подробная информация <br />
<code>pvcreate /dev/sdb</code> инициализация диска в LVM как физический том</p>
<ul>
<li>VG (Volume Group) — группы томов, для объединения физических томов и создания общего логического диска, который будет разбиватсья на разделы</li>
</ul>
<p><code>vgs</code> отображает список Volume Group <br />
<code>vgdisplay</code> подробная информация <br />
<code>vgcreate vg21 /dev/sdb</code> создать группу томов с добавлением физического тома на диске sdb</p>
<ul>
<li>LV (Logical Volume) — логические разделы</li>
</ul>
<p><code>lvs</code> отображает список Logic Volume и их объём <br />
<code>lvdisplay</code> подробная информация <br />
<code>lvcreate -n boot -L 1G vg21</code> создать первый логический раздел с наименованием boot <br />
<code>lvcreate -n home -L 9G vg21</code> создать второй логический раздел с наименованием home <br />
<code>lvcreate -n lv21 -l+100%FREE vg21</code> создать один логический раздел lv21 для группы томов vg21 и назначить ему весь объем диска <br />
<code>mkfs -t ext4 /dev/vg21/lv21</code> назначить файловую систем ext4 <br />
<code>mkdir /mnt/lv21</code> создать папку для монтирования <br />
<code>mount /dev/vg21/lv21 /mnt/lv21</code> примонтировать раздел к созданной папке <br />
<code>echo "/dev/vg21/lv21 /mnt/lv21 ext4 defaults 0 0" &gt;&gt; /etc/fstab</code> добавить монтирование в автозагруку</p>
<ul>
<li>Увеличить</li>
</ul>
<p>Расширение физического раздела можно сделать за счет добавление нового диска путём добавления в группу или увеличением имеющегося виртуального диска. <br />
<code>pvcreate /dev/sdc</code> eсли добавлен новый диск, инициализируем (минус: если один из дисков выходит из строя, данные будут не доступны, аналогично работе RAID 0) <br />
<code>pvresize /dev/sdb</code> если увеличин объем дискового пространства виртуального диска (resize - изменить размер физического тома) <br />
<code>vgextend vg21 /dev/sdc</code> расширить группу vg21 за счет добавленного диска sdc (или vgdisplay) <br />
<code>vgs</code> отобразит у какой из групп всего памяти VSize и сколько доступно памяти VFree для распредиления логическим разделам памяти, которую расширили <br />
<code>lvextend -l +100%FREE /dev/vg21/lv21</code> добавить все свободное простраство логическому разделу <br />
<code>vgs</code> VFree будет=0 а в lsblk объём раздела увеличится <br />
<code>lvextend -L+1G /dev/vg21/lv21</code> добавить 1Гб от группы томов vg21 разделу lv21 <br />
<code>lvextend -L500G /dev/vg21/lv21</code> добавить до конкретного размера диска 500Гб <br />
<code>lvs</code> проверить <br />
<code>df -T</code> отобразить используемую ФС <br />
<code>resize2fs /dev/vg01/lv01</code> изменить размер для файловой системы ext4</p>
<ul>
<li>Уменьшить</li>
</ul>
<p><code>e2fsck -fy /dev/vg21/lv21</code> проверка диска <br />
<code>resize2fs /dev/vg21/lv21 500M</code> уменьшить размер ФС на 500Мбайт <br />
<code>lvreduce -L-500 /dev/vg21/lv21</code> уменьшить размер логического тома на 500Мбайт <br />
<code>vgs</code> добавится VFree 500m для распределения другой логической группе</p>
<p><code>resize2fs /dev/ubuntu-vg/ubuntu-lv 1G</code> уменьшить размер ФС на 500Мбайт <br />
<code>lvreduce -L-1000 /dev/ubuntu-vg/ubuntu-lv</code> уменьшить размер логического тома на 1000Мбайт (Logical volume ubuntu-vg/ubuntu-lv successfully resized) <br />
<code>vgs</code> VFree 1000.00m</p>
<ul>
<li>Удалить</li>
</ul>
<p><code>umount /dev/vg21/lv21</code> предварительно отмантировать <br />
<code>lvremove /dev/vg21/lv21</code> удалить логический том <br />
<code>lvs</code> нет групп <br />
<code>vgs</code> VSize и VFree объём совпадает <br />
<code>vgremove vg21</code> удалить группу томов <br />
<code>pvremove /dev/sdb</code> удалить диск sdb из LVM</p>
<ul>
<li>RAID 1</li>
</ul>
<p>Новый диск sdc разбить на 2 раздела (основной sdc1, немного больше чем у целевого зеркалируемого раздела lv21 и sdc2 оставшийся объем для ведения файла журнала) <br />
<code>pvcreate /dev/sdc1 /dev/sdc2</code> добавить оба раздела в LVM <br />
<code>vgextend vg21 /dev/sdc1 /dev/sdc2</code> добавить в имеющиюся группу vg21 (расширить группу vg21) <br />
<code>vgs</code> у группы vg21 VFree увеличится объём добавленных томов-разделов <br />
<code>lvconvert -m1 /dev/vg21/lv21 /dev/sdb /dev/sdc1 /dev/sdc2</code> конвертируем логический том lv21, входящий в состав группы vg21 в зеркалируемый том (-m1), зеркалируется /dev/sdb (где находится lv21) на sdс1, а /dev/sdс2 используется для ведения файла журнала.</p>
<p><code>lvs -a -o +devices</code> раздел lv21 пишет на 2 устройства</p>
<pre><code>[lv21_rimage_0] /dev/sdb(0) # основной том
[lv21_rimage_1] /dev/sdc1(1) # зеркало
</code></pre>
<p><code>lsblk</code></p>
<pre><code>sdb                     8:16    0    4G  0 disk
+-vg21-lv21_rmeta_0    253:0    0    4M  0 lvm
¦ L-vg21-lv21          253:4    0    2G  0 lvm
L-vg21-lv21_rimage_0   253:1    0    2G  0 lvm
  L-vg21-lv21          253:4    0    2G  0 lvm
sdc                     8:32    0    4G  0 disk
+-sdc1                  8:33    0    3G  0 part
¦ +-vg21-lv21_rmeta_1  253:2    0    4M  0 lvm
¦ ¦ L-vg21-lv21        253:4    0    2G  0 lvm
¦ L-vg21-lv21_rimage_1 253:3    0    2G  0 lvm
¦   L-vg21-lv21        253:4    0    2G  0 lvm
</code></pre>
<p>Извлекаем (удаляем) <code>sdb</code> (оригинальный диск) <br />
<code>lsblk</code> отображает только два раздела (part) sdc1 и sdc2 зеркального диска без LVM, т.к. группа не активна <br />
Командой <code>lvs</code> видим группу <code>vg21</code> и ошибки:</p>
<pre><code>WARNING: Couldn't find device with uuid stBI99-6Qs3-B8lr-Ekaw-ahnD-oxPc-LsayLR.
WARNING: VG vg21 is missing PV stBI99-6Qs3-B8lr-Ekaw-ahnD-oxPc-LsayLR (last written to /dev/sdb).
</code></pre>
<p><code>vgchange -ay vg21</code> активировать группу <br />
<code>mount /dev/vg21/lv21 /mnt/lv21</code> примонтировать группу lv21</p>
<ul>
<li>Snapshot</li>
</ul>
<p><code>lvs</code> <br />
<code>lvcreate -L 1G -s -n snap-1 /dev/ubuntu-vg/ubuntu-lv</code> предварительно нужно добавить VFree в Volume Group (Logical volume "snap-1" created) <br />
<code>lvcreate -L 1G -s -n snap-1 /dev/vg21/lv21</code> параметр -s помечает, что 1Гб дискового пространства из группы vg21 будет использоваться для snapshot lv21  <br />
<code>lvs</code> Origin - к какому логическому тому (lv) относиться snapshot, Data% — процент исползованного объема от выделенного. <br />
<code>lsblk</code> отображает изменения в томах разделов <br />
<code>mount /dev/vg21/snap-1 /mnt/snap</code> содержимое снапшота можно смонтировать как обычный раздел, если отредактивароть снапшот и откатиться к нему, мы получим те данные, которые отредактировали <br />
<code>lvconvert --merge /dev/vg21/snap-1</code> откатиться к снапшоту snap-1, понадобится перезагрузка ОС (даже если это не основной диск)</p>
<ul>
<li>Export/Import</li>
</ul>
<p><code>umount /dev/vg21/lv21</code> отмантировать <br />
<code>vgchange -an vg21</code> деактивировать группу томов (0 logical volume в volume group "vg21") <br />
<code>vgexport vg21</code> экспортировать группу (successfully exported) <br />
<code>pvdisplay</code> список групп (VG Name vg21 (exported)) <br />
Переносим диск на новый компьютер: <br />
<code>pvscan</code> сканировать группы на новой системе (PV /dev/sdb is in exported VG vg21) <br />
<code>vgimport vg21</code> импортировать в систему (successfully imported) <br />
<code>vgs и lvs</code> проверить группы <br />
<code>vgchange -ay vg21</code> активировать группу (1+ lg в vg "vg21") <br />
<code>lsblk</code> проверить подключение LVM</p>
<h2 id="md"><a class="header" href="#md">md</a></h2>
<blockquote>
<p>SOFT RAID</p>
</blockquote>
<p><code>mdadm --zero-superblock --force /dev/sd{b,c}</code> занулить все суперблоки на дисках, которые будут добавлены в RAID-массив, т.к. диски могут содержать служебную информацию о других RAID (вывод: unrecognised md component device - ни один из дисков ранее не был добавлен в массив) <br />
<code>mdadm --create --verbose /dev/md0 -l 1 -n 2 /dev/sd{b,c}</code> создать зеркальный RAID1 (-l/--leve 1) и указать кол-во дисков (-n/--raid-devices) <br />
<code>mkfs.ext4 /dev/md0</code> форматировать в fs ext4 <br />
<code>mkdir /md0-sdb-sdc-raid1</code> создать директорию для монтирования <br />
<code>mount /dev/md0 /md0-sdb-sdc-raid1</code> примонтировать вручную <br />
<code>lsblk -o NAME,UUID | grep md*</code> отобразить UUID устройства <br />
<code>echo "UUID=20482c47-fa11-462d-b7b8-93a342a7edf8 /md0-sdb-sdc-raid1 ext4 defaults 1 2" &gt;&gt; /etc/fstab</code> добавить в автозагрузку по UUID, т.к. после перезагрузки ОС номер может измениться на md127 <br />
<code>mount -a</code> примонтировать все файловые системы из fstab <br />
<code>cat /proc/mdstat</code> проверить состояние всех доступных RAID-массивов: md127 : active raid1 sdc[1] sdb[0] <br />
<code>mdadm -D /dev/md127</code> подробное (--detail) состояние массива. State: cleane (проблем нет)/degraded (диск неисправен/поврежден). Active/Working/Failed/Spare Devices - количество активных (в работе)/рабочих/нерабочих/запасных дисков в массиве. Consistency Policy - тип синхронизации после сбоя в массиве (resync - полная синхронизация после восстановления массива). <br />
<code>mdadm /dev/md127 --add /dev/sdd</code> добавить запасной диск (в Spare Device) для горчей замены (Hot-Spare), в статусе списка дисков будет указан какой диск (State - spare /dev/sdd) <br />
<code>mdadm -G /dev/md127 —raid-devices=3</code> расширить массив до трех дисков (добавится из запасных дисков в активный в массив) <br />
<code>mdadm /dev/md127 --fail /dev/sdb</code> пометить рабочий диск как нерабочий (перевести диск в Failed Device) для замены на запасной из Spare Device, который начнет автоматическую синхронизацию для ввода в массив (Rebuild Status : 50% complete) <br />
<code>mdadm /dev/md127 --remove /dev/sdb</code> удалить нерабочий диск из массива <br />
<code>mdadm --stop /dev/md127</code> остановить/разобрать массив (предварительно umount /md0-sdb-sdc-raid1). В случае, если один из двух дисков был извлечен и не было запасных дисков, массив будет остановлен автоматически (State : inactive) <br />
<code>mdadm --assemble --scan --verbose</code> команда просканирует все диски на наличие разобранного/развалившегося RAID-массива и самостоятельно (автоматически) попытается восстановить из них массив с изначальным именем (mdadm -D /dev/md0) <br />
<code>mdadm --stop /dev/md127 &amp;&amp; mdadm --assemble --scan &amp;&amp; mount -a &amp;&amp; mdadm -D /dev/md0</code> если в системе остался один диск (второй извлечен), RAID-массив будет востановлен (пересобран) автоматически из одного диска с статусом: clean, degraded, можно сразу добавить новый диск для автоматической синхронизации данных <br />
<code>mdadm --assemble /dev/md127 /dev/sdb /dev/sdc</code> указать вручную из каких дисков пересобрать массив <br />
<code>echo 'check' &gt; /sys/block/md127/md/sync_action</code> проверять целостность данных в массиве (mdadm -D /dev/md0 - Check Status : 80% complete) <br />
<code>cat /sys/block/md127/md/mismatch_cnt</code> вывод файла (0 - все впорядке) <br />
<code>echo 'idle' &gt; /sys/block/md127/md/sync_action</code> остановить проверку</p>
<h2 id="tgt"><a class="header" href="#tgt">tgt</a></h2>
<blockquote>
<p>iSCSI</p>
</blockquote>
<p><code>apt install tgt</code> серверная часть называется порталом, который содержит цели (Target), каждая из которых предоставляет клиенту - инициатору (Initiator) доступ к блочным устройствам. <br />
<code>dd if=/dev/zero of=/storage/disk1.img bs=1 count=0 seek=200G</code> создание динамического диска (разреженный файл) с максимальным размером 200 ГБ, где вместо последовательности нулей на диске хранят информацию об этих последовательностях в специальной таблице <br />
<code>dd if=/dev/zero of=/storage/disk1.img bs=1M count=2048</code> создание фиксированного размера диск <br />
<code>cp --sparse=always filename newfilename</code> преобразование обычного файла в разреженный <br />
<code>nano /etc/tgt/targets.conf</code> <br />
<code>nano /etc/tgt/conf.d/disk-1.conf</code></p>
<pre><code>&lt;target iqn.2023-10.local.domain:ubuntu-target&gt; 
   backing-store /storage/disk1.img 
   initiator-address 192.168.3.101
   incominguser user password1212
&lt;/target&gt;
</code></pre>
<p><code>systemctl restart tgt</code> <br />
<code>tgtadm --mode target --op show</code> отобразит все подключенные цели и предоставляемые ими блочные устройства.</p>
<h2 id="dd"><a class="header" href="#dd">dd</a></h2>
<p><code>dd if=/dev/sr0 of=/tmp/cd.iso bs=2048</code> сохранить образ диска (if=источник) в файл (of=назначение) с указанием кол-ва байт для чтения и записи за один раз (2МБайт), по умолчанию используется размер блока - 512 байт (2b блока = 1024 байт, 1k = 1 КБайт/1024 байт, 1kB = 1000 байт, 1M = 1024 КБайт/1 МБайт) <br />
<code>dd if=/dev/mem bs=2048 count=100</code> вывести содержимое оперативной памяти на экран (не использовать файл) <br />
<code>dd if=/dev/zero of=/tmp/md-01 bs=4M count=256</code> создать файл заполненный нулями (из /dev/zero) размером 1ГБ с указанием кол-во копируемых блоков (bs*count) или очистить диск <br />
<code>dd if=/dev/random of=/tmp/md-02 bs=4M count=256</code> создать файл размером 1ГБ заполненный рандомными цифрами <br />
<code>dd if=/dev/sda of=/tmp/mbr.img bs=1b count=1</code> скопировать в файл первые 512 байт диска содержащие таблицу разделов MBR <br />
<code>dd if=/dev/sda of=/tmp/sda.img</code> создать образ жесткого диска, используетася для полного backup системы (копирование раздела на двоичном уровне,включая таблицу MBR и всю пустую область диска и разделов)</p>
<h3 id="backup"><a class="header" href="#backup">backup</a></h3>
<ul>
<li>Смонтировать внешний носитель для создания образа: <code>mount /dev/sdb1 /mnt/disk_b</code></li>
<li><code>dd if=/dev/sda of=/mnt/disk_b/disk.img bs=5M</code> создать образа диска (.img) # создаем образ системы</li>
<li>Подключить новый диск для записи образа на диск (<code>sdc</code>)</li>
<li><code>dd if=/mnt/disk_b/disk.img of=/dev/sdc bs=5M</code> записать образ на диск (с sdb1 на sdc):</li>
<li>Извлечь физический ЖД или удалить виртуальный диск sda (системный) и <code>sdb</code> (с записью образа). Диск <code>sdc</code> с копией системы автоматически инициализируется как диск <code>sda</code> после перезагрузки системы.</li>
<li><code>gzip disk.img</code> сжать образ (все нули сожмутся полностью - удобно для хранения backup, поддерживает только .img)
<code>dd if=/dev/sda conv=sync,noerror bs=5M | gzip -c  &gt; /mnt/disk_b/disk.img.gz</code> создать сжатый образ системы <br />
<code>gunzip -c /mnt/disk_b/disk.img.gz | dd of=/dev/sdс</code> развернуть образ на диск</li>
</ul>
<p><code>nc -lp 5000 | sudo dd of=/backup/sda.img.gz</code> сохранение сжатого файла образа жесткого диска sdb на удаленном сервере (принимающая сторона) <br />
<code>dd if=/dev/sda | gzip -c | nc 192.168.21.121 5000</code> на узле, у которого установлен жесткий диск (передающая сторона) <br />
<code>nc -lp 5000 | gunzip -c | sudo dd of=/dev/sdb</code> восстановление содержимого жесткого диска из сжатого образа (записывать не на системный диск), сохраненного на удаленном сервере на локальном узле (принимающая сторона) <br />
<code>cat /backup/sda.img.gz | nc my_local_host.com 5000</code> на удаленном сервере, на котором сохранен файл образа жесткого диска (передающая сторона)</p>
<h3 id="iso"><a class="header" href="#iso">iso</a></h3>
<p><code>dd if=/dev/sda3 status=progress of=/mnt/disk_b/disk.iso bs=5M</code> создать iso-образ (сохранить образ раздел) <br />
<code>dd if=путь/к/образу.iso of=/dev/sdb1</code> записать ISO-образ ОС на внешнее устройство <br />
<code>sync</code> завершить запись этой командой (что бы при извлечении не потерять часть данных) <br />
<code>mount -o loop /mnt/disk_b/disk.iso /mnt/iso</code> примонтировать файл образа только для чтения (iso - это директория, которую предварительно нужно создать), подключается как /dev/loop6 <br />
<code>umount /mnt/iso</code> отмантировать</p>
<h3 id="rdiff"><a class="header" href="#rdiff">rdiff</a></h3>
<p><code>apt install rdiff-backup</code> на базе rsync с поддержкой инкрементных архивов используя технологию hard link, чтобы вернуться назад на заданный день <br />
<code>rdiff-backup /usr/lifailon/ /backup/test/</code> <br />
<code>rdiff-backup user@hostname::/remote-dir local-dir -v5 --print-statistics</code> по ssh с сервера на локальный бэкап-сервер, в ней же будет находиться директория rdiff-backup-data, которая будет содержать информацию и логи о проводимых бэкапах, а также инкременты, необходимые для отката на любой прошлый выполненный бэкап <br />
<code>rdiff-backup list files --changed-since 5D local-dir</code> отобразить, какие файлы изменились за последние 5 дней <br />
<code>rdiff-backup list files --at 5D local-dir</code> отобразить список файлов, которые присутствовали в архиве 5 дней назад <br />
<code>rdiff-backup restore local-dir/rdiff-backup-data/increments.2023-10-29T21:03:37+03:00.dir /tmp/restore</code> восстановить файлы из инкримента</p>
<h2 id="users"><a class="header" href="#users">users</a></h2>
<p><code>sudo -u www-data</code> выполнить команду от имени другого пользователя <br />
<code>su root</code> войти под пользователем root <br />
<code>sudo su</code> изменить пользователя на root, при этом пользователь остается в той же директории потому, что выполняется ваш .bashrc. А также .profile пользователя root поэтому вы окажетесь в окружении root <br />
<code>sudo -i</code> указывает утилите что нужно переключиться в консоль от имени root, при этом перемещаясь в домашний каталог root, и будет выполнен его .bashrc и .profile <br />
<code>sudo /bin/bash</code> запускает еще одну оболочку bash от имени суперпользователя. Файлы конфигурации не читаются, но выполняется только .bashrc вашего пользователя. Вы не окажетесь в окружении root, а просто останетесь в своем окружении с правами суперпользователя</p>
<p><code>cat /etc/passwd</code> список/база данных пользователей зарегистрированных в системе <br />
<code>cat /etc/group</code> список групп <br />
<code>cat /etc/shadow | grep -Ev "^.+:\*:"</code> пароли пользователей хранящиеся в зашифрованном виде (заданные с помощью /usr/bin/passwd), если * или ! пользователь не сможет войти в систему с использованием аутентификации по паролю, другие методы входа, как аутентификация на основе ключей или переключение на пользователя разрешены. Синтаксис: логин:пароль:последнее изменения пароля (количество дней исчисляется с 1 января 1970 года):минимальный срок действия пароля:максимальный срок действия:период предупреждения:период бездействия:срок хранения</p>
<p><code>cat /etc/login.defs | grep -Pv "^$|^#"</code> настройка поведения утилиты управления пользователями и параметрами входа в систему (настройки минимального и максимального id для выдачи новому пользователю/группе, количество попыток входа, таймау, что делать с директорий пользователя при создании или удалении и т.п.) <br />
<code>cat /etc/login.defs | grep "^PASS"</code> максимальное кол-во дней действия пароля (PASS_MAX_DAYS), минимальное количество дней допустимое между сменами пароля (PASS_MIN_DAYS), количество дней предупреждающих об истечении срока действия пароля (PASS_WARN_AGE), ограничения длины паролей (PASS_MIN_LEN/PASS_MAX_LEN), максимальное кол-во попыток входа при вводе неправильного пароля (LOGIN_RETRIES), время на вход (LOGIN_TIMEOUT), включить логирование успешных входов (LOG_OK_LOGINS), логирование неизветных имен для системы пользователей при неудачных попытках входа (LOG_UNKFAIL_ENAB)</p>
<h3 id="passwd"><a class="header" href="#passwd">passwd</a></h3>
<p><code>passwd</code> включить учетную запись root и задать ей пароль <br />
<code>passwd username</code> смена пароля пользователя <br />
<code>passwd -l username</code> заблокировать уч. запись <br />
<code>passwd -u username</code> разблокировать уч. запись</p>
<h3 id="chage"><a class="header" href="#chage">chage</a></h3>
<p><code>chage -l root</code> информация последней смене пароля и срок действия (последняя смена пароля, Срок действия пароля, Пароль неактивен, Срок действия учетной записи, Минимальное количество дней между сменой пароля, Максимальное количество дней между сменой пароля, Количество дней предупреждения до истечения срока действия пароля) <br />
<code>chage -E lifailon</code> установить дату истечения срока действия пользовательской учетной записи (-E) <br />
<code>chage lifailon -M 30</code> установки минимального (-m) и максимального (-M) срока действия пароля</p>
<h3 id="id"><a class="header" href="#id">id</a></h3>
<p><code>id lifailon</code> узнать ID <br />
<code>uid=1000(lifailon) gid=1000(lifailon) groups=1000(lifailon),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lxd)</code> <br />
<code>usermod -u 1022 kup</code> изменить UID <br />
<code>groupmod -g 1022 kup</code> изменить GID</p>
<h3 id="usermod"><a class="header" href="#usermod">usermod</a></h3>
<p><code>usermod -L lifailon</code> заблокировать вход по паролю (перед паролем пользователя в файле /etc/shadow добавляется восклицательный знак) <br />
<code>usermod --expiredate 1 -L lifailon</code> заблокировать пользователя (не будет возможности авторизоваться через su: Authentication failure) <br />
<code>usermod --expiredate 2023-10-25 lifailon</code> задать дату блокировки <br />
<code>usermod --expiredate "" -U lifailon</code> разблокировать пользователя <br />
<code>usermod -g root lifailon</code> изменить основную группу пользователя <br />
<code>usermod -a -G plugdev lifailon</code> добавить пользователя в дополнительную группу (-G), обязательно нужно использовать вместе с -a, чтобы не удалять старые <br />
<code>usermod -d /root lifailon</code> изменить домашнюю директорию пользователя (-d) <br />
<code>usermod -m -d /root lifailon</code> переместить домашнюю папку сохранив все содержимое (-m) <br />
<code>usermod -s /usr/bin/dash lifailon</code> изменить оболочку по умолчанию (-s) <br />
<code>usermod -u 2002 lifailon</code> изменить id пользователя (-u) <br />
<code>usermod -l lifailon failon</code> изменить имя пользователя (-l) <br />
<code>usermod --password "NewPassword" lifailon</code> изменить пароль</p>
<h3 id="profile"><a class="header" href="#profile">profile</a></h3>
<p><code>nano /etc/bash.bashrc</code> задать timeout для завершения бездейстующих (idle time) SSH и локальных сессий <br />
<code>nano /etc/profile</code> задать на уровне профиля (приоритет ниже)</p>
<pre><code>TMOUT=1440
readonly TMOUT
export TMOUT
</code></pre>
<h3 id="bashrc-1"><a class="header" href="#bashrc-1">bashrc</a></h3>
<p><code>.bashrc</code> файл переменных конкретного пользователя <br />
<code>.bash_profile</code> переменные вступают в силу каждый раз когда пользователь подключается удаленно по SSH. Если этот файл отсутствует система будет искать .bash_login или .profile <br />
<code>/etc/environment</code> файл для создания, редактирования и удаления каких-либо переменных окружения на системном уровне. Переменные окружения, созданные в этом файле доступны для всей системы, для каждого пользователя и даже при удаленном подключении. <br />
<code>/etc/bash.bashrc</code> файл выполняется для каждого пользователя, каждый раз когда он создает новую терминальную сессию. Это работает только для локальных пользователей, при подключении через интернет, такие переменные не будут доступны. <br />
<code>/etc/profile</code> системный файл profile, все переменные из этого файла, доступны любому пользователю в системе, только если он вошел удаленно. Но они не будут доступны, при создании локальной терминальной сессии, то есть если вы просто откроете терминал.</p>
<h3 id="useradd"><a class="header" href="#useradd">useradd</a></h3>
<p><code>useradd -D</code> отобразить параметры, которые будут применены для пользователя по умолчанию <br />
<code>useradd -o -u 0 -g 0 -s /bin/bash newroot</code> создать нового пользователя с правами root <br />
<code>useradd -G adm,wheel -p password -s /bin/bash test2</code> разрешить пользователю читать логи и пользоваться sudo</p>
<p><code>useradd username</code> <br />
<code>-s</code> указать командную оболочку для пользователя (по умолчанию /bin/sh - без оболочки, можно указать /bin/bash) <br />
<code>-b</code> указать базовый каталог для размещения домашнего каталога пользователя (по умолчанию /home) <br />
<code>-d</code> домашний каталог, в котором будут размещаться файлы пользователя <br />
<code>-m</code> создавать домашний каталог пользователя, если он не существует <br />
<code>-c</code> комментарий к учетной записи <br />
<code>-g</code> основная группа пользователя <br />
<code>-G</code> список дополнительных групп <br />
<code>-N</code> не создавать группу с именем пользователя <br />
<code>-p</code> задать пароль пользователя <br />
<code>-l</code> не сохранять информацию о входах пользователя в lastlog и faillog <br />
<code>-o</code> разрешить создание пользователя linux с неуникальным идентификатором UID <br />
<code>-u</code> идентификатор для пользователя</p>
<h3 id="adduser"><a class="header" href="#adduser">adduser</a></h3>
<p><code>adduser username</code> интерактивное создание пользователя, по умолчанию будет создан домашний каталог (/home/username), можно указать данные о пользователе или пропустить и задать пароль <br />
<code>deluser username</code> удалить пользователя (каталог не удаляется)</p>
<h2 id="chmod"><a class="header" href="#chmod">chmod</a></h2>
<pre><code>    -                    ---                          ---         ---
    |                     |                            |           |
тип файла   права доступа пользователя (владельца)   группы   всех остальных
</code></pre>
<p><code>---</code> нет прав <br />
<code>--x</code> разрешено только выполнение файла, как программы но не изменение и не чтение <br />
<code>-w-</code> разрешена только запись и изменение файла <br />
<code>-wx</code> разрешено изменение и выполнение, в случае с каталогом нельзя посмотреть его содержимое <br />
<code>r--</code> права только на чтение <br />
<code>r-x</code> только чтение и выполнение, без права на запись <br />
<code>rw-</code> права на чтение и запись, но без выполнения <br />
<code>rwx</code> все права <br />
<code>--s</code> установлен SUID или SGID бит, первый отображается в поле для владельца, второй для группы <br />
<code>--t</code> установлен sticky-bit, значит пользователи не могут удалить этот файл</p>
<p><code>r</code> чтение <br />
<code>w</code> запись <br />
<code>x</code> выполнение <br />
<code>s</code> выполнение  от имени суперпользователя (дополнительный)</p>
<p><code>u</code> пользователь-владелец файла <br />
<code>g</code> группа-владельц файла <br />
<code>o</code> все остальные пользователи</p>
<p><code>+</code> включить <br />
<code>-</code> отключить</p>
<p><code>-R</code> поменять права на все подкаталоги и файлы указанной директории <br />
<code>-v</code> выводить информацию обо всех изменениях</p>
<p><code>chmod u+x filename</code> разрешить выполнение (x) для владельца (u) <br />
<code>chmod ugo+x filename</code> разрешить выполнение (x) для всех (ugo) <br />
<code>chmod ug+r filename</code> разрешить чтение (r) для владельца (u) и группы (g) <br />
<code>chmod o-w filename</code> запретить запись (w) для остальных пользователей (o) <br />
<code>chmod -R g+rwx dir </code> дать полный доступ (rwx) группе (g) на директорию и всем файлам в ней (-R)</p>
<p>Права доступа в восьмеричной системе, которые полностью переписывают текущие права новыми для всех категорий пользователей:</p>
<p><code>0</code> никаких прав <br />
<code>1</code> только выполнение <br />
<code>2</code> только запись <br />
<code>3</code> выполнение и запись <br />
<code>4</code> только чтение <br />
<code>5</code> чтение и выполнение <br />
<code>6</code> чтение и запись <br />
<code>7</code> чтение, запись и выполнение</p>
<p><code>chmod 744 filename</code> разрешить полные права для владельца, а остальным только чтение <br />
<code>chmod 664 filename</code> чтение и запись для владельца и группы, только чтение для остальных</p>
<h3 id="chown"><a class="header" href="#chown">chown</a></h3>
<p><code>chown lifailon tmp</code> изменить владельца на пользователя lifailon для директории tmp <br />
<code>chown lifailon:lifailon tmp</code> изменить владельца и группу <br />
<code>chown -R lifailon:lifailon tmp</code> применить изменения ко всем подкаталогам (-R) <br />
<code>chown --from=root:root lifailon:lifailon -R ./</code> изменить владельца и группу только для тех каталогов и файлов, у которых владелец и группа root в текущем каталоге</p>
<h3 id="groups"><a class="header" href="#groups">groups</a></h3>
<p><code>groups lifailon</code> отобразить в каких группах находится указанный пользователь <br />
<code>touch testdir</code> при создании файла ему назначается основная группа пользователя который его создал (ls -l testdir) <br />
<code>cat /etc/group</code> список групп <br />
<code>chgrp testdir tmp</code> изменить группу на testdir для директории tmp <br />
<code>groupadd testdir</code> создать группу <br />
<code>delgroup testdir</code> удалить группу, если ошибка 'testdir' still has <code>testdir' as their primary group!</code> предварительно исключить из группы всех пользователей</p>
<p>Опции: <br />
<code>-g</code> изменить основную группу для пользователя <br />
<code>-G</code> дополнительные группы, в которые нужно добавить пользователя (затирает предыдущие) <br />
<code>-a</code> добавить пользователя в дополнительные группы c параметром -G, а не заменять им текущее значение <br />
<code>-R</code> удалить пользователя из группы</p>
<h3 id="usermod-1"><a class="header" href="#usermod-1">usermod</a></h3>
<p><code>usermod -aG sudo lifailon</code> добавить пользователя в дополнительную группу (-aG, без затирания предыдущих групп) sudo (добавить в группу root) <br />
<code>usermod -aG disk lifailon</code> пользователь будет иметь прямой доступ к ЖД без команды sudo (например монтировать) <br />
<code>usermod -g root lifailon</code> изменить основную группу (-g) для пользователя на root <br />
<code>usermod -R ssh lifailon</code> удалить пользователя из группы</p>
<h2 id="domain"><a class="header" href="#domain">domain</a></h2>
<h3 id="realmd"><a class="header" href="#realmd">realmd</a></h3>
<p><code>hostnamectl</code> <br />
<code>hostnamectl set-hostname srv-01.domain.local</code> изменить имя сервера (/etc/hostname)</p>
<p><code>nano /etc/resolv.conf</code> <br />
<code>nameserver 192.168.3.233</code> адрес DC <br />
<code>search domain.local</code></p>
<p><code>apt -y install realmd libnss-sss libpam-sss sssd sssd-tools adcli samba-common-bin oddjob oddjob-mkhomedir packagekit</code> <br />
<code>nano /etc/realmd.conf</code> задать атрибуты хоста, которые будут сохранены в учетной записи компьютера в AD (атрибуты operatingSystem и operatingSystemVersion)</p>
<pre><code>[active-directory]
os-name = Ubuntu Server
os-version = 20.04
</code></pre>
<p><code>realm discover domain.local --verbose</code> возвращает полную конфигурацию домена и список пакетов, которые должны быть установлены для регистрации системы в домене <br />
<code>realm join --help | grep pass</code> <br />
<code>realm join -U username domain.local</code> --one-time-password<code>ввести в домен \ </code>realm list<code>проверить после подключения (server-software: active-directory) \ </code>id username@domain.local` получить сведения о пользователе домена</p>
<h3 id="sssd"><a class="header" href="#sssd">sssd</a></h3>
<p>Права доступа на логирование в Linux из под УЗ домена (sssd используется для аутентификации Kerberos)</p>
<p><code>realm permit -g 'ssh-connect-domain'</code> добавит доменную группу (echo "simple_allow_groups = ssh-connect-domain" &gt;&gt; /etc/sssd/sssd.conf) <br />
<code>realm permit username@domain.local</code> добавит пользователя (echo "simple_allow_users = username" &gt;&gt; /etc/sssd/sssd.conf) <br />
<code>realm deny --all</code> запретить доступ всем пользователям (очищает список simple_allow_* в sssd.conf) <br />
<code>systemctl restart sssd</code></p>
<p>Создавать домашний каталог для нового доменного пользователя:</p>
<pre><code>bash -c "cat &gt; /usr/share/pam-configs/mkhomedir" &lt;&lt;EOF
Name: activate mkhomedir
Default: yes
Priority: 900
Session-Type: Additional
Session:
required pam_mkhomedir.so umask=0022 skel=/etc/skel
EOF
</code></pre>
<p><code>pam-auth-update</code> обновить конфигурацию, выбрать созданную: activate mkhomedir</p>
<p>Права на sudo:</p>
<p><code>nano /etc/sudoers.d/domain_admins</code> nano /etc/sudoers.d/linux-admins</p>
<pre><code>username@domain.local               ALL=(ALL)       ALL
%ssh-connect-domain@domain.local    ALL=(ALL)       ALL
</code></pre>
<p><code>ssh username@domain.local@hostname</code></p>
<h2 id="syslog"><a class="header" href="#syslog">syslog</a></h2>
<h3 id="server"><a class="header" href="#server">server</a></h3>
<p><code>systemctl status rsyslog</code></p>
<p><code>nano /etc/rsyslog.conf</code></p>
<pre><code># provides UDP syslog reception (input module udp)
module(load="imudp")
input(type="imudp" port="514")
# provides TCP syslog reception
#module(load="imtcp")
#input(type="imtcp" port="514")
# Filter duplicated messages
# Включить фильтрацию одинаковых сообщений
$RepeatedMsgReduction off
# Шаблон создания директории на основе IP адреса клиента и сбор всех логов в один файл:
$template RemoteLogs,"/var/log/remote/%fromhost-ip%/syslog.log"
# Сохранять сообщения от любого источника (*) с любым приоритетом (*) в файл, заданный шаблоном (RemoteLogs):
*.* ?RemoteLogs
# Шаблон создания директории на основе имени клиента и лог-файлов по имени программы:
# $template RemoteLogs,"/var/log/remote/%HOSTNAME%/%PROGRAMNAME%.log"
# *.* ?RemoteLogs
# Include all config files in /etc/rsyslog.d/
$IncludeConfig /etc/rsyslog.d/*.conf
</code></pre>
<p><code>systemctl restart rsyslog</code></p>
<h3 id="client"><a class="header" href="#client">client</a></h3>
<p><code>nano /etc/rsyslog.d/all.conf</code></p>
<pre><code class="language-conf"># UDP:
*.* @192.168.3.105:514
# TCP:
# *.* @@192.168.3.105:514
# auth.* @@192.168.3.105:514
# *.err @@192.168.3.105:514
</code></pre>
<p><code>systemctl restart rsyslog</code> <br />
<code>ls /var/log/remote</code> на сервере должна появиться директория с ip-адресом/именем клиента <br />
<code>ls -lh /var/log/remote/*</code> <br />
<code>cat /var/log/remote/192.168.3.104/syslog.log | grep influxd</code> <br />
<code>systemctl restart zabbix-agent</code> <br />
<code>cat /var/log/remote/192.168.3.104/syslog.log | grep zabbix_agentd</code></p>
<h3 id="zabbix-agent"><a class="header" href="#zabbix-agent">zabbix-agent</a></h3>
<p><code>nano /etc/zabbix/zabbix_agentd.conf</code></p>
<pre><code class="language-conf"># LogType=file
LogType=system
DebugLevel=1
</code></pre>
<p><code>systemctl restart zabbix-agent</code></p>
<h3 id="ommail"><a class="header" href="#ommail">ommail</a></h3>
<p><code>nano /etc/rsyslog.conf</code></p>
<pre><code class="language-conf"># Включить модуль:
module(load="ommail")
$ActionMailSMTPServer m.domain.ru
$ActionMailSMTPPort 25
$ActionMailFrom zabbix@domain.ru
$ActionMailTo lifailon@domain.ru
# Шаблон, который будет подставляться как тема (Subject) и тело письма (Body) - имя переменной шаблона,"содержимое шаблона"
$template mailSubject,"rsyslog: disk problem on %hostname%"
$template mailBody,"RSYSLOG Alert\r\nmsg='%msg%'"
$ActionMailSubject mailSubject
$ActionMailBody mailBody
# Ограничение на отправку - одно письмо в 5 минут
$ActionExecOnlyOnceEveryInterval 300
</code></pre>
<h2 id="logrotate"><a class="header" href="#logrotate">logrotate</a></h2>
<p><code>systemctl status logrotate.timer</code></p>
<p><code>nano /etc/logrotate.conf</code></p>
<pre><code class="language-conf"># Ротация файлов журнала еженедельно
weekly
# По умолчанию используется группа adm, которая является владельцем группы ls -ld /var/log/syslog
su root adm
# Количество файлов (недель, если ротация еженедельно) хранения журналов
rotate 4
# Создавать новые (пустые) файлы журналов после ротации старых
create
# Использовать дату в качестве суффикса ротируемого файла
dateext
# Сжимать лог-файлы
compress
# Пакеты сбрасывают информацию о ротации журнала в этот каталог
include /etc/logrotate.d
</code></pre>
<p><code>nano /etc/logrotate.d/logrotate_remote.conf</code></p>
<pre><code class="language-conf">/var/log/remote/*/*.log {
su root root
daily
copytruncate
size 10M
rotate 2
compress
dateext
}
</code></pre>
<p>Условия:</p>
<p><code>hourly</code> каждый час <br />
<code>daily</code> каждый день <br />
<code>weekly</code> каждую неделю <br />
<code>monthly</code> каждый месяц <br />
<code>yearly</code> каждый год <br />
<code>size</code> минимальный размер лога, меньше этого значения ротация выполняться не будет</p>
<p>Действия:</p>
<p><code>rotate 2</code> указать, сколько последних ротированных лог-файлов нужно хранить, остальные удалять <br />
<code>maxage 30</code> указать, за сколько последних дней хранить ротированные файлы, остальные удалять <br />
<code>copytruncate</code> сначала создается копия файла лога, после уже обрезается действующий (нужно, когда программа должна писать лог непрерывно, возможность потери записей, если она придется на процесс усечения) <br />
<code>extension</code> сохранять оригинальный лог файл после ротации <br />
<code>compress</code> сжимать ротированный лог (gzip) <br />
<code>delaycompress</code> не сжимать последний и предпоследний журнал (позволяет избежать ошибок, связанных с отсутствием доступа к используемому файлу) <br />
<code>create # 0644 root root</code> создать пустой лог файл на месте старого <br />
<code>olddir /path</code> перемещать логи в отдельную папку при срабатывании условия <br />
<code>dateext</code> добавляет дату ротации перед заголовком старого лога <br />
<code>missingok</code> не выдавать ошибки, если лог файла не существует <br />
<code>notifempty</code> если файл пустой, не выполнять никаких действий <br />
<code>prerotate script.sh endscript</code> скрипт, который необходимо выполнить перед чисткой лога <br />
<code>postrotate script.sh endscript</code> скрипт, который необходимо выполнить после чистки лога <br />
<code>sharedscripts</code> если был указан путь в формате wildcard (*), выполнить скрипт один раз после завершения ротации всех файлов</p>
<p><code>logrotate -d /etc/logrotate.d/logrotate_remote.conf</code> проверить ротацию (--debug) <br />
<code>logrotate -fv /etc/logrotate.d/logrotate_remote.conf</code> запустить ротацию сейчас (--force) с подробным выводом (--verbose) <br />
<code>cat /etc/cron.daily/logrotate</code> задание на автоматический запуск создается по умолчанию, который читает конфигурационный файл ротации /etc/logrotate.conf, в нем указана директрия: include /etc/logrotate.d в которой лежат файлы ротации <br />
<code>which logrotate</code> узнать путь до исполняемого файла <br />
<code>crontab -e</code> <br />
<code>00 3 * * * /usr/sbin/logrotate -f /etc/logrotate.d/logrotate_remote.conf</code> настроить собственное ручное расписание с ежедневным запусков в 3:00</p>
<h2 id="log"><a class="header" href="#log">log</a></h2>
<ul>
<li><a href="https://github.com/Lifailon/lazyjournal">lazyjournal</a> - терминальный пользовательский интерфейс для journalctl, журналов файловой системы, а также контейнеров Docker, Podman и Kubernetes для быстрого просмотра и фильтрации с поддержкой нечеткого поиска, регулярных выражений и раскрашивания вывода:</li>
</ul>
<p><code>curl https://raw.githubusercontent.com/Lifailon/lazyjournal/main/install.sh | bash</code> <br />
<code>lazyjournal</code></p>
<ul>
<li><a href="https://github.com/tstack/lnav">lnav</a> - терминальный пользовательский интерфейс для логов файловой системы с таймстампами, возможностью поиска и подсветкой:</li>
</ul>
<p><code>apt install lnav</code> <br />
<code>journalctl -f -a -xe -o json | lnav</code> <br />
<code>ssh playground@demo.lnav.org</code></p>
<ul>
<li><a href="https://github.com/bensadeh/tailspin">tailspin</a> - раскрашивание любого вывода:</li>
</ul>
<p><code>apt install tailspin</code> <br />
<code>cat /var/log/syslog | tailspin</code></p>
<ul>
<li><a href="https://github.com/Textualize/toolong">toolong</a> - терминальный пользовательский интерфейс для интерактивного просмотра логов с поддержкой поиска и объединения журналов (заменяет tail, less и grep):</li>
</ul>
<p><code>pipx install toolong</code> <br />
<code>tl /var/log/syslog*</code> откроет все журналы syslog (включая поддержку чтения архивных журналов) <br />
<code>tl /var/log/syslog /var/log/syslog.1 --merge</code> объеденит два журнала в один <br />
<code>cat /var/log/syslog /var/log/syslog.1 | tailspin | tl</code> вначале красим вывод и потом передаем на вход toolong \</p>
<ul>
<li><a href="https://github.com/tsl0922/ttyd">ttyd</a> - позволяет запускать терминальные интерфейсы в Web интерфейсе с поддержкой базовой авторизации:</li>
</ul>
<p><code>sudo apt install ttyd</code> <br />
<code>ttyd -W -p 4444 tl /var/log/syslog*</code> <br />
<code>ttyd -W -p 4444 -c admin:admin tl /var/log/syslog*</code></p>
<h2 id="smb"><a class="header" href="#smb">smb</a></h2>
<h3 id="cifs"><a class="header" href="#cifs">cifs</a></h3>
<p><code>apt install cifs-utils</code> установить SMB Client</p>
<p><code>nano /root/.smbclient</code></p>
<pre><code>username=lifailon
password=password
#domain=domain.local
</code></pre>
<p><code>mkdir /smb &amp;&amp; mkdir /smb/backup</code> создать директорию для монтирования <br />
<code>nano /etc/fstab</code> <br />
<code>//192.168.3.100/Backup /smb/backup cifs user,rw,credentials=/root/.smbclient 0 0</code> rw права на чтение и запись <br />
<code>mount -a</code> примонтировать (открыть порты на сервере: 137/UDP; 138/UDP; 139/TCP; 445/TCP) <br />
<code>df -h</code></p>
<p><code>//192.168.3.100/torrent-files /home/lifailon/torrent-files cifs user,rw,credentials=/root/.smbclient,perms=0666 0 0</code> <br />
<code>chmod 666 /home/lifailon/torrent-files</code> <br />
<code>chown -R lifailon:lifailon /home/lifailon/torrent-files</code> <br />
<code>smbclient $path_smb_qb --user=smb --password=kinozal</code></p>
<h3 id="samba"><a class="header" href="#samba">samba</a></h3>
<p><code>iptables -I INPUT -p tcp --dport 445 -j ACCEPT</code> используется для Samba <br />
<code>iptables -I INPUT -p tcp --dport 137 -j ACCEPT</code> используется для работы NetBIOS (использование имени компьютера для доступа) <br />
<code>iptables -I INPUT -p tcp --dport 139 -j ACCEPT</code> <br />
<code>iptables -I INPUT -p udp --dport 137:138 -j ACCEPT</code> <br />
<code>iptables -L</code> отобразить список правил <br />
<code>iptables -F</code> очистить список правил <br />
<code>apt install iptables-persistent</code> <br />
<code>netfilter-persistent save</code> применить настройки</p>
<p><code>apt install samba</code> <br />
<code>systemctl status smbd</code> <br />
<code>mkdir -p /public/share</code> создать общую папку <br />
<code>chmod 777 /public/share</code> выдать права</p>
<p><code>nano /etc/samba/smb.conf</code></p>
<pre><code class="language-conf">[global]
workgroup = WORKGROUP # рабочая группа (должна одинакова на всех машинах)

[share1]
    comment = Public folder for all
    path = /public/share
    public = yes
    writable = yes
    read only = no
    guest ok = yes
    create mask = 0777
    directory mask = 0777
    force create mode = 0777
    force directory mode = 0777
</code></pre>
<p><code>[Общая папка]</code> имя общей папки, которое увидят пользователи при подключение
<code>path</code> путь на сервере, где будут храниться данные
<code>public</code> для общего доступа, чтобы все могли работать с ресурсом
<code>writable</code> разрешает запись в сетевую папку
<code>read only = yes</code> только для чтения. no - для полного доступа управлением ФС
<code>guest ok</code> разрешает доступ к папке гостевой учетной записи
<code>create mask, directory mask, force create mode, force directory mode</code> при создании новой папки или файла назначаются указанные права. В примере указаны полные права.</p>
<p><code>systemctl restart smbd</code> применить настройки</p>
<p><code>useradd smb1</code> создать пользователя <br />
<code>passwd smb1</code> задать пароль пользователю <br />
<code>smbpasswd -a smb1</code> создать пользователя для Samba</p>
<pre><code>public = no
writable = no
read only = yes
guest ok = yes # разрешить анонимный доступ на чтение (read only) без пароля
; valid users = smb1 @smb-users # список пользователей, которым разрешено подключаться к каталогу для чтения, а также входщях в группу smb-users
write list = smb1 # список пользователей, которые имеют полный доступ к директории
hosts allow = comp1, 192.168.160.0/255.255.252.0 # указать список разрешенных хостов или сетей, с которых можно подключаться к серверу. Если его прописать в секцию с настройкой шары, то он будет действовать только для нее, если прописать в [global], то для всех общих папок
hosts deny = comp2, 192.168.164.0/255.255.252.0 # запретить доступ
</code></pre>
<h3 id="client-cifs"><a class="header" href="#client-cifs">client cifs</a></h3>
<p><code>apt install cifs-utils</code> <br />
<code>mkdir /mnt/share1</code> <br />
<code>mount -t cifs "//192.168.3.103/share1" /mnt/share1 -o user=smb1</code> примонтировать удаленный каталог на клиенте Linux с авторизацией <br />
<code>df -handle</code> <br />
<code>//192.168.3.103/share1  24G  23G  1.2G  96%  /mnt/share1</code></p>
<h3 id="client-samba-client"><a class="header" href="#client-samba-client">client samba-client</a></h3>
<p><code>apt install samba-client</code> <br />
<code>smbclient -L 192.168.3.103 -U share1</code></p>
<h3 id="recycle"><a class="header" href="#recycle">recycle</a></h3>
<pre><code>[share1]
    path = /public/share
    public = yes
    browseable = yes
    writable = yes
    read only = no
    guest ok = yes
    vfs objects = recycle
    recycle:repository = .recycle/%U
    recycle:keeptree = Yes
    recycle:touch = Yes
    recycle:versions = Yes
    recycle:maxsize = 0
    recycle:exclude = *.tmp
    recycle:exclude_dir = /tmp
</code></pre>
<p><code>recycle:repository</code> где хранить удаленные объекты. Удаленные файлы попадут в скрытый каталог .recycle в котором создастся каталог с именем пользователя, удалившего файл или папку <br />
<code>recycle:keeptree</code> удалять объекты с сохранением дерева каталогов <br />
<code>recycle:touch</code> изменить дату изменения файла при его перемещении в корзину <br />
<code>recycle:versions</code> при удалении файлов с совпадающими именами, добавлять номер версии <br />
<code>recycle:maxsize</code> не помещать в корзину файлы, размер которых больше заданного параметра (в байтах). 0 - помещать файлы любого размера <br />
<code>recycle:exclude</code> исключить файлы <br />
<code>recycle:exclude_dir</code> исключить каталог</p>
<h2 id="nfs"><a class="header" href="#nfs">nfs</a></h2>
<h3 id="server-1"><a class="header" href="#server-1">server</a></h3>
<p><code>apt install nfs-kernel-server</code> установить сервер, с помощью которого будет выполнено открытие шары. Сервис NFS слушает соединения для TCP и UDP на порту 2049. <br />
<code>apt install rpcbind</code> <br />
<code>rpcinfo -p | grep nfs</code> проверить, слушается ли порт nfs <br />
<code>cat /proc/filesystems | grep nfs</code> проверить, поддерживается ли NFS на уровне ядра (вывод: nodev nfsd) <br />
<code>modprobe nfs</code> вручную загрузить модуль ядра nfs <br />
<code>systemctl status nfs-server</code> служба сервера <br />
<code>ufw allow 111,2049 &amp;&amp; ufw reload</code> <br />
<code>mkdir nfs-folder</code> создать папку для шары <br />
<code>adduser nfs-user</code> создать пользователя для подключения <br />
<code>chown nfs-user:nfs-user nfs-folder</code> изменить владельца шары <br />
<code>chmod 775 nfs-folder</code> дать полный доступ владульцу и группе <br />
<code>nano /etc/exports</code> файл настройки шары <br />
<code>/nfs-folder 192.168.3.0/24(rw,sync,no_subtree_check)</code> /путь/к/директории (шарим), удаленный IP-адрес клиента или подсеть (что бы разрешить все адреса используется 0.0.0.0/24 или символ *) и опции в скобках <br />
<code>exportfs -a</code> применить настройки (обновить таблицу экспорта NFS)</p>
<p>Options:</p>
<p><code>rw</code> разрешить чтение и запись в этой папке <br />
<code>ro</code> разрешить только чтение <br />
<code>sync</code> отвечать на следующие запросы только тогда, когда данные будут сохранены на диск (по умолчанию) <br />
<code>async</code> не блокировать подключения пока данные записываются на диск <br />
<code>secure</code> использовать для соединения только порты ниже 1024 <br />
<code>insecure</code> использовать любые порты <br />
<code>nohide</code> не скрывать дочернии директории, при открытии доступа к нескольким директориям <br />
<code>root_squash</code> подменять запросы от root на анонимные (используется по умолчанию) <br />
<code>no_root_squash</code> не подменять запросы от root на анонимные (все подключения от имени пользователя root считаются по умолчанию анонимными nfsnobody, отключение этой опции не безопасно, потому что любой root пользователь сможет получить доступ на запись ко всем файлам) <br />
<code>all_squash</code> превращать все запросы в анонимные <br />
<code>subtree_check</code> проверять не пытается ли пользователь выйти за пределы экспортированной папки <br />
<code>no_subtree_check</code> отключить проверку обращения к экспортированной папке, улучшает производительность, но снижает безопасность, можно использовать когда экспортируется раздел диска <br />
<code>anonuid и anongid</code> указывает uid и gid для анонимного пользователя</p>
<p>Работает стандартная система доступа UNIX, поэтому, если нужно чтобы пользователь подключивший директорию мог получить доступ к папке, то на клиентской стороне должен существовать пользователь с таким же UID (именем и ID), а на сервере для расшаренной директории должна принадлежать такому же пользователю или группе в которой он состоит (GID). Или дать полный доступ для всех пользователей (chmod 777 nfs-folder), тогда все созданные файлы будут от имени: nobody nogroup</p>
<p><code>/nfs-folder 192.168.3.0/24(rw,sync,all_squash,anonuid=1020,anongid=1020)</code> любой пользователь в сети сможет получить полный доступ ко всем файлам расшаренной директории, предварительно нужно создать пользователя с UID 1020 и указать, что бы все подключения считать запросами от анонимного пользователя, а анонимному пользователю присвоить UID 1020. Если у пользователя с id 1020 есть доступ к расшаренной директории на сервере, то при подключении директории на клиентской стороне он будет у пользователя с любым UID. При создании файлов и директорий под другим пользователем, будет указан владелец с номером UID и GID 1020. <br />
<code>usermod -u 1020 nfs-user</code> изменить UID <br />
<code>groupmod -g 1020 nfs-user</code> изменить GID <br />
<code>id nfs-user</code> проверяем ID</p>
<h3 id="client-1"><a class="header" href="#client-1">client</a></h3>
<p><code>apt install nfs-common</code> установить на клиентском компьютере, что бы работать c файловой системой <br />
<code>mkdir /mnt/nfs-folder &amp;&amp; mount 192.168.3.104:/nfs-folder/ /mnt/nfs-folder</code> подключить шару и првоерить df -h (192.168.3.104:/nfs-folder  48G  20G  27G  43%  /mnt/nfs-folder) <br />
<code>umount /mnt/nfs-folder</code> отключить <br />
<code>showmount -e 192.168.3.104</code> отобразить список всех доступных ресурсов</p>
<h2 id="ftp"><a class="header" href="#ftp">ftp</a></h2>
<p><code>apt install vsftpd</code> установка vsFTPd Server (Very Secure File Transfer Protocol Daemon) <br />
<code>systemctl status vsftpd</code> <br />
<code>ufw allow 20:21/tcp</code> открыть порты в Firewall <br />
<code>ufw allow 30000:31000/tcp</code> <br />
<code>cp /etc/vsftpd.conf /etc/vsftpd.conf.bak</code> резервная копия настроек</p>
<p><code>nano /etc/vsftpd.conf</code></p>
<pre><code class="language-conf">listen=YES
listen_ipv6=NO
anonymous_enable=NO` отключить ананимный вход
local_enable=YES` разрешить использовать имена локальных пользователей сервера для входа
write_enable=YES` разрешить для авторизованных пользователей управлять файловой системой (по умолчанию возможно только скачивание). При подключение к серверу пользователь может управлять всеми каталогами, куда у него есть доступ
chroot_local_user=NO` когда установлено в YES, ограничивает пользователей их домашними каталогами для предотвращения доступа к остальной части файловой системы
chroot_list_enable=YES` задать список пользователей, которые будут или не будут ограничены своими домашними каталогами в зависимости от chroot_local_user
chroot_list_file=/etc/vsftpd.chroot_list` путь к файлу, который содержит список пользователей для chroot-ограничения
user_sub_token=$USER
local_root=/home/$USER/ftp` указать для всех пользователей по умолчанию домашний каталог при подключении (используется вместе с плейсхолдером)
userlist_enable=YES` включает использование списка пользователей, которые могут (или не могут) входить на сервер
userlist_file=/etc/vsftpd.user_list` указывает путь к файлу со списком пользователей, которые разрешены или запрещены
userlist_deny=NO` ппределяет поведение списка пользователей, когда установлено в NO, только пользователи из списка userlist_file могут входить на сервер и наоборот
connect_from_port_20` YES - использовать 20 порт для передачи данных вместо случайного (нужно для нормальной работы firewall)
xferlog_enable = YES` записывать в лог файл все транзакции
</code></pre>
<p><code>systemctl restart vsftpd</code> <br />
<code>ss -ln | grep -w "21"</code> проверить, что 21 порт слушает (LISTEN) <br />
<code>ss -tn | grep -w "21"</code> проверить установленные соединения на 21 порту (ESTAB) <br />
<code>cat /var/log/vsftpd.log</code> лог работы (CONNECT/LOGIN/UPLOAD/DOWNLOAD/RENAME/DELETE)</p>
<h3 id="ftp-client"><a class="header" href="#ftp-client">ftp client</a></h3>
<p><code>ftp 192.168.3.104</code> доступен только без использования SSL <br />
<code>230 Login successful</code> вход в систему успешен <br />
<code>ls</code> отобразить все файлы в текущей директории на удаленном компьютере <br />
<code>get test.json</code> скачать файл на локальный компьютер <br />
<code>put out.txt</code> загрузить файл на удаленный сервер <br />
<code>bye</code> закрыть соединение</p>
<h3 id="ftps"><a class="header" href="#ftps">ftps</a></h3>
<p><code>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/vsftpd.key -out /etc/ssl/certs/vsftpd.crt</code> сгенерировать самозаверяющий SSL-сертификат и закрытый ключ</p>
<p><code>nano /etc/vsftpd.conf</code></p>
<pre><code class="language-conf">ssl_enable=YES
rsa_cert_file=/etc/ssl/certs/vsftpd.crt
rsa_private_key_file=/etc/ssl/private/vsftpd.key
allow_anon_ssl=NO
force_local_data_ssl=YES
force_local_logins_ssl=YES
ssl_tlsv1=YES
ssl_sslv2=NO
ssl_sslv3=NO
require_ssl_reuse=NO
ssl_ciphers=HIGH
</code></pre>
<p><code>useradd -m -s /bin/bash ftpuser</code> пользователь с домашним именным каталогом и оболочкой bash <br />
<code>passwd ftpuser</code> задать пароль пользователю <br />
<code>echo "ftpuser" | tee -a /etc/vsftpd.chroot_list</code> добавить пользователя в список ограниченных домашним каталогом <br />
<code>echo "ftpuser" | tee -a /etc/vsftpd.user_list</code> добавить пользователя в список разрешенных для подключения <br />
<code>mkdir /home/ftpuser/ftp</code> создать домашнию директорию <br />
<code>chown ftpuser:ftpuser ftp</code> назначить владельца и группу для директории <br />
<code>chmod 555 ftp</code> ограничить доступ только на чтение и выполнение <br />
<code>mkdir /home/ftpuser/ftp/upload</code> создать директорию для загруки (с возможностью записи) <br />
<code>chown ftpuser:ftpuser upload</code> <br />
<code>chmod 775 upload</code> полный доступ для владельца и группы</p>
<h2 id="rsync"><a class="header" href="#rsync">rsync</a></h2>
<p><code>rsync -options SRC DST</code></p>
<p><code>-a</code> режим архивирования, когда сохраняются все исходные атрибуты оригинальных файлов (дата изменения и создания) <br />
<code>-b</code> создание резервной копии <br />
<code>-c</code> проверка контрольных сумм для файлов <br />
<code>-e</code> использовать другой транспорт (например ssh) <br />
<code>-h</code> выводит цифры в формате, нормальном для чтения <br />
<code>-l</code> копировать символьные ссылки <br />
<code>-L</code> копировать содержимое ссылок <br />
<code>-p</code> сохранять права для файлов <br />
<code>-q</code> минимум информации <br />
<code>-u</code> не перезаписывать более новые файлы <br />
<code>-v</code> выводить подробную информацию о процессе копирования <br />
<code>-w</code> выполнить полное копирование без синхронизации <br />
<code>-z</code> сжимать файлы перед передачей <br />
<code>--delete</code> удалять остальные файлы у получателя, которых нет в источнике отправителя <br />
<code>--progress</code> выводить прогресс передачи файла (в %) <br />
<code>--stat</code> показать статистику передачи</p>
<p><code>rsync -zvh /home/lifailon /backup</code> копирование и синхронизация только файлов (skipping directory) указанной директории (в пределах одной локальной машины, например на внешний носитель). При редактировании файлов в исходной папке и повторном копирование заменит все содержимое (без синхронизации).</p>
<p><code>nano /etc/rsyncd.conf</code></p>
<pre><code class="language-conf">pid file = /var/run/rsyncd.pid
lock file = /var/run/rsync.lock
log file = /var/log/rsync.log
[share]
path = /backup/
hosts allow = 192.168.3.103
hosts deny = *
list = true
uid = lifailon
gid = lifailon
read only = false
</code></pre>
<p><code>chown kup:kup backup</code> сменить владельца и группу директории <br />
<code>chmod ug+rwx backup</code> выдать им полные права (для удаленного пользователя) <br />
<code>systemctl start rsync</code> запустить сервер</p>
<p>Синхронизация на удаленной машине (192.168.3.103) авторизованным под пользователем, указанным в конфигурации:</p>
<p><code>rsync -avzh /backup/ kup@192.168.3.103:/tmp/backup/</code> скопировать содержимое локальной папки backup (включая директории) на удаленный сервер. По умолчанию Rsync использует транспорт SSH (шифрованный) с запросом пароля (если не используется ключ). <br />
<code>rsync -avzhe "ssh -p 2121" /tmp/backup/ kup@192.168.21.121:/tmp/backup/</code> если используется нестандартный порт <br />
<code>rsync -avzh /tmp/backup/ rsync://192.168.21.121:/share</code> явно задать использование транспорта Rsync <br />
При редактировании исходных файлов, заменит содержимое только тех файлов, которые были изменены (sending incremental file list ./ test3) <br />
<code>rsync -avzh kup@192.168.3.103:/tmp/backup /tmp/backup/</code> скопировать данные с удаленного сервера на локальный компьютер <br />
<code>ssh-keygen -t rsa</code> в случае доступа к серверу по SSH необходимо будет создать ключ и загрузить его на сервер, чтобы аутентификация проходила без запроса пароля <br />
<code>ssh-copy-id -i /home/sk/.ssh/id_rsa.pub kup@192.168.21.10</code> передать ключ на сервер с которым будет происходить синхронизация <br />
<code>00 03 * * * rsync -avzhe "ssh -p 2121" /tmp/backup/ kup@192.168.21.121:/tmp/backup/</code> добавить в планировщик, синхронизация каталогов будет выполняться каждый день в 3 часа ночи</p>
<h2 id="apache"><a class="header" href="#apache">apache</a></h2>
<p><code>apt install apache2</code> <br />
<code>cat /etc/apache2/apache2.conf</code> <br />
<code>cat /etc/apache2/ports.conf</code> <br />
<code>port=8443</code> <br />
<code>cat /etc/apache2/ports.conf | sed -r "s/^Listen.+/Listen $port/" &gt; /etc/apache2/ports.conf</code> <br />
<code>systemctl restart apache2</code> <br />
<code>systemctl status apache2</code> <br />
<code>ss -lpn | grep apache</code> <br />
<code>echo "&lt;H1&gt;$(hostname)&lt;/H1&gt;" &gt; /var/www/html/index.html</code></p>
<h3 id="api-server"><a class="header" href="#api-server">api server</a></h3>
<p><code>mkdir /var/www/api &amp;&amp; touch /var/www/api/api.sh &amp;&amp; chmod +x /var/www/api/api.sh</code> <br />
<code>curl -s "https://raw.githubusercontent.com/Lifailon/bash-api-server/rsa/www/api/api.sh" &gt; /var/www/api/api.sh</code> установить пример с шаблоном сервера api</p>
<p><code>nano /var/www/api/api.sh</code></p>
<pre><code class="language-bash">#!/bin/bash
if [ "$REQUEST_METHOD" == "GET" ]
    then
    echo "Content-type: application/json"
    echo
    echo '{"result": "ok"}'
else
    echo "Content-type: text/plain"
    echo
    echo "Request method not supported"
fi
</code></pre>
<p><code>a2enmod auth_basic</code> активировать модуль базовой HTTP аутентификации <br />
<code>htpasswd -b -c /etc/apache2/.htpasswd rest api</code> настроить htpasswd для хранения пользовательских данных (создать пользователя rest с паролем api)</p>
<p><code>nano /etc/apache2/sites-available/api.conf</code> создать VirtualHost для обработки запросов</p>
<pre><code class="language-conf">&lt;VirtualHost *:8443&gt;
    DocumentRoot /var/www/html
    # Связать endpoint (включая все дочернии в пути) с исполняемым файлом
    ScriptAlias /api /var/www/api/api.sh
    # Все опции, вложенные внутрь секции Directory, применяются к указанной директории
    &lt;Directory "/var/www/api"&gt;
        # Разрешить выполнение CGI-скриптов
        Options +ExecCGI
        # Обрабатывать все файлы с расширение sh как CGI-скрипт
        AddHandler cgi-script .sh
        AllowOverride None
        Require all granted
    &lt;/Directory&gt;
    # Добавить авторизацию для endpoint
    &lt;Location "/api"&gt;
        AuthType Basic
        AuthName "Restricted Area"
        AuthUserFile /etc/apache2/.htpasswd
        Require valid-user
        SetHandler cgi-script
        Options +ExecCGI
    &lt;/Location&gt;
    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
&lt;/VirtualHost&gt;
</code></pre>
<p><code>a2enmod cgi</code> активировать модуль (en mod) Common Gateway Interface (CGI) <br />
<code>a2ensite api.conf</code> активировать VirtualHost (en site) <br />
<code>systemctl restart apache2</code> <br />
<code>tail -f /var/log/apache2/error.log</code> <br />
<code>tail -f /var/log/apache2/access.log</code></p>
<p><code>curl -s -X GET http://127.0.0.1:8443/api -u rest:api | jq .result</code> <br />
<code>curl -s -X GET http://127.0.0.1:8443/api/info -u rest:api -H "Content-Type: application/json" | jq .content[]</code></p>
<p><code>REQUEST_METHOD</code> метод HTTP-запроса (GET, POST, HEAD и т.д.) <br />
<code>REQUEST_URI</code> оригинальный URI запроса <br />
<code>QUERY_STRING</code> строка запроса URL <br />
<code>CONTENT_TYPE</code> тип содержимого запроса в заголовке клиента (например, application/text) <br />
<code>CONTENT_LENGTH</code> длина тела запроса в байтах (чаще, для POST-запросов) <br />
<code>read -n $CONTENT_LENGTH POST_DATA</code> прочитать содержимое Body из стандартного ввода (stdin). <br />
<code>HTTP_STATUS</code> читаем содержимое переданного заголовка (например, "Status: text"), которое определяется заранее и регламентируется в дальнейшем <br />
<code>HTTP_USER_AGENT</code> название агента клиента из заголовка (например, curl/8.4.0) <br />
<code>REMOTE_ADDR</code> адрес клиента <br />
<code>REMOTE_PORT</code> порт клиента <br />
<code>SERVER_NAME</code> адрес сервера <br />
<code>SERVER_PORT</code> порт сервера <br />
<code>SCRIPT_NAME</code> путь и имя CGI-скрипта <br />
<code>SERVER_SOFTWARE</code> имя и версия сервера <br />
<code>SERVER_PROTOCOL</code> версия протокола HTTP (например, HTTP/1.1) <br />
<code>HTTPS</code> если установлено, то запрос был сделан с использованием HTTPS <br />
<code>AUTH_TYPE</code> тип аутентификации, если он был предоставлен <br />
<code>REMOTE_USER</code> имя пользователя, если была использована аутентификация <br />
<code>DOCUMENT_ROOT</code> корневой каталог веб-сервера</p>
<h3 id="status"><a class="header" href="#status">status</a></h3>
<p><code>apachectl -M | grep status_module</code> проверить подключенный модуль статистики: status_module (shared) <br />
<code>nano /etc/apache2/mods-available/status.conf</code> <br />
<code>Require ip 192.168.3.0/24</code> указать для кого доступна статистика <br />
http://127.0.0.1:8443/server-status <br />
<code>apachectl -t</code> проверить синтаксис (Syntax OK) <br />
<code>a2enmod status</code> активировать модуль (Module status already enabled) <br />
<code>systemctl restart apache2</code> <br />
<code>netstat -tulpan | grep apache2</code> проверить порт <br />
<code>curl http://127.0.0.1:8443/server-status?auto</code></p>
<h3 id="webdav"><a class="header" href="#webdav">webdav</a></h3>
<p><code>nano /etc/apache2/ports.conf</code></p>
<pre><code>Listen 8443
Listen 2024
</code></pre>
<p><code>mkdir /var/www/webdav &amp;&amp; chown www-data:www-data /var/www/webdav</code> создать каталог к которому будет доступ через WebDAV и предоставить доступ к нему для www-data</p>
<p><code>nano /etc/apache2/sites-available/webdav.conf</code></p>
<pre><code class="language-conf">&lt;VirtualHost *:2024&gt;
    ServerAdmin webmaster@localhost
    DocumentRoot /var/www/webdav
    Alias /webdav /var/www/webdav
    &lt;Directory /var/www/webdav&gt;
        Options Indexes FollowSymLinks
        AllowOverride None
        Require all granted
        Dav On
        AuthType Basic
        AuthName "WebDAV"
        AuthUserFile /etc/apache2/.htpasswd
        Require valid-user
    &lt;/Directory&gt;
    ErrorLog ${APACHE_LOG_DIR}/webdav_error.log
    CustomLog ${APACHE_LOG_DIR}/webdav_access.log combined
&lt;/VirtualHost&gt;
</code></pre>
<p><code>a2enmod dav</code> <br />
<code>a2enmod dav_fs</code> <br />
<code>a2enmod auth_digest</code> <br />
<code>a2enmod authn_core</code> <br />
<code>a2enmod authn_file</code> <br />
<code>a2enmod authz_core</code> <br />
<code>a2enmod authz_user</code> <br />
<code>htpasswd /etc/apache2/.htpasswd admin</code> создать пользователя admin (ключ -с используется для пересоздания файла) <br />
<code>a2ensite webdav</code> активировать конфигурацию сайта <br />
<code>systemctl restart apache2</code></p>
<h2 id="haproxy"><a class="header" href="#haproxy">haproxy</a></h2>
<p><code>apt install haproxy</code> <br />
<code>systemctl status haproxy</code></p>
<p><code>/etc/default/haproxy</code></p>
<pre><code>ENABLED=1
</code></pre>
<p><code>/etc/haproxy/haproxy.cfg</code></p>
<pre><code>global
log 127.0.0.1 local0 notice
maxconn 10000
nbproc 1
user haproxy
group haproxy
daemon

defaults
log global
maxconn global
timeout client 5s
timeout server 5s
timeout connect 5s

frontend http_front
mode http
bind *:8081
#bind *:443 ssl crt /etc/ssl/domain.ru/cert.pem 
option httplog
###mode tcp
###bind *:3389
###option tcplog
use_backend http_back

backend http_back
mode http
balance roundrobin
###mode tcp
###balance leastconn
option httpchk GET / HTTP/1.1\r\nHost:\ localhost
###option tcp-check
###tcp-check connect port 3389
#server term1.domain.ru 192.168.55.30:443 ssl verify none weight 100 check inter 5s fall 5 rise 3
#server term2.domain.ru 192.168.55.35:443 ssl verify none weight 100 check inter 5s fall 5 rise 3
server pi-hole-01 192.168.3.101:8081 weight 100 check inter 5s fall 5 rise 3
server netbox-01 192.168.3.104:8081 weight 100 check inter 5s fall 5 rise 3

listen stats
bind *:8082
#bind *:8080 ssl crt /etc/ssl/domain.ru/cert.pem 
mode http
stats enable
stats uri /
stats auth admin:password
stats show-legends
stats show-node
stats refresh 5s
</code></pre>
<p><code>haproxy -f /etc/haproxy/haproxy.cfg -c</code> проверить синтаксис (Configuration file is valid) <br />
<code>systemctl restart haproxy</code> применить настройки (перечитать конфигурацию) <br />
<code>ss -lpn | grep 8081</code> <br />
<code>curl http://192.168.3.102:8081</code> проверка http-трафика <br />
<code>http://192.168.3.102:8082</code> статистика <br />
<code>cat /var/log/haproxy.log</code> <br />
<code>journalctl -eu haproxy</code> <br />
<code>systemctl stop apache2</code> отключить на 101</p>
<ul>
<li>options:</li>
</ul>
<p><code>maxconn</code> максимальное количество одновременных соединений <br />
<code>nbproc</code> количество процессов HAProxy <br />
<code>option httplog</code> включает журналирование HTTP-трафика, полезно для отладки и мониторинга прохождения трафика через HAProxy и дает возможность просматривать HTTP-трафик в журнале, чтобы отслеживать запросы и ответы <br />
<code>option httpchk</code> отправлять HTTP-запросы к серверам в бэкенде, чтобы определить, работают ли они, это позволяет выявлять неработающие сервера и перераспределять запросы на работающие <br />
<code>option httpchk GET / HTTP/1.1\r\nHost:\ localhost</code> отправляет GET-запрос на корневой путь (/) используя версию протокола HTTP 1.1, Host:\ localhost - это часть заголовка Host, который также включается в HTTP-запрос и указывает на целевой хост, который проверяется <br />
<code>option tcp-check</code> активирует общую функцию TCP-проверок для всего бэкэнда, без необходимости указывать порт явно <br />
<code>tcp-check connect port 443</code> HAProxy будет устанавливать соединение с серверами в бэкенде на порту 443 для проверки, что серверы доступны и способны принимать соединения на этом порту</p>
<ul>
<li>balance:</li>
</ul>
<p><code>Round Robin (roundrobin)</code> алгоритм используемый по умолчанию, отправляет запросы на сервера по очереди <br />
<code>static-rr</code> похож на roundrobin, но он сохраняет порядок серверов в конфигурации <br />
<code>Least Connections (leastconn)</code> выбирает сервер с наименьшим количеством активных соединений, это полезно, если у серверов разная производительность или загруженность, так как запросы будут отправляться на менее загруженные серверы <br />
<code>source</code> использует IP-адрес источника (клиента) для привязки к одному и тому же серверу, это означает, что клиент всегда будет направляться к одному и тому же серверу, это полезно для сохранения состояния сеанса <br />
<code>uri</code> запросы с одним и тем же URL (до знака вопроса) будут переправляться на один и тот же сервер, это полезно для балансировки запросов к разным частям приложения <br />
<code>rdp-cookie</code> используется для балансировки запросов RDP (Remote Desktop Protocol), он анализирует cookie-заголовок RDP для принятия решений о направлении запросов</p>
<ul>
<li>server:</li>
</ul>
<p><code>ssl</code> использование SSL <br />
<code>verify none</code> отсутствие проверки сертификата <br />
<code>weight</code> распределение запросов по весу, если необходимо на определенный сервер отправлять больше запросов <br />
<code>inter</code> изменяет интервал между проверками, по умолчанию две секунды <br />
<code>fall</code> устанавливает допустимое количество неудачных проверок, по умолчанию три <br />
<code>rise</code> задает, сколько проходных проверок должно быть, прежде чем вернуть ранее отказавший сервер в ротацию, по умолчанию два <br />
<code>check port 443</code> указать явную проверку порта для конкретного сервера <br />
<code>check backup</code> параметр означает, что сервер будет использоваться только в случае, если все основные серверы становятся недоступными и не будет участвовать в балансировке, пока основные серверы функционируют</p>
<h2 id="keepalive"><a class="header" href="#keepalive">keepalive</a></h2>
<p><strong>VRRP (Virtual Router Redundancy Protocol)</strong> - сетевой протокол, предназначенный для увеличения доступности маршрутизаторов, выполняющих роль шлюза <br />
<strong>VRRP-пакеты</strong> - это специальные сообщения, которые узлы (маршрутизаторы/сервера) в VRRP-группе рассылают для сообщения своего состояния <br />
<strong>VIP (Virtual IP)</strong> - виртуальный IP адрес, который может автоматически переключаться между серверами в случае сбоя (frondend для haproxy/dns-rr), у кого в данный момент в сетевом интерфейсе прописан VIP, тот сервер и работает <br />
<strong>Master</strong> - сервер, на котором в данный момент активен VIP (отправляет VRRP-пакеты на backup nodes) <br />
<strong>Backup</strong> - сервера на которые переключится VIP, в случае сбоя мастера (следим за мастером) <br />
<strong>VRID (virtual_router_id)</strong> - сервера, объединенные общим виртуальным IP (VIP) образуют виртуальный роутер, уникальный идентификатор которого, принимает значения от 1 до 255. Сервер может одновременно состоять в нескольких VRID, при этом для каждой VRID должны использоваться уникальные виртуальные IP адреса. <br />
Master сервер с заданным интервалом отправляет VRRP пакеты на зарезервированный адрес multicast (многоадресной) рассылки или unicast на указанные ip-адреса, а все backup/slave сервера слушают этот адрес. Если Slave сервер не получает пакеты, он начинает процедуру выбора Master в соответствии с приоритетом, и если он переходит в состояние Master, то у него активирует VIP (поднимается виртуальный интерфейс) и отравляет gratuitous ARP. <br />
<strong>Gratuitous ARP</strong> - это вид ARP ответа, который обновляет MAC таблицу на подключенных коммутаторах, чтобы проинформировать о смене владельца виртуального IP-адреса и MAC-адреса для перенаправления трафика. При настройке VRRP, в качестве адреса для виртуального IP не используется реальный адрес сервера, так как, в случае сбоя, его адрес переместится на соседний, и при восстановлении, он окажется изолированным от сети, и чтобы вернуть свой адрес, нужно отправить в сеть VRRP пакет, но не будет IP адреса, с которого это возможно сделать.</p>
<p><code>nano /etc/keepalived/keepalived.conf</code></p>
<pre><code class="language-conf">global_defs {
    enable_script_security
}

vrrp_script nginx_check {
    script "/usr/bin/curl http://127.0.0.1"
    interval 5
    user nginx
}

vrrp_instance web {
    state MASTER # на втором сервере BACKUP
    interface ens33
    virtual_router_id 110
    priority 255 # на втором сервере 100
    advert_int 2
    notify /etc/keepalived/notify-web.sh root
    virtual_ipaddress {
        192.168.3.110
    }
    track_interface {
        ens333
    }
    track_script {
        nginx_check
    }
}
</code></pre>
<p><code>state &lt;MASTER|BACKUP&gt;</code> начальное состояние при запуске, в режиме nopreempt единственное допустимое значение - BACKUP <br />
<code>interface</code> интерфейс, на котором будет работать VRRP и подниматься VIP <br />
<code>virtual_router_id &lt;0-255&gt;</code> уникальный идентификатор VRRP экземпляра, должен совпадать на всех серверах одной группы <br />
<code>priority &lt;0-255&gt;</code> задает приоритет при выборе MASTER, сервер с большим числом приоритета становится MASTER <br />
<code>advert_int &lt;число секунд&gt;</code> определяет, с какой периодичностью мастер должен сообщать остальным о себе, и если по истечению данного периода сервера не получат от мастера широковещательный пакет, то они инициируют выборы нового мастера <br />
<code>nopreempt</code> если мастер пропал из сети, и был выбран новый мастер с меньшим приоритетом, то по возвращении старшего мастера, он останется в состоянии BACKUP, пока новый мастер не отвалится <br />
<code>preempt_delay</code> что бы мастером был конкретный сервер, то заменить настройку nopreempt на preempt_delay <br />
<code>notify</code> скрипт, который будет выполняться при каждом изменении состояния сервера, и имя пользователя, от имени которого данный скрипт будет выполняться (логирование или отправка на почту) <br />
<code>virtual_ipaddress</code> виртуальный IP-адрес (VIP), которые будет активирован на сервере в состоянии MASTER, должны совпадать на всех серверах внутри VRRP экземпляра <br />
<code>track_interface</code> мониторинг состояния интерфейсов, переводит VRRP экземпляр в состояние FAULT, если один из перечисленных интерфейсов находится в состоянии DOWN <br />
<code>track_script</code> мониторинг с использованием скрипта, который должен возвращать 0 если проверка завершилась успешно или 1, если проверка завершилась с ошибкой <br />
<code>fall &lt;число&gt;</code> количество раз, которое скрипт вернул не нулевое значение, при котором перейти в состояние FAULT <br />
<code>rise &lt;число&gt;</code> количество раз, которое скрипт вернул нулевое значение, при котором выйти из состояния FAULT <br />
<code>timeout &lt;число&gt;</code> время ожидания, пока скрипт вернет результат, после которого вернуть ненулевое значение</p>
<p><code>journalctl -u keepalived</code> <br />
<code>cat /var/log/messages | grep -i keepalived</code> <br />
<code>tail /var/run/keepalived.INSTANCE.web.state</code></p>
<div style="break-before: page; page-break-before: always;"></div><p>+++
title = "Go"
[extra]
toc = true
toc_sidebar = true
go_to_top = true
+++</p>
<p align="center">
    <a href="https://github.com/Lifailon/golang-cheat-sheet-ru"><img title="PS-Commands Logo"src="GoLang/GoLang-Cheat-Sheet-Logo.png"></a>
</p>
<p align="center">
    Вольный и расширенный перевод оригинального репозитория <a href="https://github.com/a8m/golang-cheat-sheet">Go Cheat Sheet</a> на русский язык.
</p>
<hr />
<h1 id="Другие-ресурсы"><a class="header" href="#Другие-ресурсы">Другие ресурсы</a></h1>
<p>Подборка полезных и бесплатных ресурсов для изучения <a href="https://go.dev/learn">Go</a> на русском языке:</p>
<ul>
<li><a href="https://github.com/Konstantin8105/Effective_Go_RU">Эффективный Go</a> - перевод официальной документации <a href="https://go.dev/doc/effective_go">Effective Go</a> (не завершен и устарел).</li>
<li><a href="https://github.com/0x0FACED/effective-go-ru">Эффективный Go</a> - перевод от сентября 2024 года.</li>
<li><a href="https://github.com/region23/gobyexample.ru">Go в примерах</a> - исходный код для сборки статического сайта <a href="https://gobyexample.ru">Go в примерах</a> (форк <a href="https://github.com/mmcgrana/gobyexample">gobyexample</a>).</li>
<li><a href="https://github.com/maxpoletaev/golang-book">Введение в программирование на Go</a> (<a href="http://golang-book.ru">веб-версия</a>) - перевод книги <a href="https://www.golang-book.com">An Introduction to Programming in Go</a>.</li>
<li><a href="https://github.com/sefus/the-little-go-book/blob/master/ru/go.md">Маленькая книга о Go</a> - перевод <a href="https://github.com/karlseguin/the-little-go-book">The Little Go Book</a>.</li>
<li><a href="https://github.com/Konstantin8105/Go-pipelines">Паттерны параллельного программирования Go</a>.</li>
<li><a href="https://golangify.com/go/kurs-izucheniya-golang-dlya-nachinayuschih">Курс по изучению Golang для начинающих</a>.</li>
<li><a href="https://code-basics.com/ru/languages/go">Обучение программированию на языке Go</a> в тренажере (онлайн компилятор).</li>
<li><a href="https://metanit.com/go/tutorial">Руководство по языку Go</a> от <em>Metanit</em>.</li>
<li><a href="https://opensource.archium.org/index.php?title=Langauge_RU">Шпаргалка по Go</a> в переводе с Немецкого языка.</li>
<li><a href="https://github.com/sau00/uber-go-guide-ru">Гайды Uber по написанию кода на Go</a> - русский перевод <a href="https://github.com/uber-go/guide">оригинального репозитория</a>.</li>
<li><a href="https://github.com/jhekasoft/articles/blob/master/01_golang_gtk3/main.md">GUI на Golang на GTK+ 3</a>.</li>
</ul>
<p>Бесплатные курсы от <em>Stepik</em> с получением сертификата:</p>
<ul>
<li><a href="https://stepik.org/course/100208/promo">Go - первое знакомство</a> - 42 урока, 110 тестов, 45 задач (20к учащихся, рейтинг: 4.9).</li>
<li><a href="https://stepik.org/course/158385/promo">PRO Go. Основы программирования</a> - 38 урока, 121 тестов, 191 задач (13к учащихся, рейтинг: 4.8).</li>
<li><a href="https://stepik.org/course/54403/promo">Программирование на Golang</a> - 35 урока, 64 тестов, 94 задач (65к учащихся, рейтинг: 4.7).</li>
</ul>
<p>Другие бесплатные курсы:</p>
<ul>
<li><a href="https://github.com/tyz910/golang-webservices?tab=readme-ov-file">Разработка веб-сервисов на Golang</a> - курс по Go от <em>Mail Ru</em> на платформе Coursera.</li>
<li><a href="https://start.practicum.yandex/go-basics">Основы Go</a> - курс от <em>Яндекс Практикум</em> (2 модуля на 30 часов).</li>
<li><a href="https://ru.hexlet.io/courses/go-basics">Основы Go</a> - курс от <em>Хек Слет</em> (34 урока, 97 тестов и 37 упражнений в тренажере).</li>
</ul>
<hr />
<h1 id="Участники"><a class="header" href="#Участники">Участники</a></h1>
<p>Если вы нашли ошибку или хотите расширить список шпаргалок, а также знаете другие источники для изучения, сообщите о них, внеся изменения через <a href="https://github.com/Lifailon/golang-cheat-sheet-ru/pulls">Pull Requests</a>.</p>
<h1 id="Источники"><a class="header" href="#Источники">Источники</a></h1>
<p>Большинство примеров кода взяты из <a href="http://tour.golang.org">официального тура по Go</a>, который является прекрасным введением для знакомства с языком.</p>
<p>Вы также можете использовать <a href="https://go.dev/play">онлайн компилятор</a> на официальном сайте для запуска и проверки блоков кода.</p>
<hr />
<h1 id="Описание-языка"><a class="header" href="#Описание-языка">Описание языка</a></h1>
<ul>
<li><strong>Императивный язык</strong>, где описывается последовательность шагов (инструкций), которые необходимо выполнить для достижения результата. В отличии от декларативных языков, где описывается результат, который нужно получить, оставляя процесс выполнения скрытым (например, как в <code>SQL</code> или <code>HTML</code>).</li>
<li><strong>Используется статическая типизация</strong> для проверка типов переменных во время компиляции. Это когда тип переменной не может быть изменен после его присвоения (например, как в <code>TypeScript</code> в отличии от <code>JavaScript</code>).</li>
<li>Синтаксис похож на <code>C</code> (но меньше скобок и нет точек с запятой в конце каждой строки), а структура — на <code>Oberon-2</code>.</li>
<li><strong>Компилируется в машинный код без использования промежуточных слоев</strong> (<code>Runtime</code>, например, как <code>JVM</code> в <code>Java</code> или <code>.NET</code> в <code>C#</code>), который должен быть установлен на машине для работы программы.</li>
<li><strong>Нет классов</strong>, но есть структуры с методами.</li>
<li><strong>Не предоставляет подклассов, основанного на типах</strong>, но имеет возможность заимствовать части реализации, встраивая типы в структуру или интерфейс (<a href="https://go.dev/doc/effective_go#embedding">embedding</a>).</li>
<li><strong>Функции могут возвращать несколько значений</strong> и их можно присваивать переменным, так как они рассматриваются как объекты.</li>
<li>Функции можно передавать в другие функции в качестве аргументов, а также функции могут возвращать другие функции как результат.</li>
<li><strong>Имеет замыкания</strong> (<code>closures</code>), которые позволяют функциям хранит и использовать переменные из внешней области видимости, даже если она выполняется в другом контексте (например, за пределами этой области).</li>
<li><strong>Невозможно напрямую изменять значение указателя с помощью арифметических операций</strong> (например, <code>ptr++</code>). Это нужно, что бы исключить возможные ошибки, такие как выход за пределы памяти или доступ к неправильным участкам памяти.</li>
<li><strong>Встроенные примитивы параллелизма</strong>: горутины и каналы.</li>
<li><strong>Поддерживаются динамические и статические срезы</strong> (<code>slices</code>, аналог списков или массивов в других языках, где элементы хранятся в порядке их добавления и индексируются числами), а также <strong>карты</strong> (<code>maps</code>, аналог словарей или хэш-таблиц, где содержится уникальный ключ и его значение).</li>
</ul>
<hr />
<h1 id="Базовый-синтаксис"><a class="header" href="#Базовый-синтаксис">Базовый синтаксис</a></h1>
<h2 id="Привет-мир"><a class="header" href="#Привет-мир">Привет мир</a></h2>
<p>Файл <code>hello.go</code>:</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    fmt.Println("Hello Go")
}
</code></pre>
<p>Запуск:</p>
<p><code>go run hello.go</code></p>
<p>Выведет на экран <code>Hello Go</code></p>
<h2 id="Операторы"><a class="header" href="#Операторы">Операторы</a></h2>
<h3 id="Арифметика"><a class="header" href="#Арифметика">Арифметика</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Оператор</th><th>Описание</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>сложение</td></tr>
<tr><td><code>-</code></td><td>вычитание</td></tr>
<tr><td><code>*</code></td><td>умножение</td></tr>
<tr><td><code>/</code></td><td>деление *</td></tr>
<tr><td><code>%</code></td><td>остаток</td></tr>
<tr><td><code>&amp;</code></td><td>побитовое <code>и</code></td></tr>
<tr><td><code>|</code></td><td>побитовое <code>или</code></td></tr>
<tr><td><code>^</code></td><td>побитовое <code>исключающее или</code> * *</td></tr>
<tr><td><code>&amp;^</code></td><td>очистить бит (<code>и нет</code>) * * *</td></tr>
<tr><td><code>&lt;&lt;</code></td><td>сдвиг влево * * * *</td></tr>
<tr><td><code>&gt;&gt;</code></td><td>сдвиг вправо</td></tr>
</tbody></table>
</div>
<p>* Если оба операнда имеют целый тип (<code>int</code>, <code>int8</code>, <code>int32</code>, <code>int64</code>), результат также будет целым числом, при этом остаток отбрасывается. Если хотя бы один из операндов имеет тип с плавающей точкой (<code>float32</code>, <code>float64</code>), результат будет дробным числом.</p>
<p>* * Возвращает <code>0</code>, если биты двух операндов равны, или <code>1</code>, если биты двух операндов различны.</p>
<p>* * * Возвращает <code>0</code>, если соответствующий бит второго операнда равен <code>1</code>, или бит первого операнда (<code>0</code> или <code>1</code>), если соответствующий бит второго операнда равен <code>0</code>.</p>
<p>* * * * Сдвигает все биты числа влево на указанное количество позиций (аналог умножения числа на <code>2</code> в степени количества сдвигов), а новые биты справа заполняются нулями.</p>
<h3 id="Сравнение"><a class="header" href="#Сравнение">Сравнение</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Оператор</th><th>Описание</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>равно</td></tr>
<tr><td><code>!=</code></td><td>не равно</td></tr>
<tr><td><code>&lt;</code></td><td>меньше</td></tr>
<tr><td><code>&lt;=</code></td><td>меньше или равно</td></tr>
<tr><td><code>&gt;</code></td><td>больше</td></tr>
<tr><td><code>&gt;=</code></td><td>больше или равно</td></tr>
</tbody></table>
</div>
<h3 id="Логика"><a class="header" href="#Логика">Логика</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Оператор</th><th>Описание</th></tr></thead><tbody>
<tr><td><code>&amp;&amp;</code></td><td>логическое <code>и</code></td></tr>
<tr><td><code>||</code></td><td>логическое <code>или</code></td></tr>
<tr><td><code>!</code></td><td>логическое отрецание</td></tr>
</tbody></table>
</div>
<h3 id="Другие"><a class="header" href="#Другие">Другие</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Оператор</th><th>Описание</th></tr></thead><tbody>
<tr><td><code>&amp;</code></td><td>адрес / создать указатель</td></tr>
<tr><td><code>*</code></td><td>разыменовать указатель</td></tr>
<tr><td><code>&lt;-</code></td><td>оператор отправки / получения</td></tr>
</tbody></table>
</div>
<h2 id="Декларации"><a class="header" href="#Декларации">Декларации</a></h2>
<p>Тип указывается после идентификатора (названия переменной):</p>
<pre><code class="language-go">var foo int                 // объявление без инициализации значения
var foo int = 42            // объявление с инициализацией
var foo, bar int = 42, 1302 // объявить и инициализировать несколько переменных одновременно
var foo = 42                // тип пропущен, будет выведен
foo := 42                   // сокращение при объявление переменной (ключевое слово var опущено, тип данных определяется автоматически)
const constant = "Это константа, которая используется для хранения неизменяемых данных"

// iota можно использовать для увеличения числа, начиная с 0
const (
    _ = iota
    a
    b
    c = 1 &lt;&lt; iota
    d
)
    fmt.Println(a, b) // 1 2 (0 - пропускается)
    fmt.Println(c, d) // 8 16 (2^3, 2^4)
</code></pre>
<h2 id="Функции"><a class="header" href="#Функции">Функции</a></h2>
<pre><code class="language-go">// Простая функция
func functionName() {}

// Функция с параметрами (тип идет после идентификаторов)
func functionName(param1 string, param2 int) {}

// Несколько параметров одного типа
func functionName(param1, param2 int) {}

// Объявление типа для возвращаемого значения (идет после скобок параметров или во вторых скобках, если значений несколько)
func functionName() int {
    return 42
}

// Может возвращать несколько значений одновременно
func returnMulti() (int, string) {
    return 42, "foobar"
}
var x, str = returnMulti()

// Возвращаем несколько именованных результатов
func returnMulti2() (n int, s string) {
    n = 42
    s = "foobar"
    // Будут возвращены все значения объявленных переменных "n" и "s"
    return
}
var x, str = returnMulti2()

func main() {
    // Присвоить функцию переменной
    add := func(a, b int) int {
        return a + b
    }
    // Используйте имя переменной для вызова функции
    fmt.Println(add(3, 4))
}
</code></pre>
<h3 id="Замыкания"><a class="header" href="#Замыкания">Замыкания</a></h3>
<pre><code class="language-go">// Дочерние функции могут получить доступ к переменным, объявленным в родительской функции
func scope() func() int{
    outer_var := 2
    foo := func() int { return outer_var}
    return foo
}

func another_scope() func() int{
    // Не скомпилируется, потому что "outer_var" и "foo" не определены в данной области видимости
    outer_var = 444
    return foo
}

func outer() (func() int, int) {
    outer_var := 2
    inner := func() int {
        outer_var += 99 // переменная изменена из внешней области
        return outer_var
    }
    inner()
    return inner, outer_var // вернуть результат внутренней функции и переменной с результатом 101
}
</code></pre>
<h3 id="Вариативные-функции"><a class="header" href="#Вариативные-функции">Вариативные функции</a></h3>
<p>Вариативная функция работает и вызывается как любая другая функция, за исключением того, что в нее возможно передать произвольное количество аргументов, используя <code>...</code> перед типом данных указанного параметра.</p>
<pre><code class="language-go">func main() {
    fmt.Println(adder(1, 2, 3)) // 6
    fmt.Println(adder(9, 9))    // 18

    nums := []int{10, 20, 30}
    fmt.Println(adder(nums...)) // 60
}

func adder(args ...int) int {
    total := 0
    for _, v := range args { // перебирает все переданные аргументы в цикле
    	total += v
    }
    return total
}
</code></pre>
<h2 id="Типы-данных"><a class="header" href="#Типы-данных">Типы данных</a></h2>
<pre><code class="language-go">bool // логический тип (принимает true или false)

string // строка (текст)

int  int8  int16  int32  int64 // целое число
uint uint8 uint16 uint32 uint64 uintptr // беззнаковый целочисленный тип размером

byte // псевдоним для uint8

rune // псевдоним для int32 ~= символ (кодовая точка Unicode)

float32 float64 // число с плавающей точкой одинарной и двойной точности

complex64 complex128 // комплексное число (1 + 2i или 3.14 + 4.2i), имеющие реальную и мнимую часть

interfae{} // универсальный тип, который может позволяет работать с переменными неизвестного или изменяющегося типа
</code></pre>
<p>Все предварительно объявленные идентификаторы <code>Go</code> определены в пакете <a href="https://golang.org/pkg/builtin">builtin</a>.</p>
<h2 id="Преобразование-типов"><a class="header" href="#Преобразование-типов">Преобразование типов</a></h2>
<pre><code class="language-go">var i int = 42
var f float64 = float64(i)  // преобразуем тип данных int в float64
var u uint = uint(f)        // преобразуем тип данных float64 в unit

// Альтернативный синтаксис
i := 42
f := float64(i)
u := uint(f)
</code></pre>
<h2 id="Структуры-управления"><a class="header" href="#Структуры-управления">Структуры управления</a></h2>
<h3 id="Условия-if"><a class="header" href="#Условия-if">Условия if</a></h3>
<pre><code class="language-go">func main() {
    // Базовый
    if x &gt; 10 {
    	return x
    } else if x == 10 {
    	return 10
    } else {
    	return -x
    }

    // Возможно поставить одно утверждение перед условием
    if a := b + c; a &lt; 42 {
    	return a
    } else {
    	return a - 42
    }

    // Утверждение (проверка) типа внутри условия
    var val interface{} = "foo"
    // Проверяется, содержит ли переменная val значение типа string
    if str, ok := val.(string); ok {
        // Если тип не совпадает, значение не вернется.
        // При этом panic не вызывается, т.к. используется безопасное утверждение типа (ok)
    	fmt.Println(str)
    }
}
</code></pre>
<h3 id="Условия-switch"><a class="header" href="#Условия-switch">Условия switch</a></h3>
<p>После выполнения условия при использование переключателей, прерывания обрабатываются автоматически.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "os"
)

func main() {
    var operatingSystem string = runtime.GOOS
    // Используем оператор (ключевое слово) switch
    switch operatingSystem {
    case "darwin":
        fmt.Println("Используется macOS")
    case "linux":
        fmt.Println("Используется Linux")
    // Условие по умолчанию (аналог else в if)
    default:
        fmt.Println("Используется Windows, OpenBSD, FreeBSD или другая")
    }
}

// Как в случае с "for" и "if", возможно иметь оператор присваивания перед значением switch
switch os := runtime.GOOS; os {
    case "darwin": ...
}

// Возможно использовать сравнения
number := 42
switch {
    case number &lt; 42:
        fmt.Println("Переданное значение:", number, "меньше 42 в условие")
    case number == 42:
        fmt.Println("Переданное значение:", number, "равно 42 в условие")
    case number &gt; 42:
        fmt.Println("Переданное значение:", number, "больше 42 в условие")
}

// Все случаи могут быть представлены в виде списков, разделенных запятыми
var char byte = '?'
switch char {
    case ' ', '?', '&amp;', '=', '#', '+', '%':
        fmt.Println("Переданное значение присутствует в списке")
}
</code></pre>
<h3 id="Циклы"><a class="header" href="#Циклы">Циклы</a></h3>
<p>В <code>Go</code> используются только универсальные циклы <code>for</code>, другие операторы (например, <code>while</code> или <code>until</code>) отсутствуют.</p>
<pre><code class="language-go">// Используется 9 интераций с 1 по 9 (до 10)
for i := 1; i &lt; 10; i++ {
}
// Цикл (loop) - while
for ; i &lt; 10;  {
}
// Если есть только условие, точки с запятой опускаются
for i &lt; 10  {
}
// Если опустить условие, равноценно использованию while (true)
for {
}
    
// Использование пропуска и прерывания в цикле
// Метка here (произвольное имя) позволяет указать целевой цикл, на который будут ссылаться операторы continue и break
here:
    // Используем 2 интерации в внешнем цикле (от 0 до 1)
    for i := 0; i &lt; 2; i++ {
        // Внутренний цикл: переменная j начинается с i+1 и проходит до 3
        for j := i + 1; j &lt; 3; j++ {
            if i == 0 {
                // Пропустить интерацию внешнего цикла по названию его метки
                continue here
            }
            fmt.Println(j)
            if j == 2 {
                // Завершить внутренний цикл
                break
            }
        }
    }

// 1-я интерация: внешний цикл с значением i=0 в внутреннем цикле пропускает интерацию внешнего цикла, т.к. срабатывает условие i==0
// 2-я интерация: внешний цикл с значением i=1 в внутреннем цикле пропускает условие i==0
// Переменная j получает значение 2, которое печатается и завершает внутренний (текущий) цикл во втором условие
// Программа завершается, т.к. интерации внешнего цикла закончились

there:
    for i := 0; i &lt; 2; i++ {
        for j := i + 1; j &lt; 3; j++ {
            if j == 1 {
                // Пропускаем интерацию внутреннего цикла
                continue
            }
            fmt.Println(j)
            if j == 2 {
                // Завершаем выполнение внешнего цикла
                break there
            }
        }
    }
</code></pre>
<h3 id="Примеры-циклов"><a class="header" href="#Примеры-циклов">Примеры циклов</a></h3>
<pre><code class="language-go">package main

import "fmt"

// Функция, возвращающая название месяца через условную конструкцию switch
func getMonthName(month int) string {
    switch month {
    case 1:
        return "January"
    case 2:
        return "February"
    case 3:
        return "March"
    case 4:
        return "April"
    case 5:
        return "May"
    case 6:
        return "June"
    case 7:
        return "July"
    case 8:
        return "August"
    case 9:
        return "September"
    case 10:
        return "October"
    case 11:
        return "November"
    case 12:
        return "December"
    default:
        return "Invalid month (range: 1-12)"
    }
}

// Второй вариант функции через классическое условие по индеку массива
func getMonthName2(month int) string {
    months := []string{"", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}
    if month &gt;= 1 &amp;&amp; month &lt;= 12 {
        return months[month]
    }
    return "Invalid month"
}

func main() {
    // Классический цикл из 13-ти итераций
    for i := 1; i &lt;= 13; i++ {
        fmt.Printf("Month %d: %s\n", i, getMonthName(i))
    }

    // Увеличение индекса итерации в теле цикла
    j := 1
    for j &lt;= 13 {
        fmt.Printf("Month %d: %s\n", j, getMonthName(j))
        j++
    }

    // Бесконечный цикл
    months := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
    k := 0
    for {
        // Пропускаем итерацию, если 6-й месяц (5-й индекс)
        if k == 5 {
            k++ // переход к следующей итерации
            continue
        }
        // Выходим из цикла, если индекс больше или равен длине массива
        if k &gt;= len(months) {
            break
        }
        fmt.Printf("Month %d: %s\n", months[k], getMonthName(months[k]))
        k++
    }

    // Конструкция range используется для перебора всех элементов в коллекциях (массивы, слайсы, карты и каналы)
    for _, month := range months {
        fmt.Printf("Month %d: %s\n", month, getMonthName(month))
    }

    // Индекс может использоваться для карты (map) как ключ
    m := map[string]int{"a": 1, "b": 2, "c": 3}
    for index, value := range m {
        fmt.Println("Key:", index, "Value:", value)
    }

    // Перебор строки по символам
    s := "string"
    for index, char := range s {
        fmt.Println("Index:", index, "Char:", string(char))
    }

    // Перебор канала
    ch := make(chan int, 3)
    ch &lt;- 1
    ch &lt;- 2
    ch &lt;- 3
    close(ch)
    for val := range ch {
        fmt.Println(val)
    }
}
</code></pre>
<h2 id="Типы-последовательностей"><a class="header" href="#Типы-последовательностей">Типы последовательностей</a></h2>
<p>Массивы, срезы и диапазоны представляют собой структуры данных, хранящие упорядоченные наборы значений.</p>
<h3 id="Статические-срезы-массивы"><a class="header" href="#Статические-срезы-массивы">Статические срезы (массивы)</a></h3>
<p>Статические срезы подразумеваются как массивы.</p>
<pre><code class="language-go">var a [10]int // объявить массив int длиной 10 (длина массива является частью типа)
a[3] = 42     // присвоить значение элементу, по его порядковому номеру
i := a[3]     // прочитать элементы

// Возможные варианты объявление с инициализацией значений
var a = [2]int{1, 2}
// Массив из двух элементов: [1 2]
a := [2]int{1, 2}
// Многоточие используется компилятором для вычисления длины массива
a := [...]int{1, 2}
</code></pre>
<h3 id="Динамические-срезы"><a class="header" href="#Динамические-срезы">Динамические срезы</a></h3>
<p>Динамический срез объявляется аналогично статическому, но длина не указывается.</p>
<pre><code class="language-go">var a []int                                 // объявить срез
var a = []int {1, 2, 3, 4}                  // объявить и инициализировать срез
a := []int{1, 2, 3, 4}                      // [1 2 3 4]
chars := []string{0:"a", 2:"c", 1: "b"}     // [a b c]

var b = a[lo:hi]                            // создать срез от индекса lo до hi-1
var b = a[1:4]                              // срез c индекса 1 по 3 (до 4)
var b = a[:3]                               // отсутствие первого индекса подразумевает 0
var b = a[3:]                               // отсутствие последнего индекса подразумевает len(a) (т.е. последний идекс по длинне индекса)
a =  append(a,17,3)                         // добавление элементов к срезу a с помощью функции append
c := append(a,b...)                         // объединение срезов a и b

a = make([]byte, 5, 5)                      // первый аргумент длина, второй емкость
a = make([]byte, 5)                         // емкость необязательна

x := [3]string{"Лайка", "Белка", "Стрелка"} // создаем массив
s := x[:]                                   // создать срез из массива
</code></pre>
<h3 id="Операции-с-срезами"><a class="header" href="#Операции-с-срезами">Операции с срезами</a></h3>
<p><code>len(a)</code> возвращает длину среза/массива. Это встроенная функция, а не метод массива.</p>
<pre><code class="language-go">// Цикл по массиву/срезу
for i, e := range a {
    // "i" — индекс, "e" — элемент
}

// Если нужен только элемент "e"
for _, e := range a {
    // Используется только элемент "e"
}

// Если нужен только индекс
for i := range a {
}
</code></pre>
<h2 id="Карты"><a class="header" href="#Карты">Карты</a></h2>
<pre><code class="language-go">package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

func main() {
    m := make(map[string]int) // объявить карту
    m["key"] = 42             // инициализировать карту
    fmt.Println(m["key"])     // вывести содержимое значения (value) по его уникальному названию клчюча
    delete(m, "key")          // удалить элемент из карты
    elem, ok := m["key"]      // проверка, если ключ присутствует, то получить его значение
    fmt.Println(ok, elem)

    var m2 = map[string]Vertex{
        "Bell Labs": {40.68433, -74.39967},
        "Google":    {37.42202, -122.08408},
    }

    // Перебрать содержимое карты в цикле
    for key, value := range m2 {
        fmt.Println(key)
        fmt.Println(value)
    }
}
</code></pre>
<h2 id="Примеры-срезов-и-карт"><a class="header" href="#Примеры-срезов-и-карт">Примеры срезов и карт</a></h2>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // Массив фиксированного размера с 5-ю элементами, все элементы инициализируются значением 0 (по умолчанию для типа int)
    var arr [5]int
    // Присвоить значения указанным элементам массива по индексу
    arr[0] = 1
    arr[1] = 2
    fmt.Println("Array:", arr)
    
    // Слайсы (массивы переменной длины)
    slice := []int{1, 2, 3, 4, 5}
    // Добавить новое значение в массив с помощью функции append
    slice = append(slice, 6)
    // Удалить элемент с индексом 5
    index := 4
    // Создается 2 слайса с начала до указанного индекса и срез с следующего элемента после индекса (+1) до конца слайса
    slice = append(slice[:index], slice[index+1:]...)
    fmt.Println("Slice:", slice) // [1, 2, 3, 4, 6]
    // Вывести срез слайсов по индексу с 1 и до 4 (по 3, не включая 4) элемент
    fmt.Println(slice[1:4]) // [2, 3, 4]
    // Очистить слайс (удалить все элементы)
    slice = slice[:0] // []
    fmt.Println(len(slice) == 0) // true
    // Объединение двух слайсов
    slice1 := []int{1, 2}
    slice2 := []int{3, 4}
    combined := append(slice1, slice2...)
    fmt.Println(combined) // [1, 2, 3, 4]

    // Слайс с заданной вместимостью:
    makeSlice := make([]int, 5, 10)
    fmt.Println(makeSlice) // [0 0 0 0 0]
    fmt.Println(cap(makeSlice)) // 10

    // Создаем пустую карту (map) с ключами типа string и значениями типа int
    m := make(map[string]int)
    m["Day"] = 30       // добавляем элемент с ключом "Day" и значением 30
    m["Day"] = 31       // обновляем  значение для ключа
    m["Month"] = 12
    fmt.Println(m) // map[Day:31 Month:12]
    // Создать карту с заданными значениями
    m2 := map[string]int{
        "Day": 31,
        "Month": 12,
    }
    // Читаем значение
    value := m2["Day"]
    fmt.Println(value) // 31
    // Если ключа нет в карте, то получаем нулевое значение для типа значения
    value, exists := m["Year"]
    fmt.Println(value, exists) // 0 false
    // Удалить элемент
    delete(m, "Day")
    fmt.Println(m) // map[Month:12]
}
</code></pre>
<h2 id="Структуры"><a class="header" href="#Структуры">Структуры</a></h2>
<p>Вместо классов (<code>class</code>) в <code>Go</code> используются структуры (тип данных <code>struct</code>), которые могут иметь методы. Поля структуры всегда инициализируются нулевыми значениями при её объявлении.</p>
<pre><code class="language-go">// Объявление структуры с названием Vertex с помощью ключевого слова "type"
type Vertex struct {
    X, Y float64
}

// Создание структуры
var v = Vertex{1, 2}                // инициализация данных в структуре
var v = []Vertex{{1,2},{5,2},{5,5}} // инициализация среза в структуре
var v = Vertex{X: 1, Y: 2}          // создание структуры с опредилением значений с помощью ключей
v.X = 4                             // доступ к значениям

// Объявление метода (принимающий тип), находится между ключевым словом func и именем метода
// Структура копируется при каждом вызове метода
func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

// Вызов метода
v.Abs()

// Для мутирующих методов необходимо использовать указатель (см. ниже) на Struct в качестве типа
// При этом значение структуры не копируется для вызова метода
func (v *Vertex) add(n float64) {
    v.X += n
    v.Y += n
}
</code></pre>
<h3 id="Анонимные-структуры"><a class="header" href="#Анонимные-структуры">Анонимные структуры</a></h3>
<p>Безопаснее и дешевле, чем использование <code>map[string]interface{}</code>.</p>
<pre><code class="language-go">point := struct {
	X, Y int
} {1, 2}
</code></pre>
<h3 id="Указатели"><a class="header" href="#Указатели">Указатели</a></h3>
<pre><code class="language-go">p := Vertex{1, 2}  // "p" это структура Vertex
q := &amp;p            // "q" указывает на структуру Vertex
r := &amp;Vertex{1, 2} // "r" также указывает на структуру Vertex

// Объявление переменной с указателем на структуру *Vertex
var s *Vertex = new(Vertex) // функция "new" создает указатель на новый экземпляр структуры
</code></pre>
<h2 id="Интерфейсы"><a class="header" href="#Интерфейсы">Интерфейсы</a></h2>
<p><strong>Интерфейс</strong> - это набор методов (требований), которые должен иметь тип, чтобы соответствовать этому интерфейсу.</p>
<pre><code class="language-go">// Объявление интерфейса с одинм методом Awesomize(), который возвращает строку
type Awesomizer interface {
    Awesomize() string
}

// Обычная структура, которая может реализовывать методы
type Foo struct {}

// Добавление (реализация) метода Awesomize() в структуре Foo
// Тип автоматически соответствует интерфейсу, если он реализует все его методы
func (foo Foo) Awesomize() string {
    return "Awesome!"
}
</code></pre>
<h2 id="Встраивание"><a class="header" href="#Встраивание">Встраивание</a></h2>
<p>В <code>Go</code> нет подклассов, вместо этого используется встраивание интерфейса и структуры, которое добавляет методы встроенной структуры к внешней.</p>
<pre><code class="language-go">// В структуру Server встраиваются все методы, которые есть у метода Logger из структуры log
type Server struct {
    Host string
    Port int
    *log.Logger
}

// Структура Server инициализируется с помощью указателя на log.Logger
server := &amp;Server{"localhost", 80, log.New(...)}

// Когда вызывается server.Log(...), Go автоматически перенаправляет вызов к server.Logger.Log(...).
server.Log(...)

// Поле встроенного типа доступно через его имя, по этому переменной можно присвоить ссылку на server.Logger
var logger *log.Logger = server.Logger
</code></pre>
<h2 id="Обработка-ошибок"><a class="header" href="#Обработка-ошибок">Обработка ошибок</a></h2>
<p>Обработка исключений отсутствует. Вместо этого функции, которые могут выдать ошибку, просто объявляют дополнительное возвращаемое значение типа <a href="https://golang.org/pkg/builtin/#error">error</a> (чаще всего вторым возвращаемым параметром).</p>
<p>Встроенный тип интерфейса <code>error</code> — это общепринятый интерфейс для представления состояния ошибки, при этом нулевое значение не представляет ошибки.</p>
<pre><code class="language-go">type error interface {
    Error() string
}
</code></pre>
<p>Пример:</p>
<pre><code class="language-go">package main

import (
    "errors"
    "fmt"
    "math"
)

// Определение функции sqrt должно быть вне main
func sqrt(x float64) (float64, error) {
    if x &lt; 0 {
        // Создаем объект типа error с текстовым описанием ошибки
        return 0, errors.New("ошибка: отрицательное значение")
    }
    return math.Sqrt(x), nil
}

func main() {
    val, err := sqrt(-1)
    if err != nil {
        // Обработка ошибки
        fmt.Println(err) // отрицательное значение
        return
    }
    // Если все хорошо (переданное значение не отрицательное), вывести содержимое "val"
    fmt.Println(val)
}
</code></pre>
<h1 id="Параллелизм"><a class="header" href="#Параллелизм">Параллелизм</a></h1>
<h2 id="Горутины"><a class="header" href="#Горутины">Горутины</a></h2>
<p><strong>Горутины</strong> — это легковесные потоки (управляемые <code>Go</code>, а не потоками ОС).</p>
<p><code>go f(a, b)</code> запускает новую горутину, которая запускает <code>f</code> (при условии, что <code>f</code> — это функция).</p>
<pre><code class="language-go">// Просто функция (которая позже может быть запущена в горутине)
func doStuff(s string) {
    fmt.Println(s)
}

func main() {
    // Запуск существующий функции в горутине по ее имени
    go doStuff("foobar")

    // Использование анонимной внутренней функции в горутине
    go func (x int) {
        fmt.Println(x)
    } (42) // Параметр анонимной функции
}
</code></pre>
<h2 id="Синхронизация"><a class="header" href="#Синхронизация">Синхронизация</a></h2>
<p>Пакет <code>sync</code> используется для ожидания завершения всех запущенных горутин.</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

func doStuff(s string, wg *sync.WaitGroup) {
    fmt.Println(s)
    defer wg.Done()
}

func main() {
    // Объект для отслеживания завершение групп горутин
    var wg sync.WaitGroup

    // Задаем счетчик для запуска 2-х горутин
    wg.Add(2)

    // Запуск функции в горутине
    go doStuff("foobar", &amp;wg)

    // Запуск анонимной функции в горутине
    go func(x int, wg *sync.WaitGroup) {
        fmt.Println(x)
        // Уменьшить счётчик WaitGroup, когда горутина завершится
        defer wg.Done()
    }(42, &amp;wg)

    // Ожидание завершения всех горутин
    wg.Wait()
}
</code></pre>
<h2 id="Таймер"><a class="header" href="#Таймер">Таймер</a></h2>
<p>Таймеры из пакета <code>time</code> используются для задержки (паузы) на указанное время:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func goRun() {
    // Симуляция работы
    time.Sleep(2 * time.Second)
    fmt.Println("Выполнение горутины завершено")
}

func main() {
    // Запуск горутины
    go goRun()
     // Основная функция продолжает работать параллельно
    fmt.Println("Запуск выполнения основной функции и ожидание завершения горутины")
    // Ждем завершения выполнения горутины
    time.Sleep(3 * time.Second)
}
</code></pre>
<h2 id="Небуферизованный-канал"><a class="header" href="#Небуферизованный-канал">Небуферизованный канал</a></h2>
<p><strong>Небуферизованный канал</strong> блокирует операцию записи, пока не будет выполнено чтение, и наоборот.</p>
<pre><code class="language-go">// Создаем небуферизованный канал типа "int"
ch := make(chan int)
// Отправляем значение 42 в канал "ch"
// Операция блокирует текущую горутину, пока другая горутина не прочитает его значение
ch &lt;- 42
// Получаем значение из канала "ch"
// Это также блокирует выполнение, пока не будет доступно значение для чтения в канале
v := &lt;-ch
</code></pre>
<h2 id="Буферизованный-канал"><a class="header" href="#Буферизованный-канал">Буферизованный канал</a></h2>
<p><strong>Буферизованный канал</strong> позволяет отправлять и получать данные без блокировки, пока размер буфера не будет превышен, как только буфер заполняется, запись блокируется, пока другие горутины не начнут извлекать значения из канала.</p>
<p><strong>Закрытие канала</strong> — это сигнал получателю, что больше значений не будет отправляться в канал, при этом отправленные в него данные не удаляются. Это необходимо для того, чтобы получатели знали, что можно завершить чтение. Закрытие канала происходило только в той горутине, которая отправляет данные.</p>
<pre><code class="language-go">package main

import "fmt"

func main() {
    // Создаем буферизованный канал с размером буфера 100
    ch := make(chan int, 100)

    // Отправляем некоторое количество значений в канал
    for i := 0; i &lt; 10; i++ {
        ch &lt;- i
    }

    // Закрываем канал, чтобы цикл мог завершиться
    close(ch)

    // Читать из канала, пока он не будет закрыт
    for i := range ch {
        fmt.Println(i)
    }

    // Прочитать данные из канала и проверить, закрыт ли он
    v, ok := &lt;-ch
    if !ok {
        fmt.Println("Канал закрыт, данные не доступны")
    } else {
        fmt.Println("Прочитано из канала:", v)
    }
}
</code></pre>
<p>Вывод: <code>0 1 2 3 4 5 6 7 8 9 Канал закрыт, данные не доступны</code></p>
<h2 id="Селекторы"><a class="header" href="#Селекторы">Селекторы</a></h2>
<p>Оператор <code>select</code> работает как многоканальный оператор <code>switch</code>. Выбор блоков в операциях с несколькими каналами, если один из них разблокируется, выполняется соответствующие условие. Он блокируется до тех пор, пока одно из выражений <code>case</code> не будет готов к выполнению, при этом остальные игнорируются.</p>
<pre><code class="language-go">package main

import (
	"fmt"
	"time"
)

func doStuff(channelOut, channelIn chan int) {
    select {
    case channelOut &lt;- 42:
        fmt.Println("Отправить значение 42 в channelOut")
    case x := &lt;-channelIn:
        fmt.Println("Прочитать из channelIn:", x)
    case &lt;-time.After(time.Second * 1):
        fmt.Println("Задержка в одну секунду")
    }
}

func main() {
    // Создание двух каналов (один для записи, другой для чтения)
    channelOut := make(chan int)
    channelIn := make(chan int)

    // Запуск горутины для записи в канал "channelOut"
    go func() {
        time.Sleep(500 * time.Millisecond) // Пауза перед отправкой
        channelOut &lt;- 42                   // Отправить значение 42
        fmt.Println("Значение 42 отправлено в channelOut")
    }()

    // Запуск горутины для чтения из канала "channelIn"
    go func() {
        time.Sleep(200 * time.Millisecond) // Пауза перед отправкой
        channelIn &lt;- 99                    // Отправить значение 99
        fmt.Println("Значение 99 отправлено в channelIn")
    }()

    // Запуск функции doStuff с двумя каналами
    doStuff(channelOut, channelIn)
}
</code></pre>
<h2 id="Аксиомы-канала"><a class="header" href="#Аксиомы-канала">Аксиомы канала</a></h2>
<p>Отправка в пустой канал блокируется навсегда и вызывает фатальную ошибку:</p>
<pre><code class="language-go">var c chan string
c &lt;- "Hello, World!"
</code></pre>
<p>Чтение из нулевого канала блокируется навсегда:</p>
<pre><code class="language-go">var c chan string
fmt.Println(&lt;-c)
</code></pre>
<p>Отправка в закрытый канал вызывает панику:</p>
<pre><code class="language-go">var c = make(chan string, 1)
c &lt;- "Hello, World!"
close(c)
c &lt;- "Hello, Panic!"
</code></pre>
<p>Прием из закрытого канала немедленно возвращает нулевое значение:</p>
<pre><code class="language-go">var c = make(chan int, 2)
c &lt;- 1
c &lt;- 2
close(c)
for i := 0; i &lt; 3; i++ {
    fmt.Printf("%d ", &lt;-c)
}
// 1 2 0
</code></pre>
<h2 id="Примеры-каналов-и-горутин"><a class="header" href="#Примеры-каналов-и-горутин">Примеры каналов и горутин</a></h2>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
    "sync"
)

func goRun(ch chan string) {
    time.Sleep(2 * time.Second)
    // Возвращяем сообщене о выполнение в канал
    ch &lt;- "Первая горутина завершена за 2 секунды"
}

func goRunThree(ch chan string) {
    time.Sleep(3 * time.Second)
    ch &lt;- "Вторая горутина завершена за 3 секунды"
}

func printMessage(msg string, wg *sync.WaitGroup) {
    // Уменьшает счётчик в WaitGroup, когда горутина завершена
    defer wg.Done()
    fmt.Println(msg)
}

func main() {
    // Создаем канал
    ch := make(chan string)
    // Запускаем горутину
    go goRun(ch)
    fmt.Println("Ожидаем завершения горутины в канале")
    // Блокируем main, пока не получим сообщение от горутины
    result := &lt;-ch
    // После получения вывода, программа продолжает выполнение
    fmt.Println(result)

    // Создаем два канала и запускаем две горутины
    ch1 := make(chan string)
    ch2 := make(chan string)
    go goRun(ch1)
    go goRunThree(ch2)
    fmt.Println("Ожидаем завершения первой выполненной горутины")
    // Используем select для ожидания данных с двух каналов и выбора первого завершенного канала
    select {
    case msg1 := &lt;-ch1:
        fmt.Println("Ответ:", msg1)
    case msg2 := &lt;-ch2:
        fmt.Println("Ответ:", msg2)
    }
    
    // Создаем группу ожидания для синхронизации выполнения нескольких горутин
    var wg sync.WaitGroup
    fmt.Println("Ожидаем выполнения всех запущенных горутин")
    // Указать количество горутин, за которыми нужно следить
    wg.Add(2)
    go printMessage("Результат первой горутины", &amp;wg)
    go printMessage("Результат второй горутины", &amp;wg)
    // Ожидаем завершения всех горутин
    wg.Wait()
    fmt.Println("Все горутины завершили свою работу")
}
</code></pre>
<h1 id="Вывод"><a class="header" href="#Вывод">Вывод</a></h1>
<pre><code class="language-go">package main

import "fmt"

func main() {
    fmt.Println("Hello, 你好, नमस्ते, Привет, ᎣᏏᏲ") // базовый вывод
    p := struct{ X, Y int }{17, 2}
    fmt.Println("My point:", p, "x coord=", p.X)       // вывод структуры, цифр
    s := fmt.Sprintln("My point:", p, "x coord=", p.X) // вывод в переменную с типом данных string
    fmt.Println(s)

    fmt.Printf("%d hex:%x bin:%b fp:%f sci:%e", 17, 17, 17, 17.0, 17.0) // C-образный формат
    s2 := fmt.Sprintf("%d %f", 17, 17.0)                                // форматировать вывод в переменную с типом данных string
    fmt.Println(s2)

	// Многострочный строковый литерал
    hellomsg := `
        "Hello" in Chinese is 你好 ('Ni Hao')
        "Hello" in Hindi is नमस्ते ('Namaste')
    `
    fmt.Println(hellomsg)
}

</code></pre>
<h1 id="Переключение-типа"><a class="header" href="#Переключение-типа">Переключение типа</a></h1>
<p>Переключение типа похоже на обычный оператор <code>switch</code>, но в условиях указывается типы (а не на значения), которые сравниваются с типом значения, содержащегося в данном значении интерфейса.</p>
<pre><code class="language-go">package main

import "fmt"

func do(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf("Число %v равно %v по типу данных\n", v, v*2)
    case string:
        fmt.Printf("Значение %q равно %v bytes\n", v, len(v))
    default:
        fmt.Printf("Тип %T неизвестен\n", v)
    }
}

func main() {
    do(21)
    do("hello")
    do(true)
}

// Число 21 равно 42 по типу данных
// Значение "hello" равно 5 bytes
// Тип bool неизвестен
</code></pre>
<h1 id="Встроенные-пакеты"><a class="header" href="#Встроенные-пакеты">Встроенные пакеты</a></h1>
<ul>
<li>Декларация пакета (объявление через <code>import</code>) производится в начале каждого исходного файла.</li>
<li>Исполняемые файлы находятся в пакете <code>main</code>.</li>
<li>Имя пакета соответствует последнему имени в пути импорта (например, <code>math/rand</code> - пакет <code>rand</code>).</li>
<li>Идентификатор функции в верхнем регистре является экспортируемый (доступны из других пакетов).</li>
<li>Идентификатор функции в нижнем регистре является частный (недоступны из других пакетов).</li>
</ul>
<h2 id="Встраивание-файлов"><a class="header" href="#Встраивание-файлов">Встраивание файлов</a></h2>
<p>Программы <code>Go</code> могут встраивать статические файлы с помощью пакета <code>embed</code> и директиву <code>go:embed path/filename</code>:</p>
<pre><code class="language-go">package main

import (
    "embed"
    "fmt"
    "io"
    "log"
    "net/http"
)

//go:embed static/*
var content embed.FS

func main() {
    http.Handle("/", http.FileServer(http.FS(content)))
    go func() {
        log.Fatal(http.ListenAndServe(":8080", nil))
    }()

    // Чтение содержимого файлов из файловой системы
    entries, err := content.ReadDir("static")
    if err != nil {
        log.Fatal(err)
    }

    for _, e := range entries {
        resp, err := http.Get("http://localhost:8080/static/" + e.Name())
        if err != nil {
            log.Fatal(err)
        }
        body, err := io.ReadAll(resp.Body)
        if err != nil {
            log.Fatal(err)
        }
        if err := resp.Body.Close(); err != nil {
            log.Fatal(err)
        }
        fmt.Printf("%q: %s", e.Name(), body)
    }

    // Блокировка программы, чтобы сервер продолжал работать для доступа к статическим файлам через Web-интерфейс
    select {}
}

// Имитация реальных файлов с их содержимым для запуска в Playground
-- static/a.txt --
hello a
-- static/b.txt --
hello b
</code></pre>
<h2 id="http-сервер"><a class="header" href="#http-сервер">HTTP сервер</a></h2>
<p>Реализация простого <code>API</code> сервера на базе встроенной библиотеки <code>net/http</code>:</p>
<pre><code class="language-go">package main

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// Обработчик API
func apiHandler(w http.ResponseWriter, r *http.Request) {
	// Устанавливаем заголовок для ответа (Content-Type: application/json)
	w.Header().Set("Content-Type", "application/json")

	switch r.Method {
	case "GET":
		// Получение параметра "name" из URL
		name := r.URL.Query().Get("name")
		if name == "" {
			name = "Guest" // Значение по умолчанию, если параметр отсутствует
		}
		// Формируем JSON-ответ
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("Hi %s", name),
		})

	case "POST":
		// Парсим JSON из тела запроса
		var data map[string]interface{}
		if err := json.NewDecoder(r.Body).Decode(&amp;data); err != nil {
			http.Error(w, "invalid JSON", http.StatusBadRequest)
			return
		}

		// Формируем JSON-ответ
		json.NewEncoder(w).Encode(map[string]interface{}{
			"received": data,
			"status":   "OK",
		})

	default:
		// Обработка неподдерживаемых методов
		http.Error(w, "Метод не поддерживается", http.StatusMethodNotAllowed)
	}
}

func main() {
	// Регистрируем обработчик для пути /api
	http.HandleFunc("/api", apiHandler)

	// Запуск сервера
	fmt.Println("Сервер запущен на http://localhost:8080")
	http.ListenAndServe(":8080", nil)
}
</code></pre>
<p>Делаем запрос к <code>API</code> через <code>curl</code>:</p>
<pre><code class="language-bash">curl -s "http://localhost:8080/api" | jq .message # "Hi Guest"
curl -s "http://localhost:8080/api?name=Alex" | jq .message # "Hi Alex"
curl -s -X POST -d '{"key":"value"}' -H "Content-Type: application/json" http://localhost:8080/api | jq .received.key # "value"
curl -s -X POST "http://localhost:8080/api" # invalid JSON
</code></pre>
<h2 id="http-клиент"><a class="header" href="#http-клиент">HTTP клиент</a></h2>
<p>Делаем запрос к <code>API</code> в <code>Go</code>:</p>
<pre><code class="language-go">package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

func main() {
	// URL для отправки POST-запроса
	url := "http://localhost:8080/api"

	// Тело запроса в формате JSON
	requestBody := map[string]string{"key": "value"}
	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		fmt.Println("Ошибка при создании тела запроса в формате JSON:", err)
		return
	}

	// Создаем запрос
	resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		fmt.Println("Ошибка при отправке запроса:", err)
		return
	}
	defer resp.Body.Close()

	// Читаем тело ответа
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Ошибка при чтении ответа:", err)
		return
	}

	// Разбираем ответ в формате JSON
	var response map[string]interface{}
	if err := json.Unmarshal(body, &amp;response); err != nil {
		fmt.Println("Ошибка при парсинге JSON:", err)
		return
	}

	// Выводим значение "key" из ответа
	if received, ok := response["received"].(map[string]interface{}); ok {
		if value, exists := received["key"]; exists {
			fmt.Println(value) // "value"
		} else {
			fmt.Println("Ключ 'key' не найден в ответе")
		}
	} else {
		fmt.Println("Ответ не содержит ожидаемую структуру received")
	}
}
</code></pre>
<p><code>HTTP</code> запрос к <code>API</code> для получения последней версии релиза указаного <a href="https://github.com/Lifailon/lazyjournal">репозитория</a> в GitHub:</p>
<pre><code class="language-go">package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
)

// Формируем структуру ответа от API
type GitHubRelease struct {
	TagName string `json:"tag_name"`
}

func main() {
	// Формируем URL для получения информации
    repos := "Lifailon/lazyjournal"
	url := fmt.Sprintf("https://api.github.com/repos/%s/releases/latest", repos)
	// Выполнение GET-запроса
	resp, err := http.Get(url)
	if err != nil {
		log.Fatal("Ошибка при выполнении запроса:", err)
	}
	defer resp.Body.Close()
	// Проверка на успешный ответ
	if resp.StatusCode != http.StatusOK {
		log.Fatalf("Ошибка HTTP: %s", resp.Status)
	}
	// Декодирование JSON-ответа в заданную структуру
	var release GitHubRelease
	err = json.NewDecoder(resp.Body).Decode(&amp;release)
	if err != nil {
		log.Fatal("Ошибка при декодировании JSON:", err)
	}
	// Вывод последней версии
	fmt.Println("Latest version:", release.TagName)
}
</code></pre>
<p><code>go run main.go</code></p>
<h2 id="Вызов-системных-команд"><a class="header" href="#Вызов-системных-команд">Вызов системных команд</a></h2>
<p>Проверка доступности всех хостов в указанной подсети (асинхронный <code>ICMP</code> опрос):</p>
<pre><code class="language-go">package main

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
	"sync"
)

func pingHost(ip string, wg *sync.WaitGroup) {
	defer wg.Done()
	// Запускаем команду ping
	cmd := exec.Command("ping", "-n", "1", ip)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return
	}
	// Обрабатываем вывод команды
	if strings.Contains(string(output), "TTL=") {
		fmt.Printf("%s - доступен\n", ip)
	}
}

func main() {
	if len(os.Args) &lt; 2 {
		fmt.Println("Использование: go run main.go &lt;подсеть&gt;")
		return
	}
	// Извлекаем аргумент
	subnet := os.Args[1]
	// Убираем последний октет
	ipBase := subnet[:len(subnet)-1]
	var wg sync.WaitGroup
	for i := 1; i &lt;= 254; i++ {
		ip := fmt.Sprintf("%s%d", ipBase, i)
		wg.Add(1)
		// Запускаем асинхронный пинг
		go pingHost(ip, &amp;wg)
	}
	// Ждем завершения всех горутин
	wg.Wait()
}
</code></pre>
<p><code>go run main.go 192.168.3.0</code></p>
<h1 id="Математические-вычисления"><a class="header" href="#Математические-вычисления">Математические вычисления</a></h1>
<pre><code class="language-go">package main

import (
	"fmt"
	"math"
)

func customCeil(numerator int, denominator int) int {
    result := numerator / denominator
    if numerator%denominator != 0 {
        result++
    }
    return result
}

func main() {
    fmt.Println("Возвращает наименьшее значение из двух чисел 9 и 10:", math.Min(9, 10)) // 9
    fmt.Println("Возвращает наибольшее значение из двух чисел 9 и 10:", math.Max(9, 10)) // 10
    fmt.Println("Округляет число в меньшую сторону 10 / 3:", math.Floor(10/3)) // 3
    fmt.Println("Округляет число в большую сторону 10 / 3:", math.Ceil(10.0/3))
    fmt.Println("Округляет число в большую сторону 10 / 3:", customCeil(10, 3)) // 4
    fmt.Println("Отбрасывает дробную часть числа (не округляет) 4,9:", math.Trunc(4.9)) // 4
    fmt.Println("Округляет число до ближайшего целого в большую сторону от 4,5:", math.Round(4.5)) // 5
    fmt.Println("Округляет число до ближайшего целого в меньшую сторону от 4,5:", math.Round(4.45)) // 4
    fmt.Println("Возвращает абсолютное значение числа -7:", math.Abs(-7)) // 7
    fmt.Println("Возводит число 2 в степень 3:", math.Pow(2, 3)) // 8
    fmt.Println("Вычисляет квадратный корень числа 16:", math.Sqrt(16)) // 4
}
</code></pre>
<h1 id="Регулярные-выражения"><a class="header" href="#Регулярные-выражения">Регулярные выражения</a></h1>
<h2 id="Элементы-синтаксиса"><a class="header" href="#Элементы-синтаксиса">Элементы синтаксиса</a></h2>
<p>Основные элементы синтаксиса регулярных выражений:</p>
<div class="table-wrapper"><table><thead><tr><th>Символ</th><th>Описание</th></tr></thead><tbody>
<tr><td><code>.</code></td><td>любой символ, кроме символа новой строки</td></tr>
<tr><td><code>*</code></td><td><code>0</code> или более повторений</td></tr>
<tr><td><code>+</code></td><td><code>1</code> или более повторений</td></tr>
<tr><td><code>{n}</code></td><td>точно <code>n</code> повторений (например, <code>a{3}</code>, соответствует: <code>"aaa"</code>)</td></tr>
<tr><td><code>{n,}</code></td><td>минимум <code>n</code> повторений (например, <code>a{2,}</code>, соответствует: <code>"aa"</code>, <code>"aaa"</code> и т.д.)</td></tr>
<tr><td><code>{n,m}</code></td><td>от <code>n</code> до <code>m</code> повторений (например, <code>a{2,4}</code>, соответствует: <code>"aa"</code>, <code>"aaa"</code>, <code>"aaaa"</code>)</td></tr>
<tr><td><code>?</code></td><td><code>0</code> или <code>1</code> повторений</td></tr>
<tr><td><code>^</code></td><td>начало строки</td></tr>
<tr><td><code>$</code></td><td>конец строки</td></tr>
<tr><td><code>[]</code></td><td>группа символов (например, <code>[a-z]</code>)</td></tr>
<tr><td><code>\s</code></td><td>любой пробельный символ (пробел, табуляция, новая строка и другие пробельные символы)</td></tr>
<tr><td><code>\d</code></td><td>цифра (эквивалентно <code>[0-9]</code>)</td></tr>
<tr><td><code>\D</code></td><td>любой символ, не являющийся цифрой (эквивалентно <code>[^0-9]</code>)</td></tr>
<tr><td><code>\w</code></td><td>буквенно-цифровой символ (буквы, цифры и подчеркивание, эквивалентно <code>[a-zA-Z0-9_]</code>)</td></tr>
<tr><td><code>\W</code></td><td>не буквенно-цифровой символ (эквивалентно <code>[^a-zA-Z0-9_]</code>)</td></tr>
<tr><td><code>\b</code></td><td>граница слова (например, <code>\bword\b</code> соответствует <code>"word"</code>, и не подхоит <code>"wordy"</code>)</td></tr>
<tr><td><code>(?i)</code></td><td>делает выражение нечувствительным к регистру</td></tr>
<tr><td><code>\</code></td><td>экранирование специальных символов</td></tr>
<tr><td><code>()</code></td><td>группа захвата</td></tr>
<tr><td><code>|</code></td><td>логическое <code>ИЛИ</code> (например, `a</td></tr>
</tbody></table>
</div>
<h2 id="Функции-regexp"><a class="header" href="#Функции-regexp">Функции regexp</a></h2>
<p>Основные функции пакета <code>regexp</code>:</p>
<ul>
<li><code>regexp.MatchString</code> — проверяет, соответствует ли строка регулярному выражению.</li>
</ul>
<pre><code class="language-go">package main

import (
	"fmt"
	"regexp"
)

func main() {
    pattern := `^[a-z]+$`
	str := "string"
    matched, err := regexp.MatchString(pattern, str)
	if err != nil {
		fmt.Println("Ошибка в регулярном выражении:", err)
		return
	}
	fmt.Printf("Строка '%s' соответствует регулярному выражению '%s' (результат: %v)", str, pattern, matched)
}
</code></pre>
<ul>
<li><code>regexp.Compile</code> — компилирует регулярное выражение и возвращает объект типа <code>*regexp.Regexp</code>, если выражение корректное, или возвращается ошибка.</li>
</ul>
<pre><code class="language-go">package main

import (
    "fmt"
    "regexp"
)

func main() {
    // Компилируем регулярное выражение
    r, err := regexp.Compile(`\d+`)
    if err != nil {
        fmt.Println("Ошибка компиляции регулярного выражения:", err)
        return
    }
    // Применяем регулярное выражение к строке
    fmt.Println(r.FindString("123 abc 456")) // 123
}
</code></pre>
<ul>
<li><code>regexp.FindAllString</code> — находит все подстроки в строке, которые соответствуют регулярному выражению, и возвращает их в виде среза строк.</li>
</ul>
<pre><code class="language-go">package main

import (
    "fmt"
    "regexp"
)

func main() {
    r, err := regexp.Compile(`\d+`)
    if err != nil {
        fmt.Println("Ошибка компиляции регулярного выражения:", err)
        return
    }
    matches := r.FindAllString("123abc456", -1)
    fmt.Println(matches) // [123 456]
}
</code></pre>
<ul>
<li><code>regexp.ReplaceAllString</code> — заменяет все соответствующие части строки.</li>
</ul>
<pre><code class="language-go">package main

import (
    "fmt"
    "regexp"
)

func main() {
    pattern := `\d+`
    str := "Диапазон от 1 до 10"
    // Заменяем все цифры на "X"
    r, err := regexp.Compile(pattern)
    if err != nil {
        fmt.Println("Ошибка компиляции регулярного выражения:", err)
        return
    }
    result := r.ReplaceAllString(str, "X")
    fmt.Println(result)
}
</code></pre>
<ul>
<li>Группы захвата</li>
</ul>
<pre><code class="language-go">package main

import (
    "fmt"
    "regexp"
)

func main() {
    // Регулярное выражение с группой захвата для даты в формате "dd.mm.yyyy"
    pattern := `(\d{2}).(\d{2}).(\d{4})`
    r, err := regexp.Compile(pattern)
    if err != nil {
        fmt.Println("Ошибка компиляции регулярного выражения:", err)
        return
    }
    // Поиск и извлечение данных
    result := r.FindStringSubmatch("01.12.2024")
    if len(result) &gt; 0 {
        fmt.Println("День:", result[1])
        fmt.Println("Месяц:", result[2])
        fmt.Println("Год:", result[3])
    }
}
</code></pre>
<ul>
<li>Извлечение логина и домена из почтовых адресов</li>
</ul>
<pre><code class="language-go">package main

import (
    "fmt"
    "regexp"
)

func main() {
    pattern := `([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})`
    str := "contact@example.com, support@example.net"
    r, err := regexp.Compile(pattern)
    if err != nil {
        fmt.Println("Ошибка компиляции регулярного выражения:", err)
        return
    }
    matches := r.FindAllStringSubmatch(str, -1)
    for _, match := range matches {
        fmt.Printf("Логин: %s, Домен: %s\n", match[1], match[2])
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>+++
title = "Node.js"
[extra]
toc = true
toc_sidebar = true
go_to_top = true
+++</p>
<p align="center">
    <a href="https://github.com/Lifailon/node.js-cheat-sheet-ru"><img title="PS-Commands Logo"src="Node-js/Node.js-Cheat-Sheet-Logo.png"></a>
</p>
<p align="center">
    <span>Памятка по основам синтаксиса <b>JavaScript</b> для <b>Node.js</b> в примерах.</span>
</p>
<hr />
<h3 id="Переменные"><a class="header" href="#Переменные">Переменные</a></h3>
<p>Переменная <code>var</code> поддерживает любую область видимости и ее возможно объявить повторно (считается устаревшим методом и рекомендуется не использовать).</p>
<pre><code class="language-js">console.log(varVariable) // Uncaught ReferenceError: varVariable is not defined (не определена)
if (true) {
    var varVariable = true
}
console.log(varVariable) // true
var varVariable = 123
console.log(varVariable) // 123
</code></pre>
<p>Переменная <code>let</code> позволяет изменять содержимое с другим типом данных (в отличии от <code>const</code>), но ограничина областью видимости (в отличии от <code>var</code>).</p>
<pre><code class="language-js">console.log(letVariable) // Uncaught ReferenceError: letVariable is not defined
if (true) {
    let letVariable = 'letVariable is defined'
}
console.log(letVariable) // Uncaught ReferenceError: letVariable is not defined
let letVariable = 'string'
console.log(letVariable)
let letVariable = 'string' // Uncaught SyntaxError: Identifier 'letVariable' has already been declared (идентификатор уже объявлен)
letVariable = 123
console.log(letVariable)
</code></pre>
<p>Переменная константа <code>const</code> требует обязательной инициализации во время объявления, и не позволяет изменять значение переменной после ее объявления.</p>
<pre><code class="language-js">const constVariable = 'string'
constVariable = '123' // Uncaught TypeError: Assignment to constant variable (ошибка присвоения значения к постоянной переменной)
</code></pre>
<h3 id="Типы-данных-1"><a class="header" href="#Типы-данных-1">Типы данных</a></h3>
<pre><code class="language-js">typeof 32 // number
typeof 3.2 // number
typeof 123n // bigint
typeof 'text' // string
typeof true // boolean
typeof false // boolean
typeof null // object
typeof { key: 'value' } // object
typeof [1, 2, 3] // object
typeof function() {} // function
typeof Symbol('id') // symbol
</code></pre>
<p>Преобразовать аргумент в число. Возвращает <code>NaN</code>, если преобразование невозможно.</p>
<pre><code class="language-js">Number("123")      // 123
Number("123.45")   // 123.45
Number("abc")      // NaN
Number(undefined)  // NaN
Number(true)       // 1
Number(false)      // 0
Number(null)       // 0
</code></pre>
<p>Преобразовать строку в целое число. Прекращает чтение, как только встречает нецифровой символ.</p>
<pre><code class="language-js">parseInt("123abc")  // 123
parseInt("12.34")   // 12
parseInt("abc123")  // NaN
</code></pre>
<p>Преобразовать строку в число с плавающей точкой.</p>
<pre><code class="language-js">parseFloat("123.45abc")  // 123.45
parseFloat("abc123.45")  // NaN
</code></pre>
<p>Преобразовать значение в строку.</p>
<pre><code class="language-js">(123).toString()   // "123"
(true).toString()  // "true"
String(123)        // "123"
String(true)       // "true"
String(false)      // "false"
String(null)       // "null"
String(undefined)  // "undefined"
</code></pre>
<p>Преобразовать значение в булевое (логическое) значение. Все значения, кроме <code>0</code>, <code>null</code>, <code>NaN</code>, <code>undefined</code> и пустой строки, преобразуются в <code>true</code>.</p>
<pre><code class="language-js">Boolean(123)        // true
Boolean("Hello")    // true
Boolean(0)          // false
!0                  // true
!!0                 // false
Boolean(null)       // false
Boolean(NaN)        // false
Boolean(undefined)  // false
Boolean("")         // false
</code></pre>
<h3 id="Функции-1"><a class="header" href="#Функции-1">Функции</a></h3>
<pre><code class="language-js">function sum (param1, param2) {
    console.log(param1*param2)
}

sum(2,2) // 4

function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min
}

getRandomInt(1,100) // Например, 44
</code></pre>
<h3 id="Условия"><a class="header" href="#Условия">Условия</a></h3>
<pre><code class="language-js">function functionName (paramName) {
    if (paramName === 0) {
        console.log(`${paramName} равно 0`)
    }
    else if (paramName &lt; 10) {
        console.log(`${paramName} меньше 10`)
    }
    else if (paramName &gt;= 10) {
        console.log(`${paramName} больше или равно 10`)
    }
    else {
        console.log(`Переданное значение - ${paramName} - не подходит под заданные условия`)
    }
}

functionName(0)       // 0 равно 0
functionName(5)       // 5 меньше 10
functionName(15)      // 15 больше или равно 10
functionName('test')  // Переданное значение - test - не подходит под заданные условия
</code></pre>
<p>Однострочный формат условия <code>?:</code>, который подходит для использования в теле переменной</p>
<pre><code class="language-js">let input = 1
input === 1 ? true : false // true
input = 2
input === 1 ? true : false // false
</code></pre>
<p>Проверить одно значение сразу на большое количество условий с помощью конструкции <code>switch</code></p>
<pre><code class="language-js">function getDayOfWeek(day) {
    switch (day) {
        case 1:
            return 'Понедельник'
        case 2:
            return 'Вторник'
        case 3:
            return 'Среда'
        case 4:
            return 'Четверг'
        case 5:
            return 'Пятница'
        case 6:
            return 'Суббота'
        case 7:
            return 'Воскресенье'
        default:
            return 'Неправильно задан параметр'
    }
}

console.log(getDayOfWeek(1)) // Понедельник
console.log(getDayOfWeek(5)) // Пятница
console.log(getDayOfWeek(7)) // Воскресенье
console.log(getDayOfWeek(8)) // Неправильно задан параметр

</code></pre>
<h3 id="Обработка-ошибок-1"><a class="header" href="#Обработка-ошибок-1">Обработка ошибок</a></h3>
<pre><code class="language-js">function errorTest(a, b) {
    // Блок кода, который будет выполняется до тех пор, пока не возникнет ошибка
    try {
        if (b === 0) {
            throw new Error("на ноль делить нельзя")
        }
        console.log(a / b) // выполняется, если ошибок нет
    }
    // Блок кода, который будет выполнен, если в блоке try возникнет ошибка
    catch (error) {
        console.log(`Ошибка: ${error.message}`) // Обработка ошибки
    }
    // Блок кода, который выполняется в любом случае
    finally {
        console.log("Блок finally выполняется всегда") // Всегда выполняется
    }
}

errorTest(10, 2) 
// 5
// Блок finally выполняется всегда

errorTest(10, 0)
// Ошибка: на ноль делить нельзя
// Блок finally выполняется всегда
</code></pre>
<h3 id="Массивы"><a class="header" href="#Массивы">Массивы</a></h3>
<p>Классический массив и его методы.</p>
<pre><code class="language-js">const array = [3, 2, 'string']
Array.isArray(array) // Проверка, является ли переменная массивом (true)
array[2] = 1 // Изменить содержимое элемента в массиве по индексу
array.sort() // сортировка по умолчанию: [ 1, 2, 3 ]
array.reverse() // Поменять порядок следования: [ 3, 2, 1 ]
array[0] + array[1] + array[2] // 6
array[3] // undefined (не определено)
array[3] = 4 // Добавить новый элемент в массив по индексу
array.push(5) // Добавить новый элемент с конца
array[4] // 5
array.slice(3,5) // Вывести содержимое массива с 4-го по 5-й индекс: [ 4, 5 ]
array.unshift(0) // Добавить элемент(ы) (через запятую) в начало массива
array.shift() // Удалить первый элемент из массива
array.pop() // Удалить последний элемент из массива
array[array.length-1] // Вывести содержимое последнего элемента в массиве
array.indexOf(1) // Выводит индекс первого вхождения элемента в массив, или -1, если элемент не найден
</code></pre>
<p>Вложенный массив, а также методы фильтрации и объединения:</p>
<pre><code class="language-js">const data = [
    { id: 1, name: 'red' },
    { id: 2, name: 'blue' },
]

data.push({id: 3, name: 'green'}) // Добавить новый элемент в массив

const nameArray = data.map(item =&gt; item.name) // Пересобрать новый массив

const filterArray = nameArray.filter(item =&gt; item.length &gt;= 4) // отфильтровать содержимое массива по длинне содержимого
// [ 'blue', 'green' ]

[...nameArray, ...filterArray] // объеденить два массива
// [ 'red', 'blue', 'green', 'blue', 'green' ]

const idArray = data.map(item =&gt; item.id)
// Метод reduce выполняет функцию для каждого элемента массива, чтобы получить одно итоговое значение (сумму)
idArray.reduce((accumulator, current) =&gt; accumulator + current, 0) // 3
</code></pre>
<h3 id="Объекты"><a class="header" href="#Объекты">Объекты</a></h3>
<p>Преобразовать объект в массив и наоборот:</p>
<pre><code class="language-js">const obj = { a: 1, b: 2, c: 3 }
obj.b // 2
let keys = Object.keys(obj)      // [ 'a', 'b', 'c' ]
let values = Object.values(obj)  // [ 1, 2, 3 ]
const arr = Object.entries(obj)  // [["a", 1], ["b", 2], ["c", 3]]
arr[1][1] // 2
Object.fromEntries(arr)          // { a: 1, b: 2, c: 3 }
</code></pre>
<p>Объект представляет из себя список пар (ключ-значение), разделенного запятыми. Используя переменную <code>const</code> при объявлении объектов, возможно изменять содержимое дочерних элементов.</p>
<pre><code class="language-js">const box = {
    height: 8,
    width: 40,
    scrollable: true,
    style: {
        fg: 'white',
        bg: 'black'
    }
}

box.height // 8
box.style // { fg: 'white', bg: 'black' }
box.style.fg // white

box.style.fg = 'blue'
box.style.fg // blue
</code></pre>
<p>Объекты и вложенные массивы <code>JavaScript</code> могут содержать дочерние массивы внутри <code>[]</code> и вложенные объекты внутри <code>{}</code>.</p>
<pre><code class="language-js">const obj = [
    'JavaScript',
    2024,
    [
        'Express',
        'Axios',
    ],
    {
        name: 'Alex',
        age: 29,
        num: [1, 'string', {}],
        test: {}
    }
]
</code></pre>
<p>Конвертация в <code>JSON</code>:</p>
<pre><code class="language-js">const jsonString = JSON.stringify(obj)  // Конвертация из объекта JavaScript в JSON
const obj = JSON.parse(jsonString)      // Конвертация из JSON в JavaScript
</code></pre>
<p>Методы объекта назначаются через функции</p>
<pre><code class="language-js">const obj = {
    default: 10,
    get() {
        return this.default
    },
    plus(num) {
        if (isNaN(num)) {return}
        this.default += num
    },
    minus(num) {
        if (isNaN(num)) {return}
        this.default -= num
    }
}

obj.minus(1)
obj.get() // 9
obj.plus(2)
obj.get() // 11
</code></pre>
<p>Оператор <code>return</code> используется для выхода из функции (т.е. последующий код не читается), который возвращает значение указанное после ключевого слова.</p>
<h3 id="Циклы-1"><a class="header" href="#Циклы-1">Циклы</a></h3>
<p>Примеры циклов взяты из проекта <a href="https://github.com/Lifailon/multranslate">multranslate</a>, для проверки всех строк в массиве и увеличения количества видимых строк с учетом <code>autowrap</code>. Имеется две реальных строки, необходимо узнать количество виртуальных строк с учетом длинны символов в строке. Например, если максимальная длинна одной строки составляет, <code>36</code>, то на одну реальную строку в <code>92</code> символа приходится дополнительно еще <code>2</code> виртуальных. Количество найденных виртуальных строк прибавляется к изначально зафиксированному значению количества всех реальных строк.</p>
<pre><code class="language-js">// На входе 2 строки, разделенные символом \r
const text = "Первая строка\rВторая очень длинная строка, которое будет превышать максимальное значение символов в строке"

// Фиксируем текущее максимальное количество строк и длинну символов в строке с учетом размеров окна
const maxLines = box.height - 2 // 6
const maxChars = box.width - 4  // 36

// Разбиваем текст на массив из строк
const bufferLine = text.split('\r')
// Забираем реальное количество строк (2)
let viewLines = bufferLine.length

// Вывести количество строк в каждой строке массива
bufferLine.map(item =&gt; item.length) // [ 13, 92 ]
</code></pre>
<p>Классический цикл <code>for</code> итерирует числами с типом данных <code>number</code> (<code>int</code> / <code>integer</code>). С каждой интерацией объявленное значение (<code>let i = 0</code>) увеличивается на заданное количество (<code>i++</code> - на единицу), цикл завершается в случае успешного соблюдения условия (<code>i &lt; bufferLine.length</code>).</p>
<pre><code class="language-js">for (let i = 0; i &lt; bufferLine.length; i++) {
    if (bufferLine[i].length &gt; maxChars) {
        // Добавляем одну виртуальную строку без учета остатка символов
        viewLines++
    }
}
console.log(`${maxLines} ${maxChars} ${viewLines}`) // 6 36 3
// Уменьшаем значение на 1, для проверки в других циклах
viewLines--

for (let i = 0; i &lt; bufferLine.length; i++) {
    if (bufferLine[i].length &gt; maxChars) {
        // Добавляем все виртуальные строки, с округлением в меньшую сторону
        viewLines += Math.floor(bufferLine[1].length / maxChars)
    }
}
console.log(`${maxLines} ${maxChars} ${viewLines}`) // 6 36 4
viewLines -= 2
</code></pre>
<p>Цикл <code>for..in</code> итерирует по индексам массива, с типом данных <code>string</code>. Сколько элементов в массиве (<code>bufferLine.length</code>), столько и будет индексов (отсчет начинается с нуля).</p>
<pre><code class="language-js">for (let index in bufferLine) {
    if (bufferLine[Number(index)].length &gt; maxChars) {
        viewLines += Math.floor(bufferLine[1].length / maxChars)
    }
}
console.log(`${maxLines} ${maxChars} ${viewLines}`) // 6 36 4
viewLines -= 2
</code></pre>
<p>Цикл <code>for..of</code> итерирует по элементам массива, с уникальным типом данных каждого элемента в массиве.</p>
<pre><code class="language-js">const array = [1, 'string', {}]
for (let arr of array) {
    console.log(typeof arr)
}
// number
// string
// object

for (let line of bufferLine) {
    console.log(typeof line)
    if (line.length &gt; maxChars) {
        viewLines += Math.floor(bufferLine[1].length / maxChars)
    }
}
console.log(`${maxLines} ${maxChars} ${viewLines}`) // 6 36 4
viewLines -= 2
</code></pre>
<p>Метод массива <code>forEach</code> выполняет указанную функцию для каждого элемента в массиве.</p>
<pre><code class="language-js">bufferLine.forEach(line =&gt; {
    if (line.length &gt; maxChars) {
        viewLines += Math.floor(bufferLine[1].length / maxChars)
    }
})
console.log(`${maxLines} ${maxChars} ${viewLines}`) // 6 36 4
viewLines -= 2
</code></pre>
<p>Цикл <code>while</code> Выполняет тело цикла <code>{}</code> до тех пор, пока условие истинно</p>
<pre><code class="language-js">let i = 0
while (i &lt; bufferLine.length) {
    if (bufferLine[i].length &gt; maxChars) {
        viewLines += Math.floor(bufferLine[1].length / maxChars)
    }
    i++
}
console.log(`${maxLines} ${maxChars} ${viewLines}`) // 6 36 4
viewLines -= 2
</code></pre>
<p>Цикл <code>do..while</code> сначала выполняет тело цикла, а затем проверяет условие, это гарантирует, что интерация будет выполнена как минимум один раз.</p>
<pre><code class="language-js">i = 0
do {
    if (bufferLine[i].length &gt; maxChars) {
        viewLines += Math.floor(bufferLine[1].length / maxChars)
    }
    i++
} while (i &lt; bufferLine.length)
console.log(`${maxLines} ${maxChars} ${viewLines}`) // 6 36 4
</code></pre>
<p>Операторы:</p>
<ul>
<li><code>continue</code> - прерывает текущую интерацию, для продолжения цикла с следующим значением</li>
<li><code>break</code> - прерывает и завершает цикл</li>
</ul>
<pre><code class="language-js">let arr = [0, 1, 2, 4]
for (const value of arr) {
    console.log(`Начало ${value}-й итерации`)
    if (value === 1) {
        console.log('Пропустить оставшуюся часть кода и перейти к следующей итерации')
        continue
    } else if (value === 2) {
        console.log('Полностью выйти из цикла')
        break
    }
    console.log(`Конец ${value}-й итерации`)
}

// Начало 0-й итерации
// Конец 0-й итерации
// Начало 1-й итерации
// Пропустить оставшуюся часть кода и перейти к следующей итерации
// Начало 2-й итерации
// Полностью выйти из цикла
</code></pre>
<h3 id="Асинхронные-операции"><a class="header" href="#Асинхронные-операции">Асинхронные операции</a></h3>
<p><code>Promise</code> (промис) — это объект, который используется для обработки асинхронных операций, позволяя работать с результатами, когда они станут доступны, не блокируя основной поток выполнения. Он может находиться в одном из трех состояний:</p>
<ul>
<li><code>Pending</code> (Ожидание): Операция только отправлена на выполнение или еще выполняется.</li>
<li><code>Fulfilled</code> (Выполнен): Операция завершилась успешно.</li>
<li><code>Rejected</code> (Отклонен): Операция завершилась с ошибкой.</li>
</ul>
<p>С помощью ключевых слов <code>resolve</code> (разрешить/успех) и <code>reject</code> (отклонить/ошибка) производится управление возвращаемым результатом выполнения.</p>
<pre><code class="language-js">let testPromise = new Promise((resolve, reject) =&gt; {
    if (true) {
        resolve("Операция выполнена успешно")
    } else {
        reject("Ошибка выполнения операции")
    }
})

testPromise.then(result =&gt; console.log(result)).catch(error =&gt; console.error(error))
</code></pre>
<p>Метод <code>then</code> используется для обработки успешного выполнения промиса (в состоянии <code>fulfilled</code>).</p>
<p>Метод <code>catch</code> используется для обработки ошибок или отказов промиса (в состоянии <code>rejected</code>).</p>
<p><code>async</code> — это ключевое слово, которое делает функцию асинхронной и позволяет использовать <code>await</code>, чтобы приостановить выполнение до тех пор, пока все промисы не будут выполнены.</p>
<p><code>await</code> — это ключевое слово, которое используется внутри асинхронной функции (async). Оно заставляет ждать выполнения промиса и возвращает его результат.</p>
<pre><code class="language-js">// Импортируем функцию exec из модуля child_process, которая позволяет запускать команды операционной системы
const { exec } = require('child_process')

// Основная функция выполнения команды ping в промис
function pingHost(host) {
    return new Promise((resolve) =&gt; {
        // Выполняем команду ping для указанного хоста с timeout 50 мс
        exec(`ping -n 1 -w 50 ${host}`, (error) =&gt; {
            // Если нет ошибки, значит хост отвечает (alive: true)
            if (!error) {
                resolve({ host, alive: true })
            }
            // Если есть ошибка, хост не отвечает (alive: false)
            else {
                resolve({ host, alive: false })
            }
        })
    })
}

// Асинхронная функция создания промисов и получения результатов
async function pingSubnet(subnet) {
    // Массив для хранения промисов
    const promises = []
    // Генерация и пинг каждого IP-адреса в диапазоне от 1 до 254
    for (let i = 1; i &lt;= 254; i++) {
        // Формируем IP-адрес, заменяя последний октет подсети
        const host = `${subnet.split('.').slice(0,3).join('.')}.${i}`
        // Добавляем промис в массив для выполнения пинга в фоне и продолжения интерации
        promises.push(pingHost(host)) // Promise { &lt;pending&gt; }
    }
    // Ждем завершения выполнения всех промисов
    const results = await Promise.all(promises)
    results.forEach(result =&gt; {
        if (result.alive) {
            console.log(`+++ ${result.host}`)
        } else {
            console.log(`- ${result.host}`)
        }
    })
}

pingSubnet('192.168.3.0')
</code></pre>
<p>Использовать внешнюю библиотеку <a href="https://www.npmjs.com/package/ping">ping</a>: <code>npm install ping</code></p>
<pre><code class="language-js">const ping = require('ping')

// Асинхронная функция отправки команды ping через библиотеку
async function pingHost(host) {
    try {
        const res = await ping.promise.probe(host, { timeout: 1 })
        return { host, alive: res.alive }
    } catch (error) {
        return { host, alive: false }
    }
}

// Функция возврата промисов вручную без async
function pingHost(host) {
    return ping.promise.probe(host, { timeout: 1 })
        .then(res =&gt; {
            return { host, alive: res.alive }
        })
        .catch(error =&gt; {
            return { host, alive: false }
        })
}

async function pingSubnet(subnet) {
    const promises = []
    for (let i = 1; i &lt;= 254; i++) {
        const host = `${subnet.split('.').slice(0,3).join('.')}.${i}`
        promises.push(pingHost(host))
    }
    const results = await Promise.all(promises)
    results.forEach(result =&gt; {
        if (result.alive) {
            console.log(`+++ ${result.host}`)
        } else {
            console.log(`- ${result.host}`)
        }
    })
}

pingSubnet('192.168.3.0')
</code></pre>
<p><code>await Promise.all()</code> - дожидается успешного выполнения всех запросов.
<code>await Promise.allSettled()</code> - дожидается выполнения всех запросов не зависимо от успеха (возвращает статус и результат).
<code>await Promise.race()</code> - дожидается первого успешного выполнения, что бы получить результат от него не зависимо от его успеха.</p>
<h3 id="Регулярные-выражения-1"><a class="header" href="#Регулярные-выражения-1">Регулярные выражения</a></h3>
<p>Преобразовать строку в массив из букв (<code>char</code>).</p>
<pre><code class="language-js">let line = "javascript"
let arr = Array.from(str) // ['j', 'a', 'v', 'a',  's', 'c', 'r', 'i', 'p', 't']
</code></pre>
<p>Метод <code>split()</code> используется для преобразования строки в массив.</p>
<pre><code class="language-js">line = "1,2,3,4,5"              // '1,2,3,4,5'
arr = line.split(",")           // [ '1', '2', '3', '4', '5' ]
</code></pre>
<p>Метод <code>join()</code> используется для объединение массива в строку.</p>
<pre><code class="language-js">let arrSlice = arr.slice(1, 3)  // Срез, выводит содержимое массива с 1 по 3 индекс (два элемента)
arrSlice.join()                 // Собирает массив в строку: '2,3'
arrSlice.join(" - ")            // '2 - 3'
</code></pre>
<p>Метод <code>match()</code> используется для поиска совпадений с регулярным выражением в строке. Он возвращает массив с найденными совпадениями или <code>null</code>, если совпадений не найдено.</p>
<pre><code class="language-js">let stringForRegex = "Текст для проверки текста"
stringForRegex.match(/текст/)[0]     // Получить содержимое первого совпадения
stringForRegex.match(/текст/).index  // Возвращает порядковый индекс первого совпадения в тексте (19)
stringForRegex.match(/текст/i)[0]    // Возвращает только первое совпадение без учета регистра
stringForRegex.match(/текст/gi)      // Получить массив всех совпадений: [ 'Текст', 'текст' ]

stringForRegex = "2024-10-25"
stringForRegex.match(/(\d{4})-(\d{2})-(\d{2})/) // Группа захвата, которая возвращает полное совпадение, а также значения отдельных групп
// [ '2024-10-25', '2024', '10', '25', index: 0, input: '25-10-2024', groups: undefined ]
</code></pre>
<p>Метод <code>search()</code> возвращает только индекс первого совпадения.</p>
<pre><code class="language-js">"Текст для проверки текста".search('про') // 10
</code></pre>
<p>Метод <code>replace()</code> заменяет найденные совпадения в строке на другие значения.</p>
<pre><code class="language-js">stringForRegex = "Текст для замены"
stringForRegex.replace(/для/, "после")              // 'Текст после замены'
stringForRegex.replace(/^т/i, "Этот т")             // 'Этот текст для замены'
stringForRegex.replace(/$/, "!")                    // 'Текст для замены!'
stringForRegex.replace(/(Текст)/, "$1 только")      // 'Текст только для замены'
stringForRegex.replace(/\s[а-яА-Я]{3}/, "")         // 'Текст замены'
stringForRegex.replace(/\s\p{L}+$/u, " кириллицы")  // 'Текст для кириллицы'

stringForRegex = "Text for regex"
stringForRegex.replace(/\s\w{3}/, "")         // Используется для замены любых латинских букв: 'Text regex'
stringForRegex.replace(/\s[a-zA-Z_]{3}/, "")  // эквивалент \w

stringForRegex = "2024-10-25"
stringForRegex = stringForRegex.replace(/(\d{4})-(\d{2})-(\d{2})/,"$3.$2.$1") // Поменять порядок через группы захвата: '25.10.2024'
stringForRegex.replace(/\d{2}\./g, "11.")   // Заменяет найденные две идущие цифры подряд: '11.11.2024'
stringForRegex.replace(/\d{4}/, "2025")     // Заменяет четыре идущие цифры подряд: '25.10.2025'
stringForRegex.replace(/20\d+/, "2025")     // Заменяет 20 и любые идущие за ним цифры: '25.10.2025'
stringForRegex.replace(/10.+/g, "11.2025")  // Заменяет 10 и любое количетво символов идущее за ним: '25.11.2025'
stringForRegex.replace(/\d{2,4}/g, "11")    // Заменяет найденные цифры следующие в порядке от 2 до 4: ('11.11.11')
stringForRegex.replace(/[45]/g, "1")        // Заменить 4 или 5 на 1: '21.10.2021'
</code></pre>
<h3 id="Математические-вычисления-1"><a class="header" href="#Математические-вычисления-1">Математические вычисления</a></h3>
<pre><code class="language-js">Math.min(9, 10)        // Получить наименьшее значение двух чисел: 9
Math.max(9, 10)        // Получить максимальное значение двух чисел: 10
Math.floor(10 / 3)     // Округлить в меньшую сторону: 3
Math.ceil(10/3)        // Откруглить в большую сторону: 4
Math.trunc(4.9)        // Отбрасывание дробной части: 4
Math.round(4.5)        // Округление до ближайшего целого: 5
Math.round(4.45)       // Округление до ближайшего целого: 4
Math.fround(5.05)      // Ближайшее число с плавающей точкой одинарной точности: 5.050000190734863
Math.random()          // Псевдослучайное число между 0 и 1, например, 0.2309471255442206
Math.abs(-7)           // Получить абсолютное значение: 7
Math.sign(-3)          // Определение знака числа (-1, 0, 1): -1
Math.pow(2, 3)         // Возведение в степень: 8
Math.sqrt(16)          // Квадратный корень: 4
Math.cbrt(27)          // Кубический корень: 3
Math.imul(2, 4)        // Целочисленное 32-битное умножение: 8
Math.clz32(1)          // Количество ведущих нулей в 32-битном представлении: 31
</code></pre>
<h3 id="express"><a class="header" href="#express">Express</a></h3>
<p>Создаем директорию, инициализируем проект и устанавливаем зависимости</p>
<pre><code class="language-bash">mkdir api &amp;&amp; cd api
npm init -y
npm install express
</code></pre>
<p>Серверная часть <code>API</code> сервера в файле <code>server.js</code></p>
<pre><code class="language-js">const express = require('express')

const web = express()

// Middleware для парсинга JSON данных в теле запроса
web.use(express.json())

// Обработка GET запроса с параметрами в пути и заголовками
web.get('/user/:id', (req, res) =&gt; {
    const userId = req.params.id // Получаем параметр id из пути
    const customHeader = req.headers['custom-header'] // Чтение заголовка custom-header
    res.json({
        message: `GET запрос для пользователя с ID ${userId}`,
        customHeader: customHeader || 'Заголовок отсутствует'
    })
})

// Обработка POST запроса с данными в теле запроса и заголовками
web.post('/user', (req, res) =&gt; {
    const { name, age } = req.body // Получаем данные из тела POST запроса
    const authHeader = req.headers['authorization'] // Чтение содержимого из заголовка `authorization`
    if (authHeader !== 'Bearer TOKEN') {
        res.json({
            message: `Авторизация не пройдена, переданный токен: ${authHeader}`
        })
    } else {
        res.json({
            name: name || 'Не указано',
            age: age || 'Не указано',
        })
    }
})

// Запуск сервера на порту 3000
const PORT = 3000
web.listen(PORT, () =&gt; {
    console.log(`Сервер запущен на http://localhost:${PORT}`)
})
</code></pre>
<p>Запуск сервера</p>
<pre><code class="language-bash">node server.js
</code></pre>
<h3 id="axios"><a class="header" href="#axios">Axios</a></h3>
<p>Клиентская часть для работы с <code>API</code></p>
<pre><code class="language-bash">npm install axios
</code></pre>
<p>Пример <code>GET</code> запроса</p>
<pre><code class="language-js">const axios = require('axios')

// URL сервера
const url = 'http://localhost:3000'

// Пример GET запроса с параметром id в пути и кастомным заголовком
async function getUser(userId, Header) {
    try {
        const response = await axios.get(`${url}/user/${userId}`, {
            headers: {
                'custom-header': Header
            }
        })
        console.log('GET Ответ:', response.data)
    } catch (error) {
        console.error('Ошибка GET запроса:', error.message)
    }
}

await getUser(1, 'Value')
// GET Ответ: {
//   message: 'GET запрос для пользователя с ID 1',
//   customHeader: 'Value'
// }
</code></pre>
<p>Пример <code>POST</code> запроса</p>
<pre><code class="language-js">// Пример POST запроса с телом и заголовком авторизации
async function createUser(key, name, age) {
    try {
        const response = await axios.post(`${url}/user`, {
            name: name,
            age: age
        }, {
            headers: {
                'Authorization': `Bearer ${key}`
            }
        })
        console.log('POST Ответ:', response.data)
    } catch (error) {
        console.error('Ошибка POST запроса:', error.message)
    }
}

await createUser('KEY', 'Alex', 29)
// POST Ответ: { message: 'Авторизация не пройдена, переданный токен: Bearer KEY' }

await createUser('TOKEN', 'Alex', 29)
// POST Ответ: { name: 'Alex', age: 29 }
</code></pre>
<h3 id="fetch-1"><a class="header" href="#fetch-1">Fetch</a></h3>
<pre><code class="language-js">async function fetchData(url) {
    try {
        // Отправляем GET-запрос на указанный URL
        const response = await fetch(url)
        // Проверяем, что ответ успешен
        if (!response.ok) {
            throw new Error(`Error Status: ${response.status}`)
        }
        // Получаем и выводим данные в формате JSON
        const data = await response.json()
        return data
    }
    // Обрабатываем ошибки
    catch (error) {
        console.error('Error:', error)
    }
}

const result = await fetchData('https://jsonplaceholder.typicode.com/todos/1')
result // { userId: 1, id: 1, title: 'delectus aut autem', completed: false }
JSON.stringify(result) // '{"userId":1,"id":1,"title":"delectus aut autem","completed":false}'
</code></pre>
<h3 id="cheerio"><a class="header" href="#cheerio">Cheerio</a></h3>
<p>Cheerio - это библиотека для работы с <code>HTML</code> и <code>XML</code> в <code>Node.js</code></p>
<pre><code class="language-bash">npm install axios cheerio https-proxy-agent iconv-lite
</code></pre>
<p>Подключаем библиотеки и получаем содержимое страницы с помощью <code>Axios</code> через <code>Proxy</code></p>
<pre><code class="language-js">const axios    = require('axios')
const cheerio  = require('cheerio')
const proxy    = require('https-proxy-agent')
const iconv    = require('iconv-lite')

// Имя агента в заголовке запросов (вместо axios)
const headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0 Win64 x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
}

const proxyAddress = '192.168.3.100'
const proxyPort = 9090
const username = 'test'
const password = 'test'

// Создание экземпляра Axios с использованием конфигурации Proxy
const createAxiosProxy = () =&gt; {
    const config = {}
    config.httpsAgent = new proxy.HttpsProxyAgent(`http://${username}:${password}@${proxyAddress}:${proxyPort}`)
    return axios.create(config)
}
const axiosProxy = createAxiosProxy()

const url = "https://rutor.info"

// Отправляем запрос
const response = await axiosProxy.get(url, {
    responseType: 'arraybuffer',
    headers: headers
})

// Декодируем ответ
html = iconv.decode(response.data, 'utf8')
</code></pre>
<p>Вытаскиваем данные с помощью <code>Cheerio</code></p>
<pre><code class="language-js">const data = cheerio.load(html)

// Обращаемся к элементу div (не обязательно указывать название элемента) с id="ws" &gt; div с id="index" &gt; элемент "tbody" (таблица) &gt; элемент "tr" (строки)
data('div#ws #index tbody tr').length // 171
// Исключить из вывода строку с class="backgr" (загловки столбцов)
data('#ws #index tbody tr').not('.backgr').length // 170

// Получить содержимое первого элемента "tr" в формате HTML, строки или текста без тегов
data('#ws #index tbody tr').not('.backgr').eq(0).html()
data('#ws #index tbody tr').not('.backgr').eq(0).toString()
data('#ws #index tbody tr').not('.backgr').eq(0).text()

// Получить содержимое элемента по частичному совпадению
data('#ws #index tbody tr').not('.backgr').find('td:contains("слово")').text().replace('\n','').trim()
// 'Мужское слово (2024) WEB-DLRip'

// Получить содержимое второго элемента по индексу в строке (столбцe)
data('#ws #index tbody tr').not('.backgr').eq(0).find('td').eq(1).text().replace('\n','').trim()
// 'Launcher for Zapret [v 1.3] (2024) PC | Portable'

// Получить содержимое атрибута "href" из элемента с классом "downgif"
data('#ws #index tbody tr').not('.backgr').eq(0).find('td a.downgif').attr('href')
// '//d.rutor.info/download/1008549'

// Получить содержимое атрибута "href" из второго элемента "a" в элементе "td"
data('#ws #index tbody tr').not('.backgr').eq(0).find('td a:nth-child(2)').attr('href')
// 'magnet:?xt=urn:btih:f1ca88b9421b243b6cb3d4da90e8fe133f381817&amp;dn=rutor.info&amp;tr=udp://opentor.net:6969&amp;tr=http://retracker.local/announce'

// Фильтруем все элементы по частичному совпадению
data('#ws #index tbody tr').not('.backgr').filter((index, element) =&gt; {
    // Проверяем, содержит ли текущая строка "tr" слово "Крит" в одном из столбцов "td"
    return data(element).find('td:contains("Крит")').length &gt; 0
}).map((index, element) =&gt; {
    // Если слово найдено, извлекаем текст всех "td" в этой строке с помощью map()
    return data(element).find('td').map((index, element) =&gt; data(element).text()).get().join(' | ').replace('\n','')
}).get()

// [
//   '29 Окт 24 | Критик / The Critic (2023) WEB-DLRip 1080p от ExKinoRay | P  | 6.10 GB |  1  4',
//   '28 Окт 24 | Критик / The Critic (2023) WEB-DLRip | P  | 1.46 GB |  58  22',
//   '28 Окт 24 | Критик / The Critic (2023) WEB-DLRip-AVC от DoMiNo &amp; селезень | P  | 1.46 GB |  64  19',
//   '28 Окт 24 | Критик / The Critic (2023) WEB-DL 1080p | P | RGB  | 1 | 5.63 GB |  115  54'
// ]

const torrents = []

// Собираем объект из всех элементов
data('#ws #index tbody tr').not('.backgr').each((index, element) =&gt; {
    const row = data(element)
    const torrent = {
        'Date': row.find('td').eq(0).text().trim(),
        'Name': row.find('td').eq(1).find('a').last().text().trim(),
        'Link': 'https://rutor.info' + row.find('td').eq(1).find('a[href^="/torrent"]').attr('href'),
        'DownloadLink': 'https://' + row.find('td').eq(1).find('a.downgif').attr('href'),
        'Magnet': row.find('td').eq(1).find('a[href^="magnet:"]').attr('href')
    }
    torrents.push(torrent)
})

// Конвертируем объект в формат JSON
console.log(JSON.stringify(torrents, null, 2))

// [
//   {
//     "Date": "29 Окт 24",
//     "Name": "Launcher for Zapret [v 1.3] (2024) PC | Portable",
//     "Link": "https://rutor.info/torrent/1008549/launcher-for-zapret-v-1.3-2024-pc-portable",
//     "DownloadLink": "https:////d.rutor.info/download/1008549",
//     "Magnet": "magnet:?xt=urn:btih:f1ca88b9421b243b6cb3d4da90e8fe133f381817&amp;dn=rutor.info&amp;tr=udp://opentor.net:6969&amp;tr=http://retracker.local/announce"
//   },
//   ...
// ]
</code></pre>
<h3 id="puppeteer"><a class="header" href="#puppeteer">Puppeteer</a></h3>
<p>Puppeteer — это библиотека, которая предоставляет <code>API</code> для автоматизации любых действий в браузерах <strong>Google Chrome</strong> и <strong>Mozilla Firefox</strong> через протокол <code>Chrome DevTools</code> и <code>WebDriver BiDi</code>.</p>
<pre><code class="language-bash">mkdir api &amp;&amp; cd api &amp;&amp; npm init -y &amp;&amp; npm install puppeteer
</code></pre>
<p>Пример получения списка файлов раздачи с сайта <a href="https://rutor.info">RuTor</a>.</p>
<pre><code class="language-js">const puppeteer = require('puppeteer')
// Запускаем браузер и открываем новую пустую страницу 
const browser = await puppeteer.launch({
    headless: true // Отключить отображение браузера (параметр по умолчанию)
})
const page = await browser.newPage()
// Открываем страницу с ожиданием загрузки 60 сек
const query = 721221
await page.goto(`https://rutor.info/torrent/${query}`, {
    timeout: 60000,
    waitUntil: 'domcontentloaded' // ожидать только полной загрузки DOM (не ждать загрузки внешних ресурсов, таких как изображения, стили и скрипты)
})
await page.evaluate(() =&gt; {
    // Находим кнопку по JavaScript пути и нажимаем на нее
    // document.querySelector("#details &gt; tbody &gt; tr:nth-child(11) &gt; td.header &gt; span").click()
    // document.querySelector("#details &gt; tbody &gt; tr:nth-child(12) &gt; td.header &gt; span").click()
    // Находим все кпноки которые содержат class="button"
    const buttons = document.querySelectorAll('span.button')
    // Проходимся по найденным кнопкам
    buttons.forEach(button =&gt; {
        // Проверяем, содержит ли кнопка текст "Файлы" и нажимаем на нее
        if (button.textContent.includes('Файлы')) {
            button.click()
        }
    })
})
// Дождаться загрузки результатов
// const elementHandle = await page.waitForSelector('#files')
// Ищем элемент с идентификатором #files и проверяем, что элемент существует его содержимое не содержит текст загрузки
await page.waitForFunction(() =&gt; {
    const element = document.querySelector('#files')
    return element &amp;&amp; !element.textContent.includes("Происходит загрузка списка файлов...")
}, {
    timeout: 30000, // Ожидать результат 30 секунд
    polling: 50   // Проверка каждые 50мс (по умолчанию 100мс)
})
// Забираем результат после успешной проверки
const elementContent = await page.evaluate(() =&gt; {
    const element = document.querySelector('#files')
    return element ? element.textContent : null
})
// Закрываем браузер
await browser.close()
// Разбиваем полученные результаты на массив из строк (split) исключая первую строку (slince)
const lines = elementContent.trim().split('\n').slice(1)
// Регулярное выражение для разбиения строки на название и размер
const regex = /^(.+?)([\d.]+\s*\S+)\s+\((\d+)\)$/
const torrents = []
for (const line of lines) {
    const match = line.match(regex)
    const torrent = {
        'Name': match[1],
        'Size': match[2]
    }
    torrents.push(torrent)
}
console.log(JSON.stringify(torrents, null, 2))
</code></pre>
<p>Пример создания <code>API</code> для получения результатов проверки скорости интернета в формате <code>JSON</code> через <a href="https://www.speedtest.net">Ookla SpeedTest</a>.</p>
<pre><code class="language-js">const puppeteer = require('puppeteer')
const browser = await puppeteer.launch({
    headless: false
})
const page = await browser.newPage()
await page.goto(`https://www.speedtest.net`, {
    waitUntil: 'domcontentloaded'
})
// Дождаться, когда кнопка "Go" станет доступной
await page.waitForSelector('span[data-testid="start-button"]')
// Возвращаем массив всех элементов span на странице с их текстом
await page.evaluate(() =&gt; {
    return Array.from(document.querySelectorAll('span')).map(elemet =&gt; ({
        Text: elemet.innerText, // Текст, отображаемый внутри элемента
        Content: elemet.textContent, // Весь текст внутри элемента, включая скрытые части
        // HTML: elemet.innerHTML, // HTML-код, который находится внутри элемента
        // AllHTML: elemet.outerHTML , // Весь HTML-код, который находится внутри элемента
        id: elemet.id, // Уникальный идентификатор элемента (#)
        className: elemet.className,
        tagName: elemet.tagName // Имя тега элемента (например, SPAN)
    }))
})
// Находим и нажимаем на кнопку
await page.evaluate(() =&gt; {
    const buttons = document.querySelectorAll('span')
    buttons.forEach(button =&gt; {
        if (button.textContent.includes('Go') || button.innerText.includes('GO')) {
            button.click()
        }
    })
})
// Функция для получения результата
async function checkResult () {
    return await page.evaluate(() =&gt; {
        const element = document.querySelector('div.result-data a')
        return element ? element.getAttribute('href') : null
    })
}
// Цикл для проверки получения результата
let resultUrl = '#'
// Проверяем, что результат содержит в начале строки 'http'
while (!resultUrl.startsWith('http')) {
    resultUrl = await checkResult()
}
await browser.close()

// Считываем данные из полученного url с помощью Fetch
const result = await fetch(resultUrl)
const resultHTML = await result.text()
// Вытаскиваем JSON из HTML страницы
const resultJSON = resultHTML.split('window.OOKLA')[3].replace('.INIT_DATA  = ','').replace(';\n','')
const resultObj = JSON.parse(resultJSON)

resultObj.result.id // 16947429430
resultObj.result.download // 7169 (7.17)
resultObj.result.upload // 4939 (4.94)
resultObj.result.idle_latency // 171 (ping)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>+++
title = "Docker"
[extra]
toc = true
toc_sidebar = true
go_to_top = true
+++</p>
<p align="center">
    <a href="https://github.com/Lifailon/PS-Commands/blob/rsa/posh.md/#docker"><img title="Dpcler Commands Logo"src="Docker/Docker-Commands-Logo.png"></a>
</p>
<p align="center">
    Заметки по работе с системой контейнеризации 🐳 <b>Docker</b>.
</p>
<hr />
<h2 id="wsl"><a class="header" href="#wsl">WSL</a></h2>
<p><code>wsl --list</code> список установленных дистрибутивов Linux <br />
<code>wsl --list --online</code> список доступных дистрибутивов <br />
<code>wsl --install -d Ubuntu</code> установить Ubuntu в Windows Subsystem for Linux <br />
<code>wsl --status</code> <br />
<code>wsl --exec "htop"</code> выполнить команду в подсистеме Linux по умолчанию <br />
<code>wsl -e bash -c "docker -v"</code> <br />
<code>wsl -e bash -c "systemctl status docker"</code></p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p><code>apt update &amp;&amp; apt upgrade -y</code> <br />
<code>apt install docker.io</code> <br />
<code>systemctl status docker</code> <br />
<code>systemctl start docker</code> <br />
<code>systemctl enable docker</code> <br />
<code>iptables -t nat -N DOCKER</code> <br />
<code>docker -v</code> <br />
<code>docker -h</code> <br />
<code>curl https://registry-1.docker.io/v2/</code> проверить доступ к Docker Hub <br />
<code>curl -s -X POST -H "Content-Type: application/json" -d '{"username": "lifailon", "password": "password"}' https://hub.docker.com/v2/users/login | jq -r .token &gt; dockerToken.txt</code> получить временный токен доступа для авторизации <br />
<code>sudo docker login</code> вход в реестр репозитория hub.docker.com <br />
<code>cat dockerToken.txt | sudo docker login --username lifailon --password-stdin</code> передать токен авторизации (https://hub.docker.com/settings/security) из файла через stdin <br />
<code>cat /root/.docker/config.json | jq -r .auths[].auth</code> место хранения токена авторизации в системе <br />
<code>cat /root/.docker/config.json | python3 -m json.tool</code></p>
<h2 id="mirror"><a class="header" href="#mirror">Mirror</a></h2>
<p><code>echo '{ "registry-mirrors": ["https://dockerhub.timeweb.cloud"] }' &gt; "/etc/docker/daemon.json"</code> <br />
<code>echo '{ "registry-mirrors": ["https://huecker.io"] }' &gt; "/etc/docker/daemon.json"</code> <br />
<code>echo '{ "registry-mirrors": ["https://mirror.gcr.io"] }' &gt; "/etc/docker/daemon.json"</code> <br />
<code>echo '{ "registry-mirrors": ["https://daocloud.io"] }' &gt; "/etc/docker/daemon.json"</code> <br />
<code>echo '{ "registry-mirrors": ["https://c.163.com"] }' &gt; "/etc/docker/daemon.json"</code></p>
<p><code>systemctl restart docker</code></p>
<h2 id="proxy-1"><a class="header" href="#proxy-1">Proxy</a></h2>
<pre><code class="language-bash">mkdir -p /etc/systemd/system/docker.service.d

'[Service]
Environment="HTTP_PROXY=http://docker:password@192.168.3.100:9090"
Environment="HTTPS_PROXY=http://docker:password@192.168.3.100:9090"' &gt; /etc/systemd/system/docker.service.d/http-proxy.conf
</code></pre>
<p><code>systemctl daemon-reload</code> <br />
<code>systemctl restart docker</code></p>
<h2 id="run"><a class="header" href="#run">Run</a></h2>
<p>Commands: <code>search/pull/images/creat/start/ps/restart/pause/unpause/rename/stop/kill/rm/rmi</code></p>
<p><code>docker search speedtest</code> поиск образа в реестре <br />
<code>docker pull adolfintel/speedtest</code> скачать образ LibreSpeed из реестра Docker Hub (https://hub.docker.com/r/adolfintel/speedtest) <br />
<code>docker images (docker image ls)</code> отобразить все локальные (уже загруженные) образы docker (image ls) <br />
<code>docker images --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}"</code> отфильтровать вывод (json-формат) <br />
<code>docker create -it --name speedtest -p 8080:80 adolfintel/speedtest</code> создать контейнер из образа adolfintel/speedtest с именем speedtest и проброс 80 порта контейнера на 8080 порт хоста <br />
<code>docker start speedtest</code> запустить созданный контейнер <br />
<code>ss -ltp | grep 8080</code> проверить, что порт открыт <br />
<code>docker ps</code> отобразить все запущенные докер контейнеры <br />
<code>docker ps -a</code> список всех существующих контейнеров (для их запуска/удаления по NAMES/ID и код выхода Exited 0 - успешная остановка) <br />
<code>docker ps -s</code> размер контейнеров (--size) <br />
<code>docker restart speedtest</code> перезапустить контейнер <br />
<code>docker pause speedtest</code> приостановить контейнер <br />
<code>docker unpause uptime-kuma</code> возобновить работу контейнера <br />
<code>docker rename speedtest speedtest-2</code> переименоввать контейнер (docker rename old_name new_name) <br />
<code>docker stop speedtest-2</code> остановить работающий контейнер с отправкой главному процессу контейнера сигнал SIGTERM, и через время SIGKILL <br />
<code>docker kill uptime-kuma</code> остановить работающий контейнер с отправкой главному процессу контейнера сигнал SIGKILL <br />
<code>docker kill $(docker ps -q)</code> остановить все контейнеры <br />
<code>docker rm speedtest-2</code> удалить контейнер <br />
<code>docker rmi adolfintel/speedtest</code> удалить образ <br />
<code>docker run -p 8443:8443 -it --entrypoint /bin/sh container_name</code> запустить контейнер и подключиться к нему (даже если контейнер уходит в ошибку при запуске) <br />
<code>docker run -d --restart=unless-stopped --name openspeedtest -p 3000:3000 -p 3001:3001 openspeedtest/latest</code> загрузить образ OpenSpeedTest (https://hub.docker.com/r/openspeedtest/latest), создать контейнер и запустить в одну команду в фоновом режиме (-d/--detach, терминал возвращает контроль сразу после запуска контейнера, если не используется, можно видеть логи, но придется остановить контейнер для выхода) <br />
<code>docker rm openspeedtest &amp;&amp; docker rmi openspeedtest/latest</code> удаляем контейнер и образ в одну команду <br />
<code>docker run --name pg1 -p 5433:5432 -e POSTGRES_PASSWORD=PassWord -d postgres</code> создать контейнер postgres (https://hub.docker.com/_/postgres) с параметрами (-e) <br />
<code>docker run -d --restart=always --name uptime-kuma -p 8080:3001 louislam/uptime-kuma:1</code> создать и запустить контейнер Uptime-Kuma (https://hub.docker.com/r/elestio/uptime-kuma) в режиме always, при котором контейнер должен перезапускаться автоматически, если он остановится или если перезапустится Docker (например, после перезагрузки хоста)</p>
<h2 id="update"><a class="header" href="#update">Update</a></h2>
<p><code>docker update --restart unless-stopped uptime-kuma</code> изменить режим перезапуска контейнера после его остановки на unless-stopped (режим аналогичен always, но контейнер не будет перезапущен, если он был остановлен вручную с помощью docker stop) <br />
<code>docker update --restart on-failure uptime-kuma</code> контейнер будет перезапущен только в случае его завершения с ошибкой, когда код завершения отличается от 0, через двоеточие можно указать количество попыток перезапуска (например, on-failure:3) <br />
<code>docker update --cpu-shares 512 --memory 500M uptime-kuma</code> задать ограничения по CPU, контейнер будет иметь доступ к указанной доле процессорного времени в диапазоне от 2 до 262,144 (2^18) или --cpus (количество процессоров), --memory/--memory-swap и --blkio-weight для IOps (относительный вес от 10 до 1000)</p>
<h2 id="stats"><a class="header" href="#stats">Stats</a></h2>
<p><code>docker stats</code> посмотреть статистику потребляемых ресурсов запущенными контейнерами (top) <br />
<code>docker stats --no-stream --format json</code> вывести результат один раз в формате json</p>
<h2 id="logs"><a class="header" href="#logs">Logs</a></h2>
<p><code>docker logs uptime-kuma --tail 100</code> показать логи конкретного запущенного контейнера в терминале (последние 100 строк) <br />
<code>docker system events</code> предоставляют события от демона dockerd в реальном времени <br />
<code>journalctl -xeu docker.service</code> <br />
<code>docker system df</code> отобразить сводную информацию занятого пространства образами и контейнерами <br />
<code>du -h --max-depth=1 /var/lib/docker</code> <br />
<code>du -h --max-depth=2 /var/lib/docker/containers</code></p>
<pre><code class="language-bash">docker run \
  --log-driver json-file \
  --log-opt max-size=10m \
  --log-opt max-file=3 \
  container_name
</code></pre>
<p><code>--log-driver json-file</code> стандартный драйвер логов Docker <br />
<code>--log-opt max-size=10m</code> устанавливаем максимальный размер каждого лог-файла в 10МБайт
<code>--log-opt max-file=3</code> сохраняем только 3 файла с логами (текущий и два предыдущих). Когда лимит будет превышен, Docker автоматически удалит старые логи.</p>
<h2 id="volume"><a class="header" href="#volume">Volume</a></h2>
<p><code>docker volume ls</code> показывает список томов и место хранения (механизмы хранения постояннымх данных контейнера на хостовой машине, которые сохраняются между перезапусками или пересозданиями контейнеров) <br />
<code>docker volume inspect uptime-kuma</code> подробная информация конфигурации тома (отображает локальный путь к данным в системе, Mountpoint: /var/lib/docker/volumes/uptime-kuma/_data) <br />
<code>docker volume create test</code> создать том <br />
<code>docker volume rm test</code> удалить том <br />
<code>docker run -d --restart=always --name uptime-kuma -p 8080:3001 -v uptime-kuma:/app/data louislam/uptime-kuma:1</code> создать и запустить контейнер на указанном томе (том создается автоматически, в дальнейшем его можно указывать при создании контейнера, если необходимо загружать из него сохраненные данные)</p>
<h2 id="network"><a class="header" href="#network">Network</a></h2>
<p><code>docker network ls</code> список сетей <br />
<code>docker network inspect bridge</code> подробная информация о сети bridge <br />
<code>docker inspect uptime-kuma | jq .[].NetworkSettings.Networks</code> узнать наименование сетевого адаптера указанного контейнера <br />
<code>docker run -d --name uptime-kuma --network host nginx louislam/uptime-kuma:1</code> запуск контейнера с использованием host сети, которая позволяет контейнеру использовать сеть хостовой машины <br />
<code>docker network create network_test</code> создать новую сеть <br />
<code>docker network connect network_test uptime-kuma</code> подключить работающий контейнер к указанной сети <br />
<code>docker network disconnect network_test uptime-kuma</code> отключить от сети</p>
<h2 id="inspect"><a class="header" href="#inspect">Inspect</a></h2>
<p><code>docker inspect uptime-kuma</code> подробная информация о контейнере (например, конфигурация NetworkSettings) <br />
<code>docker inspect uptime-kuma --format='{{.LogPath}}'</code> показать, где хранятся логи для конкретного контейнера в локальной системе <br />
<code>docker inspect uptime-kuma | grep LogPath</code> <br />
<code>docker inspect $(docker ps -q) --format='{{.NetworkSettings.Ports}}'</code> отобразить TCP порты всех запущенных контейнеров <br />
<code>docker inspect $(docker ps -q) --format='{{.NetworkSettings.Ports}}' | grep -Po "[0-9]+(?=}])"</code> отобразить порты хоста (внешние) <br />
<code>docker port uptime-kuma</code> отобразить проброшенные порты контейнера <br />
<code>for ps in $(docker ps -q); do docker port $ps | sed -n 2p | awk -F ":" '{print $NF}'; done</code> отобразить внешние порты всех запущенных контейнеров <br />
<code>id=$(docker inspect uptime-kuma | jq -r .[].Id)</code> узнать ID контейнера по его имени в конфигурации <br />
<code>cat /var/lib/docker/containers/$id/config.v2.json | jq .</code> прочитать конфигурационный файл контейнера</p>
<h2 id="exec-1"><a class="header" href="#exec-1">Exec</a></h2>
<p><code>docker exec -it uptime-kuma /bin/bash</code> подключиться к работающему контейнеру (при выходе из оболочки, контейнер будет работать), используя интерпритатор bash <br />
<code>docker top uptime-kuma</code> отобразить работающие процессы контейнера <br />
<code>docker exec -it --user root uptime-kuma bash apt-get install -y procps</code> авторизоваться под пользователем root и установить procps <br />
<code>docker exec -it uptime-kuma ps -aux</code> отобразить работающие процессы внутри контейнера <br />
<code>docker exec uptime-kuma kill -9 25055</code> убить процесс внутри контейнера <br />
<code>docker exec -it uptime-kuma ping 8.8.8.8</code> <br />
<code>docker exec -it uptime-kuma pwd</code> <br />
<code>docker cp ./Console-Performance.sh uptime-kuma:/app</code> скопировать из локальной системы в контейнер <br />
<code>docker exec -it uptime-kuma ls</code> <br />
<code>docker cp uptime-kuma:/app/db/ backup/db</code> сокпировать из контейнера в локальную систему <br />
<code>ls backup/db</code></p>
<h2 id="prune"><a class="header" href="#prune">Prune</a></h2>
<p><code>docker network prune &amp;&amp; docker image prune &amp;&amp; docker volume prune &amp;&amp; docker container prune</code> удалить все неиспользуемые сети, висящие образа, остановленные контейнеры, все неиспользуемые тома <br />
<code>system prune –volumes</code> заменяет все четыре команды для очистки и дополнительно очищает кеш сборки</p>
<h2 id="remove"><a class="header" href="#remove">Remove</a></h2>
<p><code>systemctl stop docker.service</code> <br />
<code>systemctl stop docker.socket</code> <br />
<code>pkill -f docker</code> <br />
<code>pkill -f containerd</code> <br />
<code>apt purge docker.io -y || dpkg --purge docker.io</code> <br />
<code>dpkg -l | grep docker</code> <br />
<code>rm -rf /var/lib/docker</code> <br />
<code>rm -rf /run/docker</code> <br />
<code>rm -rf /run/docker.sock</code></p>
<h2 id="docker-socket-api"><a class="header" href="#docker-socket-api">Docker Socket API</a></h2>
<p><code>curl --silent -XGET --unix-socket /run/docker.sock http://localhost/version | jq .</code> использовать локальный сокет (/run/docker.sock) для взаимодействия с Docker daemon через его API <br />
<code>curl --silent -XGET --unix-socket /run/docker.sock http://localhost/info | jq .</code> количество образов, запущенных и остановленных контейнеров и остальные метрики ОС <br />
<code>curl --silent -XGET --unix-socket /run/docker.sock http://localhost/events</code> логи Docker daemon <br />
<code>curl --silent -XGET --unix-socket /run/docker.sock -H "Content-Type: application/json" http://localhost/containers/json | jq .</code> список работающих контейнеров и их параметры конфигурации <br />
<code>curl --silent -XGET --unix-socket /run/docker.sock http://localhost/containers/uptime-kuma/json | jq .</code> подробные сведения (конфигурация) контейнера <br />
<code>curl --silent -XPOST --unix-socket /run/docker.sock -d "{"Image":"nginx:latest"}" http://localhost/containers/create?name=nginx</code> создать контейнер с указанным образом в теле запроса (должен уже присутствовать образ) <br />
<code>curl --silent -XPOST --unix-socket /run/docker.sock http://localhost/containers/17fab06a820debf452fe685d1522a9dd1611daa3a5087ff006c2dabbe25e52a1/start</code> запустить контейнер по Id <br />
<code>curl --silent -XPOST --unix-socket /run/docker.sock http://localhost/containers/17fab06a820debf452fe685d1522a9dd1611daa3a5087ff006c2dabbe25e52a1/stop</code> остановить контейнер <br />
<code>curl --silent -XDELETE --unix-socket /run/docker.sock http://localhost/containers/17fab06a820debf452fe685d1522a9dd1611daa3a5087ff006c2dabbe25e52a1</code> удалить контейнер</p>
<h2 id="docker-tcp-api"><a class="header" href="#docker-tcp-api">Docker TCP API</a></h2>
<pre><code class="language-bash">echo '{
    "hosts": ["tcp://0.0.0.0:2375", "unix:///var/run/docker.sock"]
}' &gt; "/etc/docker/daemon.json"
service=$(cat /lib/systemd/system/docker.service | sed "s/ -H fd:\/\///")
printf "%s\n" "$service" &gt; /lib/systemd/system/docker.service
systemctl daemon-reload
systemctl restart docker
</code></pre>
<p>curl --silent -XGET http://192.168.3.102:2375/version | jq .</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p><code>docker context create devops-01 --docker "host=tcp://192.168.3.101:2375"</code> подключиться к удаленному сокету <br />
<code>docker context ls</code> список контекстов <br />
<code>docker context inspect devops-01</code> конфигурация указанного контекста <br />
<code>docker context use devops-01</code> использовать выбранный контекст по умолчанию (возможно на прямую взаимосдействовать с удаленным Docker Engine через cli) <br />
<code>docker context rm devops-01</code> удалить контекст</p>
<h2 id="ctop"><a class="header" href="#ctop">ctop</a></h2>
<p><code>scoop install ctop</code> установка в Windows (https://github.com/bcicen/ctop)</p>
<pre><code class="language-bash">wget https://github.com/bcicen/ctop/releases/download/v0.7.7/ctop-0.7.7-linux-amd64 -O /usr/local/bin/ctop
chmod +x /usr/local/bin/ctop
</code></pre>
<p><code>ctop</code> отображает сводную таблицу (top) CPU, MEM, NET RX/TX, IO R/W <br />
<code>o</code> - графики <br />
<code>l</code> - логи контейнера в реальном времени <br />
<code>s</code> - stop/start <br />
<code>R</code> - remove после stop <br />
<code>p</code> - pause/unpause <br />
<code>r</code> - restart <br />
<code>e</code> - exec shell</p>
<h2 id="dockly"><a class="header" href="#dockly">Dockly</a></h2>
<p><code>npm install -g dockly</code> TUI интерфейс на базе Node.js и Blessed.js <br />
<code>docker run -it --rm -v /var/run/docker.sock:/var/run/docker.sock lirantal/dockly</code> запуск в Docker <br />
<code>dockly</code></p>
<h2 id="lazydocker"><a class="header" href="#lazydocker">LazyDocker</a></h2>
<p><code>scoop install lazydocker || choco install lazydocker</code> установка в Windows (https://github.com/jesseduffield/lazydocker)</p>
<pre><code class="language-bash">wget https://github.com/jesseduffield/lazydocker/releases/download/v0.23.1/lazydocker_0.23.1_Linux_x86.tar.gz -O ~/lazydocker.tar.gz
tar -xzf ~/lazydocker.tar.gz lazydocker
rm ~/lazydocker.tar.gz
mv lazydocker /usr/local/bin/lazydocker
chmod +x /usr/local/bin/lazydocker
</code></pre>
<p>lazydocker</p>
<h2 id="lazyjournal"><a class="header" href="#lazyjournal">Lazyjournal</a></h2>
<p><code>curl -sS https://raw.githubusercontent.com/Lifailon/lazyjournal/main/install.sh | bash</code> установка в Unix <br />
<code>Invoke-RestMethod https://raw.githubusercontent.com/Lifailon/lazyjournal/main/install.ps1 | Invoke-Expression</code> установка в Windows <br />
<code>lazyjournal</code> <br />
<code>lazyjournal --help</code> <br />
<code>lazyjournal --version</code></p>
<h2 id="dockerfile"><a class="header" href="#dockerfile">Dockerfile</a></h2>
<p><code>FROM</code> указывает базовый образ, на основе которого будет создаваться новый образ <br />
<code>LABEL</code> добавляет метаданные к образу в формате ключ-значение <br />
<code>ENV</code> устанавливает переменные окружения, которые будут доступны внутри контейнера со значениями по умолчанию (можно переопределить через <code>-e</code>, который имеет повышенный приоритет) <br />
<code>ARG</code> определяет переменные, которые могут быть переданы и доступны только на этапе сборки образа (выполнения инструкций в dockerfile через <code>docker build --build-arg</code>) и недоступны в контейнере <br />
<code>USER</code> устанавливает пользователя, от имени которого будут выполняться следующие команды <br />
<code>WORKDIR</code> устанавливает рабочий каталог внутри контейнера для последующих команд <br />
<code>SHELL</code> задает командную оболочку, которая будет использоваться для выполнения команд RUN, CMD и ENTRYPOINT (по умолчанию <code>/bin/sh -c</code>, например на <code>SHELL ["/bin/bash", "-c"]</code>) <br />
<code>RUN</code> выполняет команды в контейнере во время сборки образа <br />
<code>COPY</code> копирует файлы и каталоги из указанного источника на локальной машине в файловую систему контейнера <br />
<code>ADD</code> копирует файлы и каталоги в контейнер, поддерживает загрузку файлов из URL и автоматическое извлечение архивов <br />
<code>CMD</code> определяет команду, которая будет выполняться при запуске контейнера, может быть переопределена при запуске <br />
<code>ENTRYPOINT</code> задает основную команду, которая будет выполняться при запуске контейнера без возможности ее переопредиления, но с возможностью передачи аргументов <br />
<code>VOLUME</code> создает точку монтирования для хранения данных в хостовой системе <br />
<code>EXPOSE</code> указывает, какие порты контейнера будут доступны извне <br />
<code>HEALTHCHECK</code> определяет команду для проверки состояния работающего контейнера <br />
<code>ONBUILD</code> задает команды, которые будут автоматически выполнены при сборке дочерних образов <br />
<code>STOPSIGNAL</code> определяет сигнал, который будет отправлен контейнеру для его остановки</p>
<p><code>git clone https://github.com/Lifailon/TorAPI</code> <br />
<code>cd TorAPI</code> <br />
<code>nano Dockerfile</code></p>
<pre><code class="language-Dockerfile"># Указать базовый образ для сборки, который содержит последнюю версию Node.js и npm
FROM node:alpine AS build
# Установить рабочую директорию для контейнера (все последующие команды будут выполняться относительно этой директории)
WORKDIR /torapi
# Копирует файл package.json из текущей директории на хосте в рабочую директорию
COPY package.json ./
# Запускает команду (используя оболочку по умолчанию) для установки зависимостей, указанных в package.json
RUN npm install &amp;&amp; npm update &amp;&amp; npm cache clean --force
# Копирует все файлы из текущей директории на хосте в рабочую директорию контейнера
COPY . .
# Создает новый рабочий образ для создания контейнера
FROM node:alpine
WORKDIR /torapi
# Копирует только те файлы, которые необходимые для работы приложения
COPY --from=build /torapi/node_modules ./node_modules
COPY --from=build /torapi/package.json ./package.json
COPY --from=build /torapi/main.js ./main.js
COPY --from=build /torapi/swagger/swagger.js ./swagger/swagger.js
COPY --from=build /torapi/category.json ./category.json
# Определить переменные окружения по умолчанию, которые могут быть переопределены при запуске контейнера
ENV PORT=8443
ENV PROXY_ADDRESS=""
ENV PROXY_PORT=""
ENV USERNAME=""
ENV PASSWORD=""
# Открывает порт 8443 для доступа к приложению из контейнера
EXPOSE $PORT
# Определить команду для проверки работоспособности контейнера (для примера)
# Проверка будет запускаться каждые 120 секунд, если команда не завершится за 30 секунд, она будет считаться неуспешной, если команда не проходит 3 раза подряд, контейнер будет помечен как нездоровый
# Docker будет ждать 5 секунд после старта контейнера перед тем, как начать проверки здоровья
HEALTHCHECK --interval=120s --timeout=30s --retries=3 --start-period=10s \
    CMD ["sh", "-c", "npm start -- --test"]
# Устанавливает команду по умолчанию для запуска приложения при запуске контейнера
ENTRYPOINT ["sh", "-c", "npm start -- --port $PORT --proxyAddress $PROXY_ADDRESS --proxyPort $PROXY_PORT --username $USERNAME --password $PASSWORD"]
</code></pre>
<p><code>docker build -t torapi .</code> собрать образ из dockerfile</p>
<pre><code class="language-bash">docker run -d --name TorAPI -p 8443:8443 --restart=unless-stopped \
  -e PROXY_ADDRESS="192.168.3.100" \
  -e PROXY_PORT="9090" \
  -e USERNAME="TorAPI" \
  -e PASSWORD="TorAPI" \
  torapi
</code></pre>
<h2 id="push"><a class="header" href="#push">Push</a></h2>
<p><code>docker login</code> <br />
<code>git clone https://github.com/Lifailon/TorAPI</code> <br />
<code>cd TorAPI</code> <br />
<code>docker build -t lifailon/torapi .</code> собрать образ для публикации на Docker Hub <br />
<code>docker push lifailon/torapi</code> загрузить образ на Docker Hub</p>
<p><code>docker pull lifailon/torapi:latest</code> загрузить образ из Docker Hub <br />
<code>docker run -d --name TorAPI -p 8443:8443 lifailon/torapi:latest</code> загрузить образ и создать контейнер</p>
<h2 id="add"><a class="header" href="#add">ADD</a></h2>
<pre><code class="language-bash">FROM alpine:latest
# Загрузка и распаковка архива напрямую из GitHub
ADD https://github.com/&lt;username&gt;/&lt;repository&gt;/archive/refs/heads/main.zip /app/
# Установка инструмента для работы с архивами
RUN apk add --no-cache unzip &amp;&amp; \
    unzip /app/main.zip -d /app/ &amp;&amp; \
    rm /app/main.zip
</code></pre>
<h1 id="compose"><a class="header" href="#compose">Compose</a></h1>
<pre><code class="language-bash">version=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | jq -r .tag_name)
curl -L "https://github.com/docker/compose/releases/download/$version/docker-compose-$(uname -s)-$(uname -m)" -o $HOME/.local/bin/docker-compose
chmod +x $HOME/.local/bin/docker-compose
docker-compose --version
</code></pre>
<h2 id="uptime-kuma"><a class="header" href="#uptime-kuma">Uptime-Kuma</a></h2>
<p><a href="https://github.com/louislam/uptime-kuma">Uptime-Kuma</a> - веб-интерфейс для мониторинга доступности хостов (ICMP), портов (TCP), веб-контент (HTTP/HTTPS запросы), gRPC, DNS, контейнеры Docker, базы данных и т.д с поддержкой уведомлений в Telegram.</p>
<p><code>nano docker-compose.yml</code></p>
<pre><code class="language-yaml">services:
  uptime-kuma:
    image: louislam/uptime-kuma:latest
    container_name: uptime-kuma
    volumes:
      - uptime-kuma:/app/data
    ports:
      - "8081:3001"
    restart: unless-stopped
volumes:
  uptime-kuma:
</code></pre>
<p><code>docker-compose up -d</code></p>
<p><code>kuma_db=$(docker inspect uptime-kuma | jq -r .[].Mounts.[].Source)</code> место хранения конфигураций в базе SQLite <br />
<code>cp $kuma_db/kuma.db $HOME/uptime-kuma-backup.db</code></p>
<p>Сгенерировать API ключ: <code>http://192.168.3.101:8081/settings/api-keys</code> <br />
<code>curl -u":uk1_fl3JxkSDwGLzQuHk2FVb8z89SCRYq0_3JbXsy73t" http://192.168.3.101:8081/metrics</code></p>
<p>Пример конфигурации для Prometheus:</p>
<pre><code class="language-yaml">scrape_configs:
  - job_name: uptime-kuma
    scrape_interval: 30s
    metrics_path: /metrics
    static_configs:
      - targets:
        - '192.168.3.101:8081'
    basic_auth:
      password: uk1_fl3JxkSDwGLzQuHk2FVb8z89SCRYq0_3JbXsy73t
</code></pre>
<p>Dashboard для Grafana - <a href="https://grafana.com/grafana/dashboards/18667-uptime-kuma-metrics">Uptime Kuma - SLA/Latency/Certs</a> (id 18667)</p>
<p><a href="https://github.com/MedAziz11/Uptime-Kuma-Web-API">Uptime-Kuma-Web-API</a> - оболочка API и Swagger документация написанная на Python с использованием FastAPI и <a href="https://github.com/lucasheld/uptime-kuma-api">Uptime-Kuma-API</a>.</p>
<p>nano docker-compose.yml</p>
<pre><code class="language-yaml">services:
  uptime-kuma-web:
    container_name: uptime-kuma-frontend
    image: louislam/uptime-kuma:latest
    ports:
      - "8081:3001"
    restart: unless-stopped
    volumes:
      - uptime-kuma:/app/data

  uptime-kuma-api:
    container_name: uptime-kuma-backend
    image: medaziz11/uptimekuma_restapi
    volumes:
      - uptime-api:/db
    restart: unless-stopped
    environment:
      - KUMA_SERVER=http://uptime-kuma-web:3001
      - KUMA_USERNAME=admin
      - KUMA_PASSWORD=KumaAdmin
      - ADMIN_PASSWORD=KumaApiAdmin
    depends_on:
      - uptime-kuma-web
    ports:
      - "8082:8000"

volumes:
  uptime-kuma:
  uptime-api:
</code></pre>
<p><code>docker-compose up -d</code></p>
<p>OpenAPI Docs (Swagger): http://192.168.3.101:8082/docs</p>
<pre><code class="language-bash">TOKEN=$(curl -sS -X POST http://192.168.3.101:8082/login/access-token --data "username=admin" --data "password=KumaApiAdmin" | jq -r .access_token)
curl -s -X GET -H "Authorization: Bearer ${TOKEN}" http://192.168.3.101:8082/monitors | jq .
curl -s -X GET -H "Authorization: Bearer ${TOKEN}" http://192.168.3.101:8082/monitors/1 | jq '.monitor | "\(.name) - \(.active)"'
</code></pre>
<h2 id="dozzle"><a class="header" href="#dozzle">Dozzle</a></h2>
<p>Dozzle (https://github.com/amir20/dozzle) - легковесное приложение с веб-интерфейсом для мониторинга журналов Docker (без хранения).</p>
<p><code>mkdir dozzle &amp;&amp; cd dozzle &amp;&amp; mkdir dozzle_data</code></p>
<p><code>echo -n DozzleAdmin | shasum -a 256</code> получить пароль в формате sha-256 и передать в конфигурацию</p>
<pre><code class="language-yaml">echo '
users:
  admin:
    name: "admin"
    password: "a800c3ee4dac5102ed13ba673589077cf0a87a7ddaff59882bb3c08f275a516e"
' &gt; ./dozzle_data/users.yml
</code></pre>
<p>Запускаем контейнер:</p>
<pre><code class="language-yaml">echo '
services:
  dozzle:
    image: amir20/dozzle:latest
    container_name: dozzle
    restart: unless-stopped
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./dozzle_data:/data
    ports:
      - 9090:8080
    environment:
      DOZZLE_AUTH_PROVIDER: simple
      # Доступ к удаленному хосту через Docker API (tcp socket)
      # DOZZLE_REMOTE_HOST: tcp://192.168.3.102:2375|mon-01
' &gt; docker-compose.yml
</code></pre>
<p><code>docker-compose up -d</code></p>
<h2 id="watchtower"><a class="header" href="#watchtower">Watchtower</a></h2>
<p><a href="https://github.com/containrrr/watchtower">Watchtower</a> - следить за тегом <code>latest</code> в реестре Docker Hub и обновлять контейнер, если он станет устаревшим.</p>
<pre><code class="language-yaml">echo "
services:
  watchtower:
    image: containrrr/watchtower
    container_name: watchtower
    environment:
      - WATCHTOWER_LIFECYCLE_HOOKS=1
      - WATCHTOWER_NOTIFICATIONS=shoutrrr
      - WATCHTOWER_NOTIFICATION_URL=telegram://&lt;BOT_API_KEY&gt;@telegram/?channels=&lt;CHAT/CHANNEL_ID&gt;
      # - WATCHTOWER_HTTP_API_TOKEN=demotoken
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    command: --interval 600 --http-api-metrics --http-api-token demotoken # --http-api-update # --http-api-periodic-polls
    ports:
      - 8070:8080
    restart: unless-stopped
" &gt; docker-compose.yml
</code></pre>
<p><code>docker-compose up -d</code></p>
<p>Проброс потра используется для получения метрик через Prometheus. Если нужно запускать обновления только через API, нужно добавить команду <code>--http-api-update</code>, или указать команду <code>--http-api-periodic-polls</code>, что бы использовать ручное и автоматическое обновление.</p>
<p><code>curl -H "Authorization: Bearer demotoken" http://192.168.3.101:8070/v1/metrics</code> получить метрики <br />
<code>curl -H "Authorization: Bearer demotoken" http://192.168.3.101:8070/v1/update</code> проверить и запустить обновления</p>
<p>Добавить <code>scrape_configs</code> в <code>prometheus.yml</code> для сбора метрик:</p>
<pre><code class="language-yaml">scrape_configs:
  - job_name: watchtower
    scrape_interval: 5s
    metrics_path: /v1/metrics
    bearer_token: demotoken
    static_configs:
      - targets:
        - '192.168.3.101:8070'
</code></pre>
<p><code>docker-compose restart prometheus</code></p>
<p>Чтобы исключить обновления, нужно добавить "lable" при запуске контейнера:</p>
<pre><code class="language-bash">docker run -d --name kinozal-bot \
  -v /home/lifailon/kinozal-bot/torrents:/home/lifailon/kinozal-bot/torrents \
  --restart=unless-stopped \
  --label com.centurylinklabs.watchtower.enable=false \
  kinozal-bot
</code></pre>
<h2 id="portainer"><a class="header" href="#portainer">Portainer</a></h2>
<p><code>curl -L https://downloads.portainer.io/portainer-agent-stack.yml -o portainer-agent-stack.yml</code> скачать yaml файл <br />
<code>version_update=$(cat portainer-agent-stack.yml | sed "s/2.11.1/latest/g")</code> <br />
<code>printf "%s\n" "$version_update" &gt; portainer-agent-stack.yml</code> обновить версию в yaml файле на последнюю доступную в Docker Hub (2.19.5) <br />
<code>docker stack deploy -c portainer-agent-stack.yml portainer</code> развернуть в кластере swarm (на каждом node будет установлен агент, который будет собирать данные, а на manager будет установлен сервер с web панелью) <br />
https://192.168.3.101:9443</p>
<p><code>docker run -d --name portainer_agent -p 9001:9001 --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /var/lib/docker/volumes:/var/lib/docker/volumes portainer/agent:2.19.5</code> установить агент на удаленный хост <br />
https://192.168.3.101:9443/#!/endpoints добавить удаленный хост по URL 192.168.3.102:9001</p>
<p><code>docker volume create portainer_data</code> создать volume для установки локального контейнера (не в кластер swarm) <br />
<code>docker create -it --name=portainer -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</code> создать локальный контейнер <br />
<code>docker start portainer</code> <br />
http://192.168.3.101:9000</p>
<h1 id="dockerdotnet"><a class="header" href="#dockerdotnet">Docker.DotNet</a></h1>
<pre><code class="language-PowerShell"># Импорт библиотеки Docker.DotNet (https://nuget.info/packages/Docker.DotNet/3.125.15)
Add-Type -Path "$home\Documents\Docker.DotNet-3.125.15\lib\netstandard2.1\Docker.DotNet.dll"
# Указываем адрес удаленного сервера Docker, на котором слушает сокет Docker API
$config = [Docker.DotNet.DockerClientConfiguration]::new("http://192.168.3.102:2375")
# Подключаемся клиентом
$client = $config.CreateClient()
# Получить список методов класса клиента
$client | Get-Member
# Выводим список контейнеров
$containers = $client.Containers.ListContainersAsync([Docker.DotNet.Models.ContainersListParameters]::new()).GetAwaiter().GetResult()
# Забираем id по имени
$kuma_id = $($containers | Where-Object names -match "uptime-kuma-front").id
# Получить список дочерних методов
$client.Containers | Get-Member
# Остановить контейнер по его id
$StopParameters = [Docker.DotNet.Models.ContainerStopParameters]::new()
$client.Containers.StopContainerAsync($kuma_id, $StopParameters)
# Запустить контейнер
$StartParameters = [Docker.DotNet.Models.ContainerStartParameters]::new()
$client.Containers.StartContainerAsync($kuma_id, $StartParameters)
</code></pre>
<h1 id="swarm"><a class="header" href="#swarm">Swarm</a></h1>
<p><code>docker swarm init</code> инициализировать manager node и получить токен для подключения worker node (сервер) <br />
<code>docker swarm join-token manager</code> узнать токен подключения <br />
<code>docker swarm join --token SWMTKN-1-1a078rm7vuenefp6me84t4swqtvdoveu6dh2pw34xjcf2gyw33-81f8r32jt3kkpk4dqnt0oort9 192.168.3.101:2377</code> подключение на worker node (клиент) <br />
<code>docker node ls</code> отобразить список node на manager node <br />
<code>docker node inspect u4u897mxb1oo39pbj5oezd3um</code> подробная информация (конфигурация) о node по id <br />
<code>docker swarm leave --force</code> выйти из кластера на worker node (на manager node изменится статус с Ready на Down) <br />
<code>docker node rm u4u897mxb1oo39pbj5oezd3um</code> удалить node (со статусом Down) на manager node <br />
<code>docker pull lifailon/torapi:latest</code></p>
<p><code>nano docker-compose-stack.yml</code></p>
<pre><code class="language-yaml">version: "3.8"
services:
  torapi:
    image: lifailon/torapi:latest
    deploy:
      replicas: 2
      restart_policy:
        condition: on-failure
      update_config:
        order: start-first
      # Режим виртуального IP для балансировки нагрузки
      endpoint_mode: vip
    volumes:
      - torapi:/rotapi
    ports:
      # Порт внутри контейнера
      - target: 8443
        published: 8443
        protocol: tcp
        # Режим балансировки нагрузки по умолчанию
        mode: ingress
volumes:
  torapi:
</code></pre>
<p><code>docker stack deploy -c docker-compose-stack.yml TorAPI</code> собрать стек сервисов, определенных в docker-compose (на worker node появится контейнер TorAPI_torapi.1.ug5ngdlqkl76dt)</p>
<p><code>docker stack ls</code> отобразить список стеков <br />
<code>docker service ls</code> список сервисов всех стеков <br />
<code>docker stack ps TorAPI</code> список задач в стеке <br />
<code>docker stack services TorAPI</code> список сервисов внутри стека указанного стека по имени <br />
<code>docker service ps TorAPI_torapi</code> подробная информация о сервисе по его имени (TorAPI имя стека и _torapi имя сервиса) <br />
<code>docker service inspect --pretty TorAPI_torapi</code> конфигурация сервиса <br />
<code>docker service inspect TorAPI_torapi</code> конфигурация сервиса в формате JSON <br />
<code>docker service logs TorAPI_torapi</code> журнала конкретного сервиса по всем серверам кластера <br />
<code>docker service scale TorAPI_torapi=3</code> масштабирует сервис до указанного числа реплик <br />
<code>docker stack rm TorAPI</code> удалить стек (не требует остановки контейнеров)</p>
<h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<h2 id="micro8s"><a class="header" href="#micro8s">Micro8s</a></h2>
<p><a href="https://github.com/canonical/microk8s">Micro8s</a> - это полностью совместимый и легкий Kubernetes в одном пакете, работающий на 42 разновидностях Linux.</p>
<p><code>snap install microk8s --classic</code> установка <br />
<code>microk8s status --wait-ready</code> отобразить статус работы (дождаться инициализации служб Kubernetes) и список дополнений <br />
<code>microk8s start</code> запустить или остановить (stop) MicroK8s и его службы <br />
<code>microk8s enable dashboard</code> запустить dashboard <br />
<code>microk8s enable dns</code> установка обновлений <br />
<code>sudo usermod -a -G microk8s $USER &amp;&amp; mkdir -p ~/.kube &amp;&amp; chmod 0700 ~/.kube</code> добавить текущего пользователя в группу управления microk8s (создается при установке) <br />
<code>alias kubectl='microk8s kubectl'</code> добавить псевдоним, для использования команды kubectl через microk8s <br />
<code>kubectl get nodes</code> отобразить список нод <br />
<code>kubectl config view --raw &gt; $HOME/.kube/config</code> передать конфигурацию в MicroK8s, для использования с существующим kubectl</p>
<h2 id="k3s"><a class="header" href="#k3s">k3s</a></h2>
<p><a href="https://github.com/k3s-io/k3s">K3s</a> — это полностью совместимый дистрибутив Kubernetes в формате единого двоичного файле, который удаляет хранение драйверов и поставщика облачных услуг, а также добавляет поддержку sqlite3 для backend хранилища.</p>
<p><code>curl -sfL https://get.k3s.io | sh -</code> установка службы в systemd и утилит <code>kubectl</code>, <code>crictl</code>, <code>k3s-killall.sh</code> и <code>k3s-uninstall.sh</code> <br />
<code>/etc/rancher/k3s/k3s.yaml</code> конфигурация <br />
<code>/var/lib/rancher/k3s/server/node-token</code> токен авторизации <br />
<code>curl -sfL https://get.k3s.io | K3S_URL=https://myserver:6443 K3S_TOKEN=XXX sh -</code> передать переменные окружения K3S_URL и K3S_TOKEN токен для установки на рабочие ноды <br />
<code>sudo k3s server &amp;</code> запустить сервер кластера <br />
<code>sudo k3s agent --server https://myserver:6443 --token ${NODE_TOKEN}</code> подключиться к кластеру <br />
<code>sudo k3s kubectl get nodes</code> отобразить список нод в кластере</p>
<h2 id="minikube"><a class="header" href="#minikube">Minikube</a></h2>
<p><a href="https://github.com/kubernetes/minikube">Minikube</a> - это локальный кластер Kubernetes от создателя оригинального k8s</p>
<pre><code class="language-bash">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe
mv minikube-windows-amd64.exe minikube.exe
</code></pre>
<p><code>minikube start --vm-driver=hyperv --memory=4g --cpus=2</code> запустить кластер и/или создать виртуальную машину <br />
<code>minikube status</code> статус работы кластера <br />
<code>minikube stop</code> остановить кластер <br />
<code>minikube delete</code> удалить виртуальную машину <br />
<code>minikube profile list</code> узнать информацию о драйвере, ip, версии и количество Nodes <br />
<code>minikube dashboard --port 8085</code> запустить api сервер и интерфейс состояния</p>
<p><code>minikube addons list</code>  список доступных дополнений и их статус работы <br />
<code>minikube addons enable metrics-server</code> активировать дополнение, которое предоставляет метрики для HPA, такие как загрузка процессора и использование памяти <br />
<code>kubectl get deployment metrics-server -n kube-system</code> текущее состояние развертывания metrics-server в кластере <br />
<code>kubectl get pod,svc -n kube-system</code> отобразить список системных подов и сервисов в кластере (pod/metrics-server-7fbb699795-wvfxb) <br />
<code>kubectl logs -n kube-system deployment/metrics-server</code> отобразить логи metrics-server <br />
<code>kubectl top pods</code> отобразить метрики на подах (CPU/MEM) <br />
<code>minikube addons disable metrics-server</code> отключить дополнение</p>
<p><code>minikube addons enable ingress</code> включить Nginx Ingress Controller <br />
<code>kubectl get pods -n kube-system</code> отобразить список системных подов (должен появиться ingress-nginx-controller) <br />
<code>minikube tunnel --alsologtostderr</code> создает виртуальный LoadBalancer в Minikube, для перенаправления трафика на нужный сервис, вместо использования NodePort</p>
<h2 id="kubectl"><a class="header" href="#kubectl">kubectl</a></h2>
<p><code>Node</code> - физическая или виртуальная машина, на которой работает Kubernetes-кластер, каждый узел выполняет контейнеры и поды <br />
<code>Pod</code> - содержит один или несколько контейнеров работающих вместе, которые всегда разворачиваются в кластере <br />
<code>Deployment</code> - управляет состоянием подов и отвечает за масштабируемость (автоматический перезапуск контейнеров и замена подов при сбоях), чтобы их количество соответствовало желаемому числу реплик (ReplicaSet) <br />
<code>Service</code> - абстракция, которая отвечает за балансировку нагрузки (обрабатывает входящий трафик и распределяет его между подами), а также обеспечивая стабильный IP-адрес и DNS-имя для общения с ними</p>
<p><code>kubectl config view</code> отобразить конфигурацию кластера (настройка подключения kubectl к Kubernetes, которое взаимодействует с приложением через конечные точки REST API) <br />
<code>sudo cp ~/.minikube/ca.crt /usr/local/share/ca-certificates/minikube.crt &amp;&amp; update-ca-certificates &amp;&amp; openssl verify /usr/local/share/ca-certificates/minikube.crt</code> установка сертификатов в Linux <br />
<code>Import-Certificate -FilePath "$HOME\.minikube\ca.crt" -CertStoreLocation Cert:\LocalMachine\Root &amp;&amp; Import-Certificate -FilePath "$HOME\.minikube\profiles\minikube\client.crt" -CertStoreLocation Cert:\CurrentUser\My &amp;&amp; ls Cert:\LocalMachine\Root | Where-Object Subject -Match "minikube"</code> установка сертификатов в Windows <br />
<code>curl -k https://192.168.27.252:8443/version</code> удаленный доступ к API Kubernetes (адрес и порт можно взять из config view) <br />
<code>kubectl get namespaces</code> вывести все namespace <br />
<code>kubectl get nodes</code> отобразить список node и их статус работы, роль (master/node), время запуска и версию <br />
<code>kubectl get events</code> отобразить логи кластера</p>
<p><code>kubectl create deployment test-node --image=registry.k8s.io/e2e-test-images/agnhost:2.39 -- /agnhost netexec --http-port=8080</code> создать под из указанного Docker образа (запускает контейнер и внутри него команду для запуска веб-сервера на порту 8080) <br />
<code>kubectl get deployments</code> статус всех Deployments (контроллеров), которые в свою очередь управляют Pod-ами (RADY - количество экземпляров-реплик, UP-TO-DATE — количество реплик, которые были обновлены) <br />
<code>kubectl get pods</code> статус всех подов <br />
<code>kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}'</code> получить список имен всех под через шаблон фильтра</p>
<p><code>kubectl proxy</code> запустить прокси сервер для локального взаимодействия с частной сетью кластера через API (без авторизации), где автоматически создаются конечные точки для каждого пода в соответствии с его именем <br />
<code>curl http://localhost:8001</code> отобразить список всех конечных точек (endpoints) <br />
<code>curl http://localhost:8001/api/v1/namespaces/default/pods/test-node-69f66d85f8-2d2tv:8080/proxy/</code> конечная точка, которая проксирует запрос внутрь пода по его имени (напрямую к приложению в контейнере) <br />
<code>kubectl port-forward pod/test-node-69f66d85f8-2d2tv 8080:8080</code> запустить сервер для проброса порта из пода <br />
<code>curl http://localhost:8080</code></p>
<p><code>kubectl expose deployment test-node --type=LoadBalancer --port=8080</code> предоставить pod как service (пробросить порт из частной сети Kubernetes) в режиме балансировки нагрузки <br />
<code>--type=ClusterIP</code> - открывает доступ к сервису по внутреннему IP-адресу в кластере (по умолчанию), этот тип делает сервис доступным только внутри кластера <br />
<code>--type=NodePort</code> - открывает сервис на том же порту каждого выбранного узла в кластере с помощью NAT, и делает сервис доступным вне кластера через <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> (надмножество ClusterIP) <br />
<code>--type=LoadBalancer</code> - создает внешний балансировщик нагрузки и назначает фиксированный внешний IP-адрес для сервиса (надмножество NodePort) <br />
<code>--type=ExternalName</code> - открывает доступ к сервису по содержимому поля externalName (например, foo.bar.example.com), возвращая запись CNAME с его значением</p>
<p><code>kubectl get services</code> отобразить список сервисов (CLUSTER-IP, EXTERNAL-IP и PORT 8080:32467/TCP), которые принимают внешний трафик <br />
<code>kubectl describe services test-node</code> отобразить настройки сервиса для внешнего доступа (ip, тип сервиса и конечные точки) <br />
<code>curl http://192.168.27.252:32467</code> проверить доступность приложения</p>
<p><code>kubectl describe pods test-node</code> отобразить какие контейнеры находятся внутри пода, а также какие образы и команды (/agnhost netexec --http-port=8080) использовались при сборке этих контейнеров <br />
<code>kubectl logs test-node-69f66d85f8-2d2tv</code> отобразить логи контейнера в поде (сообщения, которые приложение отправляет в standard output) <br />
<code>kubectl exec test-node-69f66d85f8-2d2tv -c agnhost -- ls -lha</code> выполнить команду в контейнере указанного пода <br />
<code>kubectl exec test-node-69f66d85f8-2d2tv -c agnhost -- env</code> отобразить список глобальных переменных в контейнере <br />
<code>kubectl exec -it test-node-69f66d85f8-2d2tv -c agnhost -- curl http://localhost:8080</code> проверить доступность приложения внутри контейнера <br />
<code>kubectl exec -it test-node-69f66d85f8-2d2tv -c agnhost -- bash</code> запустить bash сессию в контейнере пода</p>
<p><code>kubectl get rs</code> состояние реплик (ReplicaSet) для всех deployment <br />
<code>kubectl scale deployments/test-node --replicas=4</code> масштабируем deployment до 4 реплик <br />
<code>kubectl scale deployments/test-node --replicas=2</code> уменьшить deployment до 2 реплик подов <br />
<code>kubectl describe deployments/test-node</code> изменения фиксируется в конфигурации deployment -&gt; Events (Scaled down replica set test-node-69f66d85f8 from 4 to 2) <br />
<code>kubectl get rs</code> проверить текущее количество под в deployment и их состояние (DESIRED - желаемое количество экземпляров-реплик и CURRENT - текущее количество реплик) <br />
<code>kubectl get endpoints test-node</code> отобразить на какие адреса (ip и порт) подов перенаправляется трафик сервиса test-node <br />
<code>kubectl get pods -o wide</code> отобразить количество всех подов (у каждого пода разное время работы в AGE и свой ip-адрес)</p>
<p><code>kubectl logs -l app=test-node --follow</code> выводить лог в реальном времени для всех запущенных репликах подов указанного deployment <br />
<code>PODS_NAME=$(kubectl get pods -l app=test-node -o jsonpath="{.items[*].metadata.name}")</code> получаем названия всех подов указанного deployment <br />
<code>for POD_NAME in $PODS_NAME; do kubectl logs $POD_NAME --follow | awk -v pod=$POD_NAME '{print "[" pod "] " $0}' &amp; done</code> отобразить лог приложения конкретного пода по имени <br />
<code>NODE_PORT="$(kubectl get services test-node -o go-template='{{(index .spec.ports 0).nodePort}}')"</code> получить порт указанного сервиса <br />
<code>for i in {1..5}; do curl -s "http://$(minikube ip):$NODE_PORT"; echo ""; done</code> каждый запрос будет попадать на разный под</p>
<p><code>kubectl delete service test-node</code> удалить службу <br />
<code>kubectl delete deployment test-node</code> удалить под</p>
<p><code>kubectl run busybox --rm -it --image=busybox:latest -- /bin/sh</code> создание временного пода для отладки (контейнер busybox, который можно использовать для отладки сети и команд curl, ping и т.д.)</p>
<p><code>kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1 \  </code>kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --port 8080 <br />
<code>kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=docker.io/jocatalin/kubernetes-bootcamp:v2</code> выполнение плавающего обновления версии образа работающего контейнера <br />
<code>kubectl rollout status deployments/kubernetes-bootcamp</code> проверить статус обновления <br />
<code>kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10</code> выполнить обновление на несуществующую версию <br />
<code>kubectl rollout undo deployments/kubernetes-bootcamp</code> откатить deployment к последней работающей версии (к предыдущему известному состоянию в образе v2)</p>
<p><code>kubectl get configmap</code> Получить все ConfigMap <br />
<code>kubectl describe configmap kube-root-ca.crt</code> отобразить содержимое корневого сертифика</p>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<pre><code class="language-yaml">echo '
apiVersion: apps/v1
kind: Deployment
metadata:
  name: torapi # ммя Deployment, который управляет созданием подов (Pods)
spec:
  replicas: 2 # количество реплик (2 пода с одинаковыми настройками)
  selector:
    matchLabels:
      app: torapi # определяет, какие поды будут управляться этим Deployment
  template:
    metadata:
      labels:
        app: torapi  # метка, которая связывает этот шаблон с селектором выше
    spec:
      containers:
      - name: torapi                    # имя контейнера внутри пода
        image: lifailon/torapi:latest   # используемый образ контейнера
        ports:
        - containerPort: 8443           # порт, который будет открыт внутри контейнера
        resources:                      # ограничения и минимальные требования по ресурсам
          requests:
            cpu: "100m"                 # Минимальный запрашиваемый процессор (100 милли-ядра)
            memory: "64Mi"              # Минимальный запрашиваемый объем оперативной памяти (64 МБайт)
          limits:
            cpu: "200m"                 # Максимально доступное процессорное время 
            memory: "256Mi"             # Максимальный объем памяти
        livenessProbe:                  # Проверка работоспособности контейнера
          httpGet:
            path: /api/provider/list    # endpoint контейнера, по которому проверяется работоспособность
            port: 8443                  # порт, на котором доступен этот endpoint внутри контейнера
          initialDelaySeconds: 5        # ждет 5 секунд после запуска контейнера перед первой проверкой
          periodSeconds: 10             # интервал проверки (повторяет проверку каждые 10 секунд)
          timeoutSeconds: 3             # максимальное время ожидания ответа
          failureThreshold: 3           # количество неудачных попыток перед рестартом
' &gt; torapi-deployment.yaml
</code></pre>
<p><code>kubectl apply -f torapi-deployment.yaml</code></p>
<pre><code class="language-yaml">echo '
apiVersion: v1
kind: Service
metadata:
  name: torapi-service
  namespace: default
spec:
  selector:
    app: torapi
  ports:
    - protocol: TCP
      port: 8444        # Внутренний порт сервиса
      targetPort: 8443  # Порт контейнера
      nodePort: 30000   # Фиксированный внешний порт (valid range 30000-32767)
  type: LoadBalancer
' &gt; torapi-service.yaml
</code></pre>
<p><code>kubectl apply -f torapi-service.yaml</code></p>
<p><code>kubectl get pods</code> будет создано два пода <br />
<code>kubectl logs torapi-54775d94b8-vp26b</code> отобразить логи пода, будут идти запросы от 10.244.0.1 (kube-probe/1.32) для проверки доступности <br />
<code>kubectl exec -it torapi-54775d94b8-vp26b -- npm --version</code> вывести версию npm внутри контейнера <br />
<code>kubectl get services torapi-service</code> <br />
<code>kubectl describe service torapi-service</code> узнать Server Port, TargetPort (container) и NodePort <br />
<code>kubectl port-forward --address 0.0.0.0 service/torapi-service 8444:8444</code> <br />
<code>curl http://192.168.3.100:8444/api/provider/list</code></p>
<h2 id="hpa"><a class="header" href="#hpa">HPA</a></h2>
<p><code>HPA</code> (Horizontal Pod Autoscaling) - горизонтальное масштабирование позволяет автоматически увеличивать или уменьшать количество реплик (подов) в зависимости от текущей нагрузки по показателям метрик, получаемых из <code>metrics-server</code>.</p>
<p><code>kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml</code> активировать metrics-server в Docker-Desktop (загрузить и применить конфигурацию) <br />
<code>kubectl logs -n kube-system deployment/metrics-server</code> проверить логи metrics-server <br />
<code>kubectl get deployment metrics-server -n kube-system</code> отобразить статус работы metrics-server <br />
<code>kubectl top nodes</code> отобразить метрики ресурсов для всех узлов в кластере</p>
<p><code>kubectl edit deployment metrics-server -n kube-system</code> отключить проверку TLS</p>
<pre><code class="language-yaml">spec:
  containers:
  - args:
    - --kubelet-insecure-tls
</code></pre>
<p><code>kubectl rollout restart deployment metrics-server -n kube-system</code> перезапустить metrics-server</p>
<pre><code class="language-yaml">echo '
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: torapi-hpa
  namespace: default
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: torapi
  minReplicas: 1
  maxReplicas: 5
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 50 # когда среднее использование CPU превышает 50%, будет увеличено количество реплик, чтобы уменьшить нагрузку на поды
' &gt; torapi-hpa.yaml
</code></pre>
<p><code>kubectl apply -f torapi-hpa.yaml</code></p>
<p><code>kubectl get hpa</code> отобразить статус работы всех HPA и текущие таргеты (cpu: 1%/50%) <br />
<code>kubectl get pods</code> будет активен 1 под из 5 подов (вместо двух, изначально определенных в Deployment)</p>
<h2 id="ingress"><a class="header" href="#ingress">Ingress</a></h2>
<p><code>Ingress</code> - это балансировщик нагрузки, который также управляет HTTP/HTTPS трафиком в кластер и направляет его к нужным логическим сервисам (маршрутизация запросов к разным конечным точкам в path).</p>
<p><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml</code> установить Ingress Controller <br />
<code>kubectl get pods -n ingress-nginx</code> <br />
<code>kubectl get svc -n ingress-nginx</code></p>
<pre><code class="language-yaml">echo '
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: torapi-ingress
  namespace: default
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
  - host: torapi.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: torapi-service
            port:
              number: 8444
' &gt; torapi-ingress.yaml
</code></pre>
<p><code>kubectl apply -f torapi-ingress.yaml</code> <br />
<code>kubectl get ingress</code> отобразить статус работы ingress</p>
<p>Настраиваем <code>HPA</code> на основе 100 и выше HTTP-запросов в секунду через метрику <code>nginx_ingress_controller_requests</code>:</p>
<pre><code class="language-yaml">echo '
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: torapi-hpa
  namespace: default
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: torapi
  minReplicas: 1
  maxReplicas: 5
  metrics:
  - type: External
    external:
      metric:
        name: nginx_ingress_controller_requests
      target:
        type: Value
        value: "100"
' &gt; torapi-hpa.yaml
</code></pre>
<p><code>kubectl apply -f torapi-hpa.yaml</code> <br />
<code>kubectl get hpa</code> отобразить статус работы HPA</p>
<h2 id="secrets"><a class="header" href="#secrets">Secrets</a></h2>
<p><code>kubectl create secret generic admin-password --from-literal=username=admin --from-literal=password=Secret2025</code> создать секрет в формате ключ-значение <br />
<code>kubectl create secret generic api-key --from-file=api-key.txt</code> создать секрет из содержимого файла <br />
<code>kubectl get secret</code> получить список всех секретов <br />
<code>kubectl describe secret admin-password</code> получить информацию о секрете (размер в байтах) <br />
<code>kubectl get secret admin-password -o yaml</code> получить содержимое секретов в кодировке base64 <br />
<code>kubectl get secret admin-password -o jsonpath="{.data.password}" | base64 --decode</code> декодировать содержимое секрета <br />
<code>kubectl delete secret admin-password</code> удалить секрет</p>
<pre><code class="language-yaml">echo '
apiVersion: v1
kind: Secret
metadata:
  name: admin-password
type: Opaque
data:
  username: YWRtaW4=
  password: U2VjcmV0MjAyNQ==
' &gt; admin-secret.yaml
</code></pre>
<p><code>kubectl apply -f admin-secret.yaml</code></p>
<p>Передать secret в контейнер через переменные окружения:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx-secret-test
spec:
  containers:
  - name: nginx-secret-test
    image: nginx
    env:
    - name: USERNAME
      valueFrom:
        secretKeyRef:
          name: admin-password  # Имя секрета
          key: username         # Ключ в секрете
    - name: PASSWORD
      valueFrom:
        secretKeyRef:
          name: admin-password
          key: password
</code></pre>
<h2 id="kompose"><a class="header" href="#kompose">Kompose</a></h2>
<p><a href="https://github.com/kubernetes/kompose">Kompose</a> - это инструмент, который конвертируемт спецификацию docker-compose в файлы Kubernetes.</p>
<p><code>curl -L https://github.com/kubernetes/kompose/releases/download/v1.35.0/kompose-linux-amd64 -o kompose</code> установка <br />
<code>kompose --file docker-compose.yaml convert</code> конвертация</p>
<h2 id="k9s"><a class="header" href="#k9s">k9s</a></h2>
<p><a href="https://github.com/derailed/k9s">K9s</a> - это TUI интерфейс для взаимодействия с кластерами Kubernetes (управление и чтение логов).</p>
<p><code>snap install k9s --devmode || wget https://github.com/derailed/k9s/releases/download/v0.32.7/k9s_linux_amd64.deb &amp;&amp; apt install ./k9s_linux_amd64.deb &amp;&amp; rm k9s_linux_amd64.deb</code> <br />
<code>winget install k9s || scoop install k9s || choco install k9s || curl.exe -A MS https://webinstall.dev/k9s | powershell</code></p>
<div style="break-before: page; page-break-before: always;"></div><p>+++
title = "Network"
[extra]
toc = true
toc_sidebar = true
go_to_top = true
+++</p>
<p>Заметки по сетевым утилитам.</p>
<hr />
<h1 id="network-1"><a class="header" href="#network-1">Network</a></h1>
<h3 id="ping-1"><a class="header" href="#ping-1">ping</a></h3>
<p><code>Test-Connection -Count 1 $srv1, $srv2</code> отправить icmp-пакет двум хостам <br />
<code>Test-Connection $srv -ErrorAction SilentlyContinue</code> не выводить ошибок, если хост не отвечает <br />
<code>Test-Connection -Source $srv1 -ComputerName $srv2</code> пинг с удаленного компьютера</p>
<pre><code class="language-PowerShell">function Test-PingNetwork {
param (
    [Parameter(Mandatory,ValueFromPipeline)][string[]]$Network,
    [ValidateRange(100,10000)][int]$Timeout = 100
)
$ping = New-Object System.Net.NetworkInformation.Ping
$Network  = $Network -replace "0$"
$net = @()
foreach ($r in @(1..254)) {
    $net += "$network$r"
}
foreach ($n in $net) {
    $ping.Send($n, $timeout) | select @{Name="Address"; Expression={$n -replace ".+\."}}, Status
}
}
</code></pre>
<p><code>Test-PingNetwork -Network 192.168.3.0</code> <br />
<code>Test-PingNetwork -Network 192.168.3.0 -Timeout 1000</code></p>
<p><code>Get-CimInstance -Class Win32_PingStatus -Filter "Address='127.0.0.1'"</code> <br />
<code>Get-CimInstance -Class Win32_PingStatus -Filter "Address='127.0.0.1'" | Format-Table -Property Address,ResponseTime,StatusCode -Autosize</code> 0 - успех <br />
<code>'127.0.0.1','8.8.8.8' | ForEach-Object -Process {Get-CimInstance -Class Win32_PingStatus -Filter ("Address='$_'") | Select-Object -Property Address,ResponseTime,StatusCode}</code> <br />
<code>$ips = 1..254 | ForEach-Object -Process {'192.168.1.' + $_}</code> сформировать массив из ip-адресов подсети</p>
<h3 id="dhcp"><a class="header" href="#dhcp">dhcp</a></h3>
<p><code>Get-CimInstance -Class Win32_NetworkAdapterConfiguration -Filter "DHCPEnabled=$true"</code> отобразить адаптеры с включенным DHCP <br />
<code>$wql = 'SELECT * from Win32_NetworkAdapterConfiguration WHERE IPEnabled=True and DHCPEnabled=False'</code> <br />
<code>Invoke-CimMethod -MethodName ReleaseDHCPLease -Query $wql</code> включение DHCP на всех адаптерах <br />
<code>Invoke-CimMethod -ClassName Win32_NetworkAdapterConfiguration -MethodName ReleaseDHCPLeaseAll</code> отменить аренду адресов DHCP на всех адаптерах <br />
<code>Invoke-CimMethod -ClassName Win32_NetworkAdapterConfiguration -MethodName RenewDHCPLeaseAll</code> обновить аренду адресов DHCP на всех адаптерах</p>
<h3 id="port"><a class="header" href="#port">port</a></h3>
<p><code>tnc $srv -p 5985</code> <br />
<code>tnc $srv -CommonTCPPort WINRM</code> HTTP,RDP,SMB <br />
<code>tnc ya.ru –TraceRoute -Hops 2</code> TTL=2 <br />
<code>tnc ya.ru -DiagnoseRouting</code> маршрутизация до хоста, куда (DestinationPrefix: 0.0.0.0/0) через (NextHop: 192.168.1.254)</p>
<h3 id="netstat"><a class="header" href="#netstat">netstat</a></h3>
<p><code>netstat -anop tcp</code> -n/-f/-b <br />
<code>Get-NetTCPConnection -State Established,Listen | ? LocalPort -Match 3389</code> <br />
<code>Get-NetTCPConnection -State Established,Listen | ? RemotePort -Match 22</code> <br />
<code>Get-NetUDPEndpoint | ? LocalPort -Match 514</code> netstat -ap udp`</p>
<h3 id="nslookup"><a class="header" href="#nslookup">nslookup</a></h3>
<p><code>nslookup ya.ru 1.1.1.1</code> с указанием DNS сервера <br />
<code>nslookup -type=any ya.ru</code> указать тип записи <br />
<code>Resolve-DnsName ya.ru -Type MX</code> ALL,ANY,A,NS,SRV,CNAME,PTR,TXT(spf) <br />
<code>[System.Net.Dns]::GetHostEntry("ya.ru")</code></p>
<h3 id="ipconfig"><a class="header" href="#ipconfig">ipconfig</a></h3>
<p><code>Get-NetIPConfiguration</code> <br />
<code>Get-NetIPConfiguration -InterfaceIndex 14 -Detailed</code></p>
<h3 id="adapter"><a class="header" href="#adapter">Adapter</a></h3>
<p><code>Get-NetAdapter</code> <br />
<code>Set-NetIPInterface -InterfaceIndex 14 -Dhcp Disabled</code> отключить DHCP <br />
<code>Get-NetAdapter -InterfaceIndex 14 | New-NetIPAddress –IPAddress 192.168.3.99 -DefaultGateway 192.168.3.1 -PrefixLength 24</code> задать/добавить статический IP-адрес <br />
<code>Set-NetIPAddress -InterfaceIndex 14 -IPAddress 192.168.3.98</code> изменить IP-адреас на адаптере <br />
<code>Remove-NetIPAddress -InterfaceIndex 14 -IPAddress 192.168.3.99</code> удалить IP-адрес на адаптере <br />
<code>Set-NetIPInterface -InterfaceIndex 14 -Dhcp Enabled</code> включить DHCP</p>
<h3 id="dnsclient"><a class="header" href="#dnsclient">DNSClient</a></h3>
<p><code>Get-DNSClientServerAddress</code> список интерфейсов и настроенные на них адреса DNS сервера <br />
<code>Set-DNSClientServerAddress -InterfaceIndex 14 -ServerAddresses 8.8.8.8</code> изменить адрес DNS сервера на указанного интерфейсе</p>
<h3 id="dnscache"><a class="header" href="#dnscache">DNSCache</a></h3>
<p><code>Get-DnsClientCache</code> отобразить кэшированные записи клиента DNS <br />
<code>Clear-DnsClientCache</code> очистить кэш</p>
<h3 id="binding"><a class="header" href="#binding">Binding</a></h3>
<p><code>Get-NetAdapterBinding -Name Ethernet -IncludeHidden -AllBindings</code> <br />
<code>Get-NetAdapterBinding -Name "Беспроводная сеть" -DisplayName "IP версии 6 (TCP/IPv6)" | Set-NetAdapterBinding -Enabled $false</code> отключить IPv6 на адаптере</p>
<h3 id="tcpsetting"><a class="header" href="#tcpsetting">TCPSetting</a></h3>
<p><code>Get-NetTCPSetting</code> <br />
<code>Set-NetTCPSetting -SettingName DatacenterCustom,Datacenter -CongestionProvider DCTCP</code> настраивает провайдера управления перегрузкой (Congestion Control Provider) на DCTCP (Data Center TCP) для профилей TCP с именами DatacenterCustom и Datacenter <br />
<code>Set-NetTCPSetting -SettingName DatacenterCustom,Datacenter -CwndRestart True</code> включает функцию перезапуска окна перегрузки (Congestion Window Restart, CwndRestart) для указанных профилей TCP. Это означает, что после периода идле (когда нет передачи данных) TCP окно перегрузки будет сбрасываться <br />
<code>Set-NetTCPSetting -SettingName DatacenterCustom,Datacenter -ForceWS Disabled</code> отключает принудительное масштабирование окна (Forced Window Scaling) для указанных профилей TCP. Масштабирование окна — это механизм, который позволяет увеличивать размер окна перегрузки TCP, чтобы улучшить производительность передачи данных по сети с высокой пропускной способностью и большой задержкой</p>
<h3 id="hostname"><a class="header" href="#hostname">hostname</a></h3>
<p><code>$env:computername</code> <br />
<code>hostname.exe</code> <br />
<code>(Get-CIMInstance CIM_ComputerSystem).Name</code> <br />
<code>(New-Object -ComObject WScript.Network).ComputerName</code> <br />
<code>[System.Environment]::MachineName</code> <br />
<code>[System.Net.Dns]::GetHostName()</code></p>
<h3 id="arp"><a class="header" href="#arp">arp</a></h3>
<p><code>ipconfig /all | Select-String "физ"</code> grep <br />
<code>Get-NetNeighbor -AddressFamily IPv4</code></p>
<pre><code class="language-PowerShell">function Get-ARP {
    Param (
        $proxy,
        $search
    )
    if (!$proxy) {
        $arp = arp -a
    }
    if ($proxy) {
        $arp = icm $proxy { arp -a }
    }
    $mac = $arp[3..260]
    $mac = $mac -replace "^\s\s"
    $mac = $mac -replace "\s{1,50}", " "
    $mac_coll = New-Object System.Collections.Generic.List[System.Object]
    foreach ($m in $mac) {
        $smac = $m -split " "
        $mac_coll.Add([PSCustomObject]@{
                IP   = $smac[0];
                MAC  = $smac[1];
                Type = $smac[2]
            })
    }
    if ($search) {
        if ($search -NotMatch "\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}") {
            #$ns = nslookup $search
            #$ns = $ns[-2]
            #$global:ns = $ns -replace "Address:\s{1,10}"
            $rdns = Resolve-DnsName $search -ErrorAction Ignore
            $ns = $rdns.IPAddress
            if ($ns -eq $null) {
                return
            }
        }
        else {
            $ns = $search
        }
        $mac_coll = $mac_coll | ? ip -Match $ns
    }
    $mac_coll
}
</code></pre>
<p><code>Get-ARP -search 192.168.3.100</code> <br />
<code>Get-ARP -search 192.168.3.100 -proxy dc-01</code></p>
<h3 id="network-adapter-statistics"><a class="header" href="#network-adapter-statistics">Network Adapter Statistics</a></h3>
<p><code>netstat -se</code> <br />
<code>Get-NetAdapterStatistics</code></p>
<h3 id="speedtest"><a class="header" href="#speedtest">SpeedTest</a></h3>
<pre><code class="language-PowerShell">function Get-SpeedTestOokla {
    param (
        $Server = 3682,
        [switch]$List
    )
    $path = "$env:TEMP\speedtest.exe"
    $testPath = Test-Path "$env:TEMP\speedtest.exe"
    if ($testPath -eq $false) {
        Invoke-RestMethod https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-win64.zip -OutFile "$env:TEMP\speedtest.zip"
        Expand-Archive "$env:TEMP\speedtest.zip" -DestinationPath $env:TEMP
    }
    if ($List) {
        $(&amp; $path -L -f json | ConvertFrom-Json).servers
    } else {
        $test = &amp; $path -s $Server -f json
        $Collections = New-Object System.Collections.Generic.List[System.Object]
        $Collections.Add(
            [PSCustomObject]@{
                Date = $($test | ConvertFrom-Json).timestamp
                Url = $($test | ConvertFrom-Json).result.url
                Download = [double]::Round($($($test | ConvertFrom-Json).download.bandwidth / 1mb * 8), 2)
                Upload = [double]::Round($($($test | ConvertFrom-Json).upload.bandwidth / 1mb * 8), 2)
                Ping = $($test | ConvertFrom-Json).ping.latency
                Internal_IP = $($test | ConvertFrom-Json).interface.internalIp
                External_IP = $($test | ConvertFrom-Json).interface.externalIp
                Server = $($test | ConvertFrom-Json).server
            }
        )
        $Collections
    }
}
</code></pre>
<h1 id="iperf"><a class="header" href="#iperf">iPerf</a></h1>
<h3 id="install-1"><a class="header" href="#install-1">Install</a></h3>
<pre><code class="language-PowerShell">$url = $($(Invoke-RestMethod https://api.github.com/repos/ar51an/iperf3-win-builds/releases/latest).assets | Where-Object name -match "win64.zip").browser_download_url
Invoke-RestMethod $url -OutFile $home\Downloads\iperf.zip
New-Item "$home\Documents\iperf3" -Type Directory | Out-Null
Expand-Archive -Path "$home\Downloads\iperf.zip" -OutputPath "$home\Documents\iperf3"
Remove-Item "$home\Downloads\iperf*" -Force -Recurse
</code></pre>
<p><code>&amp; "$home\Documents\iperf3\iperf3.exe" -h</code></p>
<h3 id="env-update-exec-path"><a class="header" href="#env-update-exec-path">Env-Update-Exec-Path</a></h3>
<pre><code class="language-PowerShell">$EnvPath = [Environment]::GetEnvironmentVariable("Path", [EnvironmentVariableTarget]::Machine)
$EnvPath -split ";"
$iperfPath = "$home\Documents\iperf3\"
$EnvAddPath = $EnvPath + ";" + $iperfPath
[Environment]::SetEnvironmentVariable("Path", $EnvAddPath, [EnvironmentVariableTarget]::Machine)
$([Environment]::GetEnvironmentVariable("Path", [EnvironmentVariableTarget]::Machine)) -split ";"
</code></pre>
<p><code>iperf3 -h</code></p>
<h3 id="iperf-gui"><a class="header" href="#iperf-gui">iPerf-GUI</a></h3>
<p><code>Invoke-RestMethod "https://github.com/Lifailon/iPerf-GUI/raw/rsa/iPerf-GUI-Install.exe" -OutFile "$home\Downloads\iPerf-GUI-Install.exe"</code> скачать установочную версию собранную с помощью WinRAR <br />
<code>Start-Process -FilePath "$home\Downloads\iPerf-GUI-Install.exe" -ArgumentList "/S" -NoNewWindow -Wait</code> установить в тихом режиме</p>
<h3 id="iperf-docker"><a class="header" href="#iperf-docker">iPerf-Docker</a></h3>
<pre><code class="language-PowerShell">echo '
FROM alpine:latest
RUN apk update &amp;&amp; apk add --no-cache iperf3
ENV PORT=5201
EXPOSE $PORT
CMD ["sh", "-c", "iperf3 -s -p $PORT"]
' &gt; Dockerfile
</code></pre>
<p><code>docker build -t iperf3-alpine-server .</code> <br />
<code>docker run -d -p 5201:5201 --name iperf3-alpine-server iperf3-alpine-server</code></p>
<h3 id="server-2"><a class="header" href="#server-2">Server</a></h3>
<p><code>iperf3 -s</code> запуск сервера <br />
<code>iperf3 -s -D</code> запустить сервер в фоновом режиме как службу (--daemon) <br />
<code>Get-NetTCPConnection -State Established,Listen | ? LocalPort -Match 5201</code> проверить, что порт сервера слушает <br />
<code>Get-Process -Id $(Get-NetTCPConnection -State Established,Listen | ? LocalPort -Match 5201).OwningProcess</code> получить процесс по порту <br />
<code>Get-Process iperf3 | Stop-Process</code> остановить процесс <br />
<code>iperf3 -s -D --logfile "$home\Documents\iperf3\iperf3.log"</code> перенаправить вывод в лог файл <br />
<code>iperf3 -s -p 5211</code> указать порт, на котором будет слушать сервер или отправлять запросы клиент <br />
<code>iperf3 -s -p 5211 -f M</code> изменить формат выводимых данных (измерять в байтах а не в битах, доступные значения: K,M,G,T) <br />
<code>iperf3 -s -p 5211 -f M -J</code> вывод в формате json <br />
<code>iperf3 -s -p 5211 -f M -V</code> вывод подробной информации</p>
<h3 id="client-2"><a class="header" href="#client-2">Client</a></h3>
<p><code>iperf3 -c 192.168.3.100 -p 5211</code> подключение к серверу (по умолчанию проверяется отдача на сервер с клиента) <br />
<code>iperf3 -c 192.168.3.100 -p 5211 -R</code> обратный тест, проверка скачивания с сервера (--reverse, сервер отправляет данные клиенту) <br />
<code>iperf3 -c 192.168.3.100 -p 5211 -R -P 2</code> количество одновременных потоков ([SUM] - суммарная скорость нескольки потоков) <br />
<code>iperf3 -c 192.168.3.100 -p 5211 -R -4</code> использовать только IPv4 <br />
<code>iperf3 -c 192.168.3.100 -p 5211 -R -u</code> использовать UDP вместо TCP <br />
<code>iperf3 -c 192.168.3.100 -p 5211 -R -u -b 2mb</code> установить битрейт в 2.00 Mbits/sec для UDP (по умолчанию 1 Мбит/сек, для TCP не ограничено) <br />
<code>iperf3 -c 192.168.3.100 -p 5211 -R -t 30</code> время одного теста в секундах (по умолчанию 10 секунд) <br />
<code>iperf3 -c 192.168.3.100 -p 5211 -R -n 1gb</code> указать объем данных для проверки (применяется вместо времени -t) <br />
<code>iperf3 -c 192.168.3.100 -p 5211 -R --get-server-output</code> вывести вывод сервера на клиенте</p>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<p><code>sender</code> upload (скорость передачи на удаленный сервер) <br />
<code>receiver</code> download (скорость скачивания с удаленного сервера) <br />
<code>Interval</code> общее время сканирования <br />
<code>Transfer</code> кол-во переданных и полученных МБайт <br />
<code>Bandwidth</code> скорость передачи (измеряется в Мбит/c)</p>
<h3 id="ps-iperf"><a class="header" href="#ps-iperf">PS-iPerf</a></h3>
<p><code>Install-Module ps-iperf -Repository NuGet</code> <br />
<code>Import-Module PS-iPerf</code> <br />
<code>Start-iPerfServer -Port 5211</code> запустить сервер <br />
<code>Get-iPerfServer</code> статус работы сервера <br />
<code>Stop-iPerfServer</code> остановить сервер <br />
<code>Connect-iPerfServer -Server 192.168.3.100 -Port 5211 -MBytes 500 -Download</code> подключиться к серверу и скачать 500 МБайт <br />
<code>$SpeedTest = Connect-iPerfServer -Server 192.168.3.100 -Port 5211 -MBytes 500 -LogWrite</code> передать 500 МБайт на сервер (вести запись в лог-файл) <br />
<code>$SpeedTest.Intervals</code> метрики измерений <br />
<code>Get-iPerfLog</code> прочитать лог-файл</p>
<h1 id="rdp"><a class="header" href="#rdp">RDP</a></h1>
<p><code>Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name "PortNumber"</code> отобразить номер текущего RDP порта <br />
<code>Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name "PortNumber" -Value "3390"</code> изменить RDP-порт <br />
<code>$(Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server\" -Name "fDenyTSConnections").fDenyTSConnections</code> если 0, то включен <br />
<code>Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server\" -Name "fDenyTSConnections" -Value 0</code> включить RDP <br />
<code>reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f</code> <br />
<code>(gcim -Class Win32_TerminalServiceSetting -Namespace root\CIMV2\TerminalServices).SetAllowTSConnections(0)</code> включить RDP (для Windows Server) <br />
<code>Get-Service TermService | Restart-Service -Force</code> перезапустить rdp-службу <br />
<code>New-NetFirewallRule -Profile Any -DisplayName "RDP 3390" -Direction Inbound -Protocol TCP -LocalPort 3390</code> открыть RDP-порт</p>
<h3 id="ipban"><a class="header" href="#ipban">IPBan</a></h3>
<p><code>auditpol /get /category:*</code> отобразить все политики аудита <br />
<code>auditpol /get /category:Вход/выход</code> отобразить локальные политики аудита для Входа и Выхода из системы <br />
<code>auditpol /set /subcategory:"Вход в систему" /success:enable /failure:enable</code> включить локальные политики - Аудит входа в систему <br />
<code>auditpol /set /subcategory:"Выход из системы" /success:enable /failure:enable</code></p>
<p><code>$url = $($(Invoke-RestMethod https://api.github.com/repos/DigitalRuby/IPBan/releases/latest).assets | Where-Object name -match ".+win.+x64.+").browser_download_url</code> получить ссылку для загрузки последней версии <br />
<code>$version = $(Invoke-RestMethod https://api.github.com/repos/DigitalRuby/IPBan/releases/latest).tag_name</code> получить номер последней версии <br />
<code>$path = "$home\Documents\ipban-$version"</code> путь для установки <br />
<code>Invoke-RestMethod $url -OutFile "$home\Downloads\IPBan-$version.zip"</code> скачать дистрибутив <br />
<code>Expand-Archive "$home\Downloads\ipban-$version.zip" -DestinationPath $path</code> разархивировать в путь для установки <br />
<code>Remove-Item "$home\Downloads\ipban-$version.zip"</code> удалить дистрибутив <br />
<code>sc create IPBan type=own start=delayed-auto binPath="$path\DigitalRuby.IPBan.exe" DisplayName=IPBan</code> создать службу <br />
<code>Get-Service IPBan</code> статус службы <br />
<code>$conf = $(Get-Content "$path\ipban.config")</code> читаем конфигурацию <br />
<code>$conf = $conf -replace '&lt;add key="Whitelist" value=""/&gt;','&lt;add key="Whitelist" value="192.168.3.0/24"/&gt;'</code> добавить в белый лист домашнюю сеть для исключения <br />
<code>$conf = $conf -replace '&lt;add key="ProcessInternalIPAddresses" value="false"/&gt;','&lt;add key="ProcessInternalIPAddresses" value="true"/&gt;'</code> включить обработку локальных (внутренних) ip-адресов <br />
<code>$conf = $conf -replace '&lt;add key="FailedLoginAttemptsBeforeBanUserNameWhitelist" value="20"/&gt;','&lt;add key="FailedLoginAttemptsBeforeBanUserNameWhitelist" value="5"/&gt;'</code> указать количество попыток подключения до блокировки <br />
<code>$conf = $conf -replace '&lt;add key="ExpireTime" value="01:00:00:00"/&gt;','&lt;add key="ExpireTime" value="00:01:00:00"/&gt;'</code> задать время блокировки 1 час <br />
<code>$conf &gt; "$path\ipban.config"</code> обновить конфигурацию <br />
<code>Get-Service IPBan | Start-Service</code> запустить службу</p>
<pre><code>Get-NetFirewallRule | Where-Object DisplayName -Match "IPBan" | ForEach-Object {
    $Name = $_.DisplayName
    Get-NetFirewallAddressFilter -AssociatedNetFirewallRule $_ | Select-Object @{Name="Name"; Expression={$Name}},LocalIP,RemoteIP
} # отобразить область применения правил Брандмауэра для IPBan
</code></pre>
<p><code>Get-Content -Wait "$path\logfile.txt"</code> читать лог <br />
<code>Get-Service IPBan | Stop-Service</code> остановить службу <br />
<code>sc delete IPBan</code> удалить службу</p>
<h1 id="sockets"><a class="header" href="#sockets">Sockets</a></h1>
<h3 id="udp-socket"><a class="header" href="#udp-socket">UDP-Socket</a></h3>
<p><a href="https://cloudbrothers.info/en/test-udp-connection-powershell/">Source</a></p>
<pre><code class="language-PowerShell">function Start-UDPServer {
    param(
        $Port = 5201
    )
    $RemoteComputer = New-Object System.Net.IPEndPoint([System.Net.IPAddress]::Any, 0)
    do {
        $UdpObject = New-Object System.Net.Sockets.UdpClient($Port)
        $ReceiveBytes = $UdpObject.Receive([ref]$RemoteComputer)
        $UdpObject.Close()
        $ASCIIEncoding = New-Object System.Text.ASCIIEncoding
        [string]$ReturnString = $ASCIIEncoding.GetString($ReceiveBytes)
        [PSCustomObject]@{
            LocalDateTime = $(Get-Date -UFormat "%Y-%m-%d %T")
            ClientIP      = $RemoteComputer.address.ToString()
            ClientPort    = $RemoteComputer.Port.ToString()
            Message       = $ReturnString
        }
    } while (1)
}
</code></pre>
<p><code>Start-UDPServer -Port 5201</code></p>
<h3 id="test-netudpconnection"><a class="header" href="#test-netudpconnection">Test-NetUDPConnection</a></h3>
<pre><code class="language-PowerShell">function Test-NetUDPConnection {
    param(
        [string]$ComputerName = "127.0.0.1",
        [int32]$PortServer = 5201,
        [int32]$PortClient = 5211,
        $Message
    )
    begin {
        $UdpObject = New-Object system.Net.Sockets.Udpclient($PortClient)
        $UdpObject.Connect($ComputerName, $PortServer)
    }
    process {
        $ASCIIEncoding = New-Object System.Text.ASCIIEncoding
        if (!$Message) { $Message = Get-Date -UFormat "%Y-%m-%d %T" }
        $Bytes = $ASCIIEncoding.GetBytes($Message)
        [void]$UdpObject.Send($Bytes, $Bytes.length)
    }
    end {
        $UdpObject.Close()
    }
}
</code></pre>
<p><code>Test-NetUDPConnection -ComputerName 127.0.0.1 -PortServer 5201</code> <br />
<code>Test-NetUDPConnection -ComputerName 127.0.0.1 -PortServer 514 -Message "&lt;30&gt;May 31 00:00:00 HostName multipathd[784]: Test message"</code></p>
<h3 id="tcp-socket"><a class="header" href="#tcp-socket">TCP-Socket</a></h3>
<pre><code class="language-PowerShell">function Start-TCPServer {
    param(
        $Port = 5201
    )
    do {
        $TcpObject = New-Object System.Net.Sockets.TcpListener($port)
        $ReceiveBytes = $TcpObject.Start()
        $ReceiveBytes = $TcpObject.AcceptTcpClient()
        $TcpObject.Stop()
        $ReceiveBytes.Client.RemoteEndPoint | select Address, Port
    } while (1)
}
</code></pre>
<p><code>Start-TCPServer -Port 5201</code> <br />
<code>Test-NetConnection -ComputerName 127.0.0.1 -Port 5201</code></p>
<h3 id="wakeonlan"><a class="header" href="#wakeonlan">WakeOnLan</a></h3>
<p>Broadcast package consisting of 6 byte filled "0xFF" and then 96 byte where the mac address is repeated 16 times</p>
<pre><code class="language-PowerShell">function Send-WOL {
    param (
        [Parameter(Mandatory = $True)]$Mac,
        $IP,
        [int]$Port = 9
    )
    $Mac = $Mac.replace(":", "-")
    if (!$IP) { $IP = [System.Net.IPAddress]::Broadcast }
    $SynchronizationChain = [byte[]](, 0xFF * 6)
    $ByteMac = $Mac.Split("-") | % { [byte]("0x" + $_) }
    $Package = $SynchronizationChain + ($ByteMac * 16)
    $UdpClient = New-Object System.Net.Sockets.UdpClient
    $UdpClient.Connect($IP, $port)
    $UdpClient.Send($Package, $Package.Length)
    $UdpClient.Close()
}
</code></pre>
<p><code>Send-WOL -Mac "D8-BB-C1-70-A3-4E"</code> <br />
<code>Send-WOL -Mac "D8-BB-C1-70-A3-4E" -IP 192.168.3.100</code></p>
<h3 id="httplistener"><a class="header" href="#httplistener">HTTPListener</a></h3>
<pre><code class="language-PowerShell">$httpListener = New-Object System.Net.HttpListener
$httpListener.Prefixes.Add("http://+:8888/")
$httpListener.Start()
while (!([console]::KeyAvailable)) {
    $info = Get-Service | select name, status | ConvertTo-HTML
    $context = $httpListener.GetContext()
    $context.Response.StatusCode = 200
    $context.Response.ContentType = 'text/HTML'
    $WebContent = $info
    $EncodingWebContent = [Text.Encoding]::UTF8.GetBytes($WebContent)
    $context.Response.OutputStream.Write($EncodingWebContent , 0, $EncodingWebContent.Length)
    $context.Response.Close()
    Get-NetTcpConnection -LocalPort 8888
(Get-Date).datetime
}
$httpListener.Close()
</code></pre>
<h3 id="webclient"><a class="header" href="#webclient">WebClient</a></h3>
<p><code>[System.Net.WebClient] | Get-Member</code> <br />
<code>(New-Object Net.WebClient).DownloadString("https://raw.githubusercontent.com/Lifailon/PowerShell-Commands/rsa/README.md")</code></p>
<h3 id="httpclient"><a class="header" href="#httpclient">HttpClient</a></h3>
<pre><code class="language-PowerShell">$url = "https://github.com/PowerShell/PowerShell/releases/download/v7.4.2/PowerShell-7.4.2-win-x64.zip"
$path = "$home\Downloads\$(Split-Path -Path $url -Leaf)"
$httpClient = [System.Net.Http.HttpClient]::new()
# Выполнение GET-запроса для загрузки файла (считывая заголовки ответа)
$response = $httpClient.GetAsync($url, [System.Net.Http.HttpCompletionOption]::ResponseHeadersRead).Result
# Получение потока содержимого из заголовка ответа
$stream = $response.Content.ReadAsStreamAsync().Result
# Открытие файла для записи
$fileStream = [System.IO.File]::OpenWrite($path)
try {
    # Создание буфера размером 81920 байт (80 КБ) для чтения данных из потока
    $buffer = New-Object byte[] 81920
    # Чтение данных из потока и запись их в файл
    while (($bytesRead = $stream.Read($buffer, 0, $buffer.Length)) -ne 0) {
        $fileStream.Write($buffer, 0, $bytesRead)
    }
}
finally {
    # Освобождение ресурсов, связанных с потоками
    $stream.Dispose()
    $fileStream.Dispose()
}
</code></pre>
<h3 id="certificate"><a class="header" href="#certificate">Certificate</a></h3>
<pre><code class="language-PowerShell">function Get-WebCertificate ($srv) {
    $iwr = iwr $srv
    $status_code = $iwr.StatusCode
    $status = $iwr.BaseResponse.StatusCode
    $info = $iwr.BaseResponse.Server
    $spm = [System.Net.ServicePointManager]::FindServicePoint($srv)
    $date_end = $spm.Certificate.GetExpirationDateString()
    $cert_name = ($spm.Certificate.Subject) -replace "CN="
    $cert_owner = ((($spm.Certificate.Issuer) -split ", ") | where { $_ -match "O=" }) -replace "O="
    $Collections = New-Object System.Collections.Generic.List[System.Object]
    $Collections.Add([PSCustomObject]@{
            Host        = $srv;
            Server      = $info;
            Status      = $status;
            StatusCode  = $status_code;
            Certificate = $cert_name;
            Issued      = $cert_owner;
            End         = $date_end
        })
    $Collections
}
</code></pre>
<p><code>Get-WebCertificate https://google.com</code></p>
<h1 id="smtp"><a class="header" href="#smtp">SMTP</a></h1>
<h3 id="netmail"><a class="header" href="#netmail">Net.Mail</a></h3>
<pre><code class="language-PowerShell">function Send-SMTP {
param (
    [Parameter(Mandatory = $True)]$mess
)
    $srv_smtp = "smtp.yandex.ru" 
    $port = "587"
    $from = "login1@yandex.ru" 
    $to = "login2@yandex.ru" 
    $user = "login1"
    $pass = "password"
    $subject = "PowerShell"
    $Message = New-Object System.Net.Mail.MailMessage
    $Message.From = $from
    $Message.To.Add($to) 
    $Message.Subject = $subject 
    $Message.IsBodyHTML = $true 
    $Message.Body = "&lt;h1&gt; $mess &lt;/h1&gt;"
    $smtp = New-Object Net.Mail.SmtpClient($srv_smtp, $port)
    $smtp.EnableSSL = $true 
    $smtp.Credentials = New-Object System.Net.NetworkCredential($user, $pass);
    $smtp.Send($Message) 
}
</code></pre>
<p><code>Send-SMTP "This is a test email from PowerShell"</code></p>
<h3 id="smtp-over-openssl"><a class="header" href="#smtp-over-openssl">SMTP over OpenSSL</a></h3>
<pre><code class="language-Bash"># Получить логин и пароль в формате Base64
echo -n "fromUserName@yandex.ru" | base64 # ZnJvbVVzZXJOYW1lQHlhbmRleC5ydQ==
echo -n "app-password" | base64 # YXBwLXBhc3N3b3Jk
# Подключаемся к серверу через OpenSSL и авторизуемся
openssl s_client -connect smtp.yandex.ru:465 -crlf -quiet
# 220 Ok
EHLO hv-dev-101
AUTH LOGIN
ZnJvbVVzZXJOYW1lQHlhbmRleC5ydQ==
YXBwLXBhc3N3b3Jk
# 235 Authentication successful
# Отправляем письмо
MAIL FROM:&lt;fromUserName@yandex.ru&gt;
RCPT TO:&lt;toUserName@yandex.ru&gt;
DATA
Subject: OpenSSL
# Отделить тему от тела письма пустой строкой
This is a test email from OpenSSL
.
# 250 Ok
</code></pre>
<h3 id="swaks"><a class="header" href="#swaks">Swaks</a></h3>
<p><a href="https://github.com/jetmore/swaks">Swaks</a> - SMTP клиент на Perl</p>
<pre><code class="language-bash">swaks --from fromUserName@yandex.ru \
    --to toUserName@yandex.ru \
    --server smtp.yandex.ru \
    --port 587 \
    --auth LOGIN \
    --auth-user fromUserName@yandex.ru \
    --auth-password "app-password" \
    --tls \
    --header "Subject: Test Subject" \
    --body "This is the body test from swaks"
</code></pre>
<h1 id="route"><a class="header" href="#route">Route</a></h1>
<p><code>Get-Service RemoteAccess | Stop-Service</code> <br />
<code>Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters" -Name "IPEnableRouter" -Value 1</code> включает IP маршрутизацию <br />
<code>(Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters").IPEnableRouter</code> <br />
<code>Get-NetIPInterface | select ifIndex,InterfaceAlias,AddressFamily,ConnectionState,Forwarding | ft</code> отобразить сетевые интерфейсы <br />
<code>Set-NetIPInterface -ifIndex 13 -Forwarding Enabled</code> включить переадресацию на интерфейсе</p>
<p><code>sysctl net.ipv4.ip_forward=1</code> <br />
<code>echo "sysctl net.ipv4.ip_forward = 1" &gt;&gt; /etc/sysctl.conf</code></p>
<p><code>Get-NetRoute</code> <br />
<code>New-NetRoute -DestinationPrefix "192.168.3.0/24" -NextHop "192.168.4.1" -InterfaceIndex 8</code> <br />
<code>route -p add 192.168.3.0 mask 255.255.255.0 192.168.4.1 metric 1</code> <br />
<code>route -p change 192.168.3.0 mask 255.255.255.0 192.168.4.1 metric 2</code> <br />
<code>route -p add 192.168.3.0 mask 255.255.255.0 192.168.4.1 metric 1 if 7</code> указать номер сетевого интерфейса на который необходимо посылать пакет (Wintun Userspace Tunnel) <br />
<code>route print -4</code> <br />
<code>route delete 192.168.3.0</code></p>
<p><code>tracert 192.168.3.101</code> с 192.168.4.6</p>
<pre><code>1    17 ms     *       22 ms  192.168.4.1
2    12 ms    13 ms    14 ms  192.168.3.101
</code></pre>
<p><code>route add -net 192.168.4.0 netmask 255.255.255.0 gw 192.168.3.100</code> <br />
<code>route -e</code></p>
<p><code>traceroute 192.168.4.6</code> с 192.168.3.101</p>
<pre><code>1  192.168.3.100 (192.168.3.100)  0.148 ms  0.110 ms  0.106 ms
2  192.168.4.6 (192.168.4.6)  14.573 ms * *
</code></pre>
<p><code>ping 192.168.3.101 -t</code> с 192.168.4.6 <br />
<code>tcpdump -n -i ens33 icmp</code> на 192.168.3.101</p>
<pre><code>14:36:34.533771 IP 192.168.4.6 &gt; 192.168.3.101: ICMP echo request, id 1, seq 2962, length 40 # отправил запрос
14:36:34.533806 IP 192.168.3.101 &gt; 192.168.4.6: ICMP echo reply, id 1, seq 2962, length 40 # отправил ответ
</code></pre>
<h1 id="nat"><a class="header" href="#nat">NAT</a></h1>
<p><code>Get-Command -Module NetNat</code> <br />
<code>New-NetNat -Name LocalNat -InternalIPInterfaceAddressPrefix "192.168.3.0/24"</code> <br />
<code>Add-NetNatStaticMapping -NatName LocalNat -Protocol TCP -ExternalIPAddress 0.0.0.0 -ExternalPort 80 -InternalIPAddress 192.168.3.102 -InternalPort 80</code> <br />
<code>Remove-NetNatStaticMapping -StaticMappingID 0</code> <br />
<code>Remove-NetNat -Name LocalNat</code></p>
<h1 id="wireguard"><a class="header" href="#wireguard">WireGuard</a></h1>
<p><code>Invoke-WebRequest "https://download.wireguard.com/windows-client/wireguard-amd64-0.5.3.msi" -OutFile "$home\Downloads\WireGuard-Client-0.5.3.msi"</code> <br />
<code>msiexec.exe /i "$home\Downloads\WireGuard-Client-0.5.3.msi" DO_NOT_LAUNCH=1 /qn</code> <br />
<code>Invoke-WebRequest "http://www.wiresock.net/downloads/wiresock-vpn-gateway-x64-1.1.4.1.msi" -OutFile "$home\Downloads\WireSock-VPN-Gateway-1.1.4.1.msi"</code> <br />
<code>msiexec.exe /i "http://www.wiresock.net/downloads/wiresock-vpn-gateway-x64-1.1.4.1.msi" /qn</code> <br />
<code>$env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")</code> <br />
<code>wg-quick-config -add -start</code> <br />
<code>26.115.154.67:8181</code> <br />
<code>192.168.21.4/24</code> <br />
<code>Successfully saved client configuration: C:\ProgramData\NT KERNEL\WireSock VPN Gateway\wsclient_1.conf</code> <br />
<code>Successfully saved server configuration: C:\ProgramData\NT KERNEL\WireSock VPN Gateway\wiresock.conf</code> <br />
<code>get-service *wire*</code> <br />
<code>wg show</code> <br />
<code>wg-quick-config -add -restart</code> add client</p>
<p>wiresock.conf</p>
<pre><code>[Interface]
PrivateKey = gCHC0g2JPwr6sXPiaOL4/KTkMyjN9TculrJUA/GORV8=
Address = 192.168.21.5/24
ListenPort = 8181

[Peer]
PublicKey = NoSxjew2RCHiUzI6mlahjd4I+0EcLsoYom/H01z91yU=
AllowedIPs = 192.168.21.6/32
</code></pre>
<p>wsclient_1.conf (добавить маршруты для клиента в AllowedIPs)</p>
<pre><code>[Interface]
PrivateKey = yIpRQRmaGrrk9Y+49E8JhEpFmKzSeecvUAdeNgf1hUM=
Address = 192.168.21.6/24
DNS = 8.8.8.8, 1.1.1.1
MTU = 1420

[Peer]
PublicKey = Fp7674VSYeGj8CYt6RCKR7Qz1y/IKUXCw8ImOFhX3hk=
AllowedIPs = 192.168.21.0/24, 192.168.3.0/24
Endpoint = 26.115.154.67:8181
PersistentKeepalive = 25
</code></pre>
<h1 id="vpnclient"><a class="header" href="#vpnclient">VpnClient</a></h1>
<p><code>Get-Command -Module VpnClient</code> <br />
<code>Add-VpnConnection -Name "vpn-failon" -ServerAddress "26.115.154.67" -TunnelType L2TP -L2tpPsk "123098" -EncryptionLevel "Required" -AuthenticationMethod MSChapv2 -RememberCredential -AllUserConnection –PassThru -Force</code> <br />
<code>-TunnelType PPTP/L2TP/SSTP/IKEv2/Automatic</code> <br />
<code>-L2tpPsk</code> использовать общий ключ для аутентификации (без параметра, для L2TP аутентификации используется сертификат) <br />
<code>-AuthenticationMethod Pap/Chap/MSChapv2/Eap/MachineCertificate</code> <br />
<code>-EncryptionLevel NoEncryption/Optional/Required/Maximum/Custom</code> <br />
<code>-SplitTunneling</code> заворачивать весь трафик через VPN-туннель (включение Use default gateway on remote network в настройках параметра VPN адаптера) <br />
<code>-UseWinlogonCredential</code> использовать учетные данные текущего пользователя для аутентификации на VPN сервере <br />
<code>-RememberCredential</code> разрешить сохранять учетные данные для VPN подключения (учетная запись и пароль сохраняются в диспетчер учетных данных Windows после первого успешного подключения) <br />
<code>-DnsSuffix domain.local</code> <br />
<code>-AllUserConnection</code> разрешить использовать VPN подключение для всех пользователей компьютера (сохраняется в конфигурационный файл: C:\ProgramData\Microsoft\Network\Connections\Pbk\rasphone.pbk)</p>
<p><code>Install-Module -Name VPNCredentialsHelper</code> модуль для сохранения логина и пароля в Windows Credential Manager для VPN подключения <br />
<code>Set-VpnConnectionUsernamePassword -connectionname vpn-failon -username user1 -password password</code></p>
<p><code>rasdial "vpn-failon"</code> подключиться <br />
<code>Get-VpnConnection -AllUserConnection | select *</code> список VPN подключения, доступных для всех пользователей, найстройки и текущий статус подключения (ConnectionStatus) <br />
<code>Add-VpnConnectionRoute -ConnectionName vpn-failon -DestinationPrefix 192.168.3.0/24 –PassThru</code> динамически добавить в таблицу маршрутизации маршрут, который будет активен при подключении к VPN <br />
<code>Remove-VpnConnection -Name vpn-failon -AllUserConnection -Force</code> удалить</p>
<p><code>Set-VpnConnection -Name "vpn-failon" -SplitTunneling $True</code> включить раздельное тунеллирование <br />
<code>Add-VpnConnectionRoute -ConnectionName "vpn-failon" -DestinationPrefix 172.22.22.0/24</code> настроить маршрутизацию к указанной подсети через VPN-соединение <br />
<code>(Get-VpnConnection -ConnectionName "vpn-failon").routes</code> отобразить таблицу маршрутизации для указанного соединения <br />
<code>Remove-VpnConnectionRoute -ConnectionName "vpn-failon" -DestinationPrefix "172.22.23.0/24"</code></p>
<h1 id="proxyclient"><a class="header" href="#proxyclient">ProxyClient</a></h1>
<p><code>$user = "lifailon"</code> <br />
<code>$pass = "Proxy"</code> <br />
<code>$SecureString = ConvertTo-SecureString $pass -AsPlainText -Force</code> <br />
<code>$Credential = New-Object System.Management.Automation.PSCredential($user, $SecureString)</code> <br />
<code>[System.Net.Http.HttpClient]::DefaultProxy = New-Object System.Net.WebProxy("http://192.168.3.100:9090")</code> <br />
<code>[System.Net.Http.HttpClient]::DefaultProxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials</code> <br />
<code>[System.Net.Http.HttpClient]::DefaultProxy.Credentials = $Credential</code> <br />
<code>Invoke-RestMethod http://ifconfig.me/ip</code> узнать внешний ip-адрес (по умолчанию в текущей сессии подключения будут происходить через заданный прокси сервер) <br />
<code>Invoke-RestMethod https://kinozal.tv/rss.xml</code></p>
<h1 id="netsh"><a class="header" href="#netsh">netsh</a></h1>
<h3 id="reverse-proxy"><a class="header" href="#reverse-proxy">Reverse Proxy</a></h3>
<p><code>netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=192.168.3.108</code> настраивает входящее подключение на 8080 порту и переадресует трафик на 80 порт указанного хоста <br />
<code>netsh interface portproxy show all</code> отобразить список всех настроек <br />
<code>netsh interface portproxy delete v4tov4 listenport=8080 listenaddress=0.0.0.0</code> удалить переадресацию</p>
<h3 id="wlan"><a class="header" href="#wlan">Wlan</a></h3>
<p><code>netsh wlan show profile</code> список сохраненны профилей Wi-Fi и паролей <br />
<code>netsh wlan show interfaces</code> хар-ки текущей сети (MAC, speed) <br />
<code>netsh wlan show profile SSID-Name-Network key=clear</code> очистить пароль <br />
<code>netsh wlan show networks</code> список видемых сетей <br />
<code>netsh wlan disconnect</code> отключиться от Wi-Fi <br />
<code>netsh wlan connect name="SSID-Name-Network"</code> подключиться <br />
<code>netsh wlan show drivers</code> драйвер Wi-Fi <br />
<code>netsh wlan set hostednetwork mode=allow ssid="WiFi-Test" key="password"</code> создание точки доступа Wi-Fi (SoftAP)</p>
<h3 id="firewall-2"><a class="header" href="#firewall-2">Firewall</a></h3>
<p><code>netsh advfirewall set allprofiles state off</code> отключить fw <br />
<code>netsh advfirewall reset</code> сбросить настройки <br />
<code>netsh advfirewall firewall add rule name="Open Remote Desktop" protocol=TCP dir=in localport=3389 action=allow</code> открыть порт 3389 <br />
<code>netsh advfirewall firewall add rule name="All ICMP V4" dir=in action=allow protocol=icmpv4</code> открыть icmp</p>
<h1 id="pki"><a class="header" href="#pki">pki</a></h1>
<p><code>New-SelfSignedCertificate -CertStoreLocation Cert:\LocalMachine\My -DnsName "$env:computername" -FriendlyName "Test Certificate" -NotAfter (Get-Date).AddYears(5)</code> создать самоподписанный сертификат (в LocalMachine\My - Сертификаты компьютера\Личное) с сроком действия 5 лет</p>
<p><code>Get-ChildItem -Path Cert:\CurrentUser\Root\</code> список всех установленных сертификатов в хранилище Доверенные корневые ЦС Текущего пользователя <br />
<code>Get-ChildItem -Path Cert:\CurrentUser\My\</code> список самозаверяющих сертификатов в Личное хранилище Текущего пользователя <br />
<code>Get-ChildItem -Path Cert:\LocalMachine\My\</code> список самозаверяющих сертификатов в Личное хранилище Локального компьютера <br />
<code>Get-ChildItem -Path Cert:\LocalMachine\My\ | select NotBefore,NotAfter,Thumbprint,Subject</code> срок действия сертификата <br />
<code>Get-ChildItem -Path Cert:\LocalMachine\My\ | where Thumbprint -eq D9356FB774EE0E6206B7D5B59B99102CA5B17BDA</code> поиск сертификат по отпечатку</p>
<p><code>Get-ChildItem -Path $env:APPDATA\Microsoft\SystemCertificates\My\Certificates\</code> сертификаты в файловой системе, каждый файл соответствует сертификату, установленному в личном хранилище текущего пользователя <br />
<code>Get-ChildItem -Path $env:APPDATA\Microsoft\SystemCertificates\My\Keys\</code> ссылки на объекты закрытых ключей, созданных поставщиком хранилища ключей (KSP) <br />
<code>Get-ChildItem -Path HKCU:\Software\Microsoft\SystemCertificates\CA\Certificates | ft -AutoSize</code> список сертификатов в реестре вошедшего в систему пользователя</p>
<p><code>$cert = (Get-ChildItem -Path Cert:\CurrentUser\My\)[1]</code> выбрать сертификат <br />
<code>$cert | Remove-Item</code> удалить сертификат</p>
<p><code>Export-Certificate -FilePath $home\Desktop\certificate.cer -Cert $cert</code> экспортировать сертификат <br />
<code>$cert.HasPrivateKey</code> проверить наличие закрытого ключа <br />
<code>$pass = "password" | ConvertTo-SecureString -AsPlainText -Force</code> создать пароль для шифрования закрытого ключа <br />
<code>Export-PfxCertificate -FilePath $home\Desktop\certificate.pfx -Password $pass -Cert $certificate</code> экспортировать сертификат с закрытым ключем</p>
<p><code>Import-Certificate -FilePath $home\Desktop\certificate.cer -CertStoreLocation Cert:\CurrentUser\My</code> импортировать сертификат <br />
<code>Import-PfxCertificate -Exportable -Password $pass -CertStoreLocation Cert:\CurrentUser\My -FilePath $home\Desktop\certificate.pfx</code></p>
<h1 id="openssl"><a class="header" href="#openssl">OpenSSL</a></h1>
<pre><code class="language-PowerShell">Invoke-WebRequest -Uri https://slproweb.com/download/Win64OpenSSL_Light-3_1_1.msi -OutFile $home\Downloads\OpenSSL-Light-3.1.1.msi
Start-Process $home\Downloads\OpenSSL-Light-3.1.1.msi -ArgumentList '/quiet' -Wait` установить msi пакет в тихом режиме (запуск от имени Администратора)
rm $home\Downloads\OpenSSL-Light-3.1.1.msi
cd "C:\Program Files\OpenSSL-Win64\bin"
</code></pre>
<ul>
<li>
<p>Изменить пароль для PFX <br />
<code>openssl pkcs12 -in "C:\Cert\domain.ru.pfx" -out "C:\Cert\domain.ru.pem" -nodes</code> экспортируем имеющийся сертификат и закрытый ключ в .pem-файл без пароля с указанием текущего пароля <br />
<code>openssl pkcs12 -export -in "C:\Cert\domain.ru.pem" -out "C:\Cert\domain.ru_password.pfx" -nodes</code> конвертируем .pem обратно в .pfx c указанием нового пароля</p>
</li>
<li>
<p>Конвертация из закрытого и открытого ключа PEM в PFX <br />
<code>openssl pkcs12 -export -in "C:\tmp\vpn\vpn.itproblog.ru-crt.pem" -inkey "C:\tmp\vpn\vpn.itproblog.ru-key.pem" -out "C:\tmp\vpn\vpn.iiproblog.ru.pfx"</code> <br />
in – путь до файла с открытым ключом <br />
inkey – путь до файла с закрытым ключом <br />
out – путь до файла, в который будет конвертирован сертификат (pfx)</p>
</li>
<li>
<p>Конвертация PFX в CRT <br />
<code>openssl pkcs12 -in "C:\OpenSSL-Win64\bin\_.domain.ru.pfx" -clcerts -out "C:\OpenSSL-Win64\bin\_.domain.ru.crt"</code> указывается текущий и 2 раза новый пароль PEM pass phrase (файл содержит EGIN CERTIFICATE и BEGIN ENCRYPTED PRIVATE KEY) <br />
<code>openssl pkcs12 -in "C:\OpenSSL-Win64\bin\_.domain.ru.pfx" -clcerts -nokeys -out "C:\OpenSSL-Win64\bin\_.domain.ru.crt"</code> без ключа, получить открытую часть (файл содержит только EGIN CERTIFICATE)</p>
</li>
<li>
<p>Конвертация PFX в KEY <br />
<code>openssl pkcs12 -in "C:\OpenSSL-Win64\bin\_.domain.ru.pfx" -nocerts -out "C:\OpenSSL-Win64\bin\_.domain.ru.key"</code> файл содержит только BEGIN ENCRYPTED PRIVATE KEY</p>
</li>
<li>
<p>Снять пароль к закрытого ключа .key <br />
<code>openssl rsa -in "C:\OpenSSL-Win64\bin\_.domain.ru.key" -out "C:\OpenSSL-Win64\bin\_.domain.ru-decrypted.key"</code></p>
</li>
<li>
<p>CRT и KEY в PFX: <br />
<code>openssl pkcs12 -inkey certificate.key -in certificate.crt -export -out certificate.pfx</code></p>
</li>
</ul>
<h1 id="openvpn"><a class="header" href="#openvpn">OpenVPN</a></h1>
<p><code>Invoke-WebRequest -Uri https://swupdate.openvpn.org/community/releases/OpenVPN-2.6.5-I001-amd64.msi -OutFile $home\Downloads\OpenVPN-2.6.5.msi</code> <br />
<code>Start-Process $home\Downloads\OpenVPN-2.6.5.msi -ArgumentList '/quiet /SELECT_OPENSSL_UTILITIES=1' -Wait</code> <br />
<code>msiexec /i $home\Downloads\OpenVPN-2.6.5.msi ADDLOCAL=EasyRSA /passive /quiet # установить отдельный компонент EasyRSA Certificate Management Scripts</code> <br />
<code># msiexec /i $home\Downloads\OpenVPN-2.6.5.msi ADDLOCAL=OpenVPN.Service,Drivers,Drivers.Wintun,OpenVPN,OpenVPN.GUI,OpenVPN.GUI.OnLogon,EasyRSA /passive</code> выборочная установка <br />
<code># Invoke-WebRequest -Uri https://github.com/OpenVPN/easy-rsa/releases/download/v3.1.5/EasyRSA-3.1.5-win64.zip -OutFile $home\Downloads\EasyRSA-3.1.5.zip</code> скачать отдельный пакет EasyRSA <br />
<code>rm $home\Downloads\OpenVPN-2.6.5.msi</code></p>
<p><code>cd "C:\Program Files\OpenVPN\easy-rsa"</code> <br />
<code>Copy-Item vars.example vars</code> файл конфигурации для EasyRSA</p>
<pre><code>set_var EASYRSA_TEMP_DIR "$EASYRSA_PKI"
set_var EASYRSA_REQ_COUNTRY "RU"
set_var EASYRSA_REQ_PROVINCE "MSK"
set_var EASYRSA_REQ_CITY "MSK"
set_var EASYRSA_REQ_ORG "FAILON.NET"
set_var EASYRSA_REQ_EMAIL "lifailon@domain.ru"
set_var EASYRSA_REQ_OU "IT"
#set_var EASYRSA_KEY_SIZE 2048
#set_var EASYRSA_CA_EXPIRE 3650
#set_var EASYRSA_CERT_EXPIRE 825
</code></pre>
<p><code>.\EasyRSA-Start.bat</code> среда EasyRSA Shell <br />
<code>easyrsa init-pki</code> инициализация PKI, создает директорию: C:\Program Files\OpenVPN\easy-rsa\pki и читает переменные файла \easy-rsa\vars <br />
<code>easyrsa build-ca</code> генерация корневого CA с указанием пароля и произвольное имя сервера (\pki\ca.crt и \pki\private\ca.key) <br />
<code>easyrsa gen-req server nopass</code> генерация запроса сертификата и ключ для сервера OpenVPN - yes (\pki\reqs\server.req и \pki\private\server.key) <br />
<code>easyrsa sign-req server server</code> подписать запрос на выпуск сертификата сервера с помощью CA - yes (\pki\issued\server.crt) <br />
<code>easyrsa gen-dh</code> создать ключ Диффи-Хеллмана (\pki\dh.pem) <br />
<code>easyrsa gen-req client1</code> nopass<code> генерация запроса сертификата и ключ для клиента OpenVPN (\pki\reqs\client1.req и \pki\private\client1.key)</code> <br />
<code>easyrsa sign-req client client1</code> подписать запрос на выпуск сертификата клиента с помощью CA - yes (\pki\issued\client1.crt) <br />
<code>easyrsa revoke client1</code> отозвать сертификат пользователя <br />
<code>openssl rsa -in "C:\Program Files\OpenVPN\easy-rsa\pki\private\client1.key" -out "C:\Program Files\OpenVPN\easy-rsa\pki\private\client1_nopass.key"</code> снять защиту паролем для ключа (BEGIN ENCRYPTED PRIVATE KEY -&gt; BEGIN PRIVATE KEY) <br />
<code>exit</code> <br />
<code>cd "C:\Program Files\OpenVPN\bin"</code> <br />
<code>.\openvpn --genkey secret ta.key</code> генерация ключа tls-auth (\bin\ta.key) <br />
<code>Move-Item "C:\Program Files\OpenVPN\bin\ta.key" "C:\Program Files\OpenVPN\easy-rsa\pki\"</code></p>
<h3 id="server-ovpn"><a class="header" href="#server-ovpn">server ovpn</a></h3>
<p><code># Copy-Item "C:\Program Files\OpenVPN\sample-config\server.ovpn" "C:\Program Files\OpenVPN\config-auto\server.ovpn"</code> <br />
<code>New-Item -ItemType File -Path "C:\Program Files\OpenVPN\config-auto\server.ovpn"</code></p>
<pre><code>port 1194
proto udp
# Что именно инкапсулировать в туннеле (ethernet фреймы - tap или ip пакеты - tun)
dev tun
ca "C:\\Program Files\\OpenVPN\\easy-rsa\\pki\\ca.crt"
cert "C:\\Program Files\\OpenVPN\\easy-rsa\\pki\\issued\\server.crt"
key "C:\\Program Files\\OpenVPN\\easy-rsa\\pki\\private\\server.key"
dh "C:\\Program Files\\OpenVPN\\easy-rsa\\pki\\dh.pem"
server 192.168.4.0 255.255.255.0
# Хранит список сопоставления ip для клиентов, что бы назначить тот же адрес при перезапуске сервера
# ifconfig-pool-persist "C:\\Program Files\\OpenVPN\\dhcp-client-list.txt"
# Разрешить клиентам подключаться под одним ключом
# duplicate-cn
# max-clients 30
# Разрешить обмен трафиком между клиентами
client-to-client
# compress
tls-auth "C:\\Program Files\\OpenVPN\\easy-rsa\\pki\\ta.key" 0
cipher AES-256-GCM
keepalive 20 60
# Не перечитавать файлы ключей при перезапуске туннеля
persist-key
# Оставляет без изменения устройства tun/tap при перезапуске OpenVPN
persist-tun
status "C:\\Program Files\\OpenVPN\\log\\status.log"
log "C:\\Program Files\\OpenVPN\\log\\openvpn.log"
verb 3
mute 20
windows-driver wintun
# Открыть доступ к подсети за сервером
push "route 192.168.3.0 255.255.255.0"
push "route 192.168.4.0 255.255.255.0"
# Завернуть все запросы клиента (в том числе Интернет трафик) на OpenVPN сервер
# push "redirect-gateway def1"
# push "dhcp-option DNS 192.168.3.101"
# push "dhcp-option DOMAIN failon.net"
</code></pre>
<p><code>New-NetFirewallRule -DisplayName "AllowOpenVPN-In" -Direction Inbound -Protocol UDP –LocalPort 1194 -Action Allow</code> на сервере <br />
<code>New-NetFirewallRule -DisplayName "AllowOpenVPN-Out" -Direction Outbound -Protocol UDP –LocalPort 1194 -Action Allow</code> на клиенте <br />
<code>Get-Service *openvpn* | Restart-Service</code></p>
<h3 id="client-ovpn"><a class="header" href="#client-ovpn">client ovpn</a></h3>
<p><code># Copy-Item "C:\Program Files\OpenVPN\sample-config\client.ovpn" "C:\Program Files\OpenVPN\config-auto\client.ovpn"</code> <br />
<code>New-Item -ItemType File -Path "C:\Program Files\OpenVPN\config-auto\client.ovpn"</code></p>
<pre><code>client
dev tun
proto udp
remote 26.115.154.67 1194
resolv-retry infinite
nobind
persist-key
persist-tun
ca ca.crt
cert client1.crt
key client1.key
remote-cert-tls server
tls-auth ta.key 1
cipher AES-256-GCM
connect-retry-max 25
# Использовать драйвер wintun и полный путь до сертификатов при использовании openvpn gui
windows-driver wintun
verb 3
</code></pre>
<h3 id="client-3"><a class="header" href="#client-3">Client</a></h3>
<p><code>iwr -Uri https://openvpn.net/downloads/openvpn-connect-v3-windows.msi -OutFile "$home\downloads\OpenVPN-Connect-3.msi"</code> <br />
Передать конфигурацию и ключи: <br />
<code>client.ovpn</code> <br />
<code>ca.crt</code> <br />
<code>dh.pem</code> <br />
<code>ta.key</code> <br />
<code>client1.crt</code> <br />
<code>client1.key</code></p>
<h1 id="openssh"><a class="header" href="#openssh">OpenSSH</a></h1>
<p><code>Get-WindowsCapability -Online | ? Name -like 'OpenSSH.Client*'</code> <br />
<code>Add-WindowsCapability -Online -Name OpenSSH.Client*</code> <br />
<code>dism /Online /Add-Capability /CapabilityName:OpenSSH.Client~~~~0.0.1.0</code> <br />
<code>iwr https://github.com/PowerShell/Win32-OpenSSH/releases/download/v9.2.2.0p1-Beta/OpenSSH-Win64-v9.2.2.0.msi -OutFile $home\Downloads\OpenSSH-Win64-v9.2.2.0.msi</code> скачать <br />
<code>msiexec /i $home\Downloads\OpenSSH-Win64-v9.2.2.0.msi</code> установить msi пакет <br />
<code>Set-Service sshd -StartupType Automatic</code> <br />
<code>Get-NetTCPConnection | where LocalPort -eq 22</code> <br />
<code>New-NetFirewallRule -Name sshd -DisplayName 'OpenSSH Server (sshd)' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22</code> <br />
<code>Get-NetFirewallRule -Name *ssh*</code> <br />
<code>Start-Process notepad++ C:\Programdata\ssh\sshd_config</code> конфигурационный файл <br />
<code>GSSAPIAuthentication yes</code> включить Kerberos аутентификацию (через AD) <br />
<code>SyslogFacility LOCAL0</code> включить локальное ведение журнала в файл (C:\ProgramData\ssh\logs\sshd.log) <br />
<code>LogLevel INFO</code> <br />
<code>Restart-Service sshd</code> <br />
<code>ssh -K $srv</code> выполнить Kerberos аутентификацию <br />
<code>ssh Lifailon@192.168.3.99 -p 22</code> <br />
<code>pwsh -command Get-Service</code> <br />
<code>ssh -L 3101:192.168.3.101:22 -R 3101:192.168.3.101:22 lifailon@192.168.3.101 -p 22</code> SSH Tunnel lifailon@localhost:3101 -&gt; 192.168.3.101:3101</p>
<h3 id="psremoting-over-ssh"><a class="header" href="#psremoting-over-ssh">PSRemoting over SSH</a></h3>
<p><code>Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0</code> установка OpenSSH Server <br />
<code>Get-WindowsCapability -Online | ? Name -like 'OpenSSH.Ser*'</code> <br />
<code>iex "&amp; { $(irm https://aka.ms/install-powershell.ps1) } -UseMSI"</code> установка PowerShell Core последней версии (требуется на клиентской стороне) <br />
<code>Set-Service -Name sshd -StartupType "Automatic"</code> <br />
<code>Start-Service sshd</code> <br />
<code>Get-NetTCPConnection -State Listen|where {$_.localport -eq '22'}</code> <br />
<code>Enable-NetFirewallRule -Name *OpenSSH-Server*</code> <br />
<code>New-ItemProperty -Path "HKLM:\SOFTWARE\OpenSSH" -Name DefaultShell -Value "C:\Program Files\PowerShell\7\pwsh.exe" -PropertyType String –Force</code> изменить интерпритатор по умолчанию на pwsh <br />
<code>notepad $Env:ProgramData\ssh\sshd_config</code></p>
<p>PasswordAuthentication yes <br />
Subsystem powershell c:/progra~1/powershell/7/pwsh.exe -sshs -NoLogo # запуск интерпретатора pwsh для удаленных SSH подключений</p>
<p><code>Restart-Service sshd</code></p>
<p><code>$session = New-PSSession -HostName 192.168.3.100 -Port 2121 -UserName lifailon -SSHTransport</code> <br />
<code>Invoke-Command -Session $session -ScriptBlock {Get-Service}</code></p>
<h1 id="winrm"><a class="header" href="#winrm">WinRM</a></h1>
<p><code>Enter-PSSession -ComputerName $srv</code> подключиться к PowerShell сессии через PSRemoting. Подключение возможно только по FQDN-имени <br />
<code>Invoke-Command $srv -ScriptBlock {Get-ComputerInfo}</code> выполнение команды через PSRemoting <br />
<code>$session = New-PSSession $srv</code> открыть сессию <br />
<code>Get-PSSession</code> отобразить активные сессии <br />
<code>icm -Session $session {$srv = $using:srv}</code> передать переменную текущей сессии ($using) в удаленную <br />
<code>Disconnect-PSSession $session</code> закрыть сессию <br />
<code>Remove-PSSession $session</code> удалить сессию <br />
<code>Import-Module -Name ActiveDirectory -PSSession $srv</code> импортировать модуль с удаленного компьютера в локальную сессию</p>
<h3 id="winrm-configuration"><a class="header" href="#winrm-configuration">WinRM Configuration</a></h3>
<p><code>winrm quickconfig -quiet</code> изменит запуск службы WinRM на автоматический, задаст стандартные настройки WinRM и добавить исключения для портов в fw <br />
<code>Enable-PSRemoting –Force</code> включить PowerShell Remoting, работает только для доменного и частного сетевых профилей Windows <br />
<code>Enable-PSRemoting -SkipNetworkProfileCheck -Force</code> для настройки компьютера в общей (public) сети (работает с версии powershell 6)</p>
<p><code>$NetProfiles = Get-NetConnectionProfile</code> отобразить профили сетевых подключений <br />
<code>Set-NetConnectionProfile -InterfaceIndex $NetProfiles[1].InterfaceIndex -NetworkCategory Private</code> изменить тип сети для профиля (DomainAuthenticated/Public) <br />
<code>(Get-CimInstance -ClassName Win32_ComputerSystem).PartOfDomain</code> проверить, что компьютер добавлен в домен AD <br />
<code>Get-Service WinRM | Set-Service -StartupType AutomaticDelayedStart</code> отложенный запуск <br />
<code>Get-Service -Name winrm -RequiredServices</code> статус зависимых служб <br />
<code>New-NetFirewallRule -Profile Any -DisplayName "WinRM HTTP" -Direction Inbound -Protocol TCP -LocalPort 5985,5986</code> <br />
<code>Test-NetConnection $srv -port 5895</code> проверить порт <br />
<code>Test-WSMan $srv -ErrorAction Ignore</code> проверить работу WinRM на удаленном компьютере (игнорировать вывод ошибок для скрипта) или локально (localhost)</p>
<p><code>$Cert = New-SelfSignedCertificate -CertStoreLocation Cert:\LocalMachine\My -DnsName "$env:computername" -FriendlyName "WinRM HTTPS Certificate" -NotAfter (Get-Date).AddYears(5)</code> создать самоподписанный сертификат <br />
<code>$Thumbprint = $Cert.Thumbprint</code> забрать отпечаток <br />
<code>New-Item -Path WSMan:\Localhost\Listener -Transport HTTPS -Address * -CertificateThumbprint $Thumbprint -Name WinRM_HTTPS_Listener -Force</code> создать прослушиватель <br />
<code>New-NetFirewallRule -DisplayName 'WinRM HTTPS' -Profile Domain,Private -Direction Inbound -Action Allow -Protocol TCP -LocalPort 5986</code> открыть порт в fw</p>
<pre><code>$selector_set = @{
    Address = "*"
    Transport = "HTTPS"
}
$value_set = @{
    CertificateThumbprint = "66ABFDA044D8C85135048186E2FDC0DBE6125163"
}
New-WSManInstance -ResourceURI "winrm/config/Listener" -SelectorSet $selector_set -ValueSet $value_set
</code></pre>
<p><code>winrm get winrm/config</code> отобразить всю конфигурацию (Client/Service) <br />
<code>winrm get winrm/config/service/auth</code> конфигурация авторизации на сервере <br />
<code>winrm enumerate winrm/config/listener</code> текущая конфигурация прослушивателей WinRM (отображает отпечаток сертификата для HTTPS 5986) <br />
<code>Get-ChildItem -Path Cert:\LocalMachine\My\ | where Thumbprint -eq D9356FB774EE0E6206B7D5B59B99102CA5B17BDA | select *</code> информация о сертификате</p>
<p><code>ls WSMan:\localhost\Client</code> конфигурацию клиента <br />
<code>ls WSMan:\localhost\Service</code> конфигурация сервера <br />
<code>ls WSMan:\localhost\Service\auth</code> список всех конфигураций аутентификации WinRM сервера <br />
<code>Set-Item -path WSMan:\localhost\Service\auth\basic -value $true</code> разрешить локальную аутентификацию к текущему серверу <br />
<code>ls HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WSMAN</code> настройки в реестре (например, для включения аудентификации в \Service\auth_basic = 1) <br />
<code>Set-Item WSMan:\localhost\Client\TrustedHosts -Value 192.168.* -Force</code> добавить доверенные хосты в конфигурацию на клиенте, чтобы работала Negotiate аутентификация через NTLM <br />
<code>Set-Item WSMan:\localhost\Client\TrustedHosts -Value 192.168.3.100 -Concatenate -Force</code> добавить второй компьютер <br />
<code>ls WSMan:\localhost\Client\TrustedHosts</code> <br />
<code>Set-Item WSMan:\localhost\Client\AllowUnencrypted $true</code> включить передача незашифрованных данных конфигурации клиента <br />
<code>Set-Item WSMan:\localhost\Service\AllowUnencrypted $true</code> включить передача незашифрованных данных конфигурации сервера (необходимо быть в private сети)</p>
<p><code>Get-PSSessionConfiguration</code> проверить, включен ли PSremoting и вывести список пользователей и групп, которым разрешено подключаться через WinRM <br />
<code>Set-PSSessionConfiguration -Name Microsoft.PowerShell -ShowSecurityDescriptorUI</code> назначить права доступа через дескриптор безопасности текущей сессии (до перезагруки) <br />
<code>(Get-PSSessionConfiguration -Name "Microsoft.PowerShell").SecurityDescriptorSDDL</code> получить настройки дескриптора в формате SDDL <br />
<code>Set-PSSessionConfiguration -Name Microsoft.PowerShell -SecurityDescriptorSDDL $SDDL</code> применить настройки дескриптора на другом компьютере без использования GUI \</p>
<p><code>New-LocalUser "WinRM-Writer" -Password (ConvertTo-SecureString -AsPlainText "123098")</code> создать пользователя <br />
<code>Add-LocalGroupMember -Group "Remote Management Users" -Member "WinRM-Writer"</code> добавить пользователя WinRM-Writer в локальную группу доступа "Пользователи удаленного управления" <br />
<code>cmdkey /add:192.168.3.99 /user:WinRM-Writer /pass:123098</code> сохранить пароль в CredentialManager
<code>cmdkey /list</code> <br />
<code>Import-Module CredentialManager</code> <br />
<code>Add-Type -AssemblyName System.Web</code> <br />
<code>New-StoredCredential -Target 192.168.3.99 -UserName WinRM-Writer -Password 123098 -Comment WinRM</code> сохранить пароль в CredentialManager (из PS5) <br />
<code>Get-StoredCredential -AsCredentialObject</code> <br />
<code>$cred = Get-StoredCredential -Target 192.168.3.99</code> <br />
<code>Enter-PSSession -ComputerName 192.168.3.99 -Credential $cred -Authentication Negotiate</code> <br />
<code>Enter-PSSession -ComputerName 192.168.3.99 -Credential $cred -Authentication Basic -Port 5985</code> работает при отключении allowunencrypted на стороне сервера и клиента <br />
<code>winrs -r:http://192.168.3.100:5985/wsman -u:WinRM-Writer -p:123098 ipconfig</code> передать команду через winrs (-?) <br />
<code>winrs -r:https://192.168.3.100:5985/wsman -u:WinRM-Writer -p:123098 -ssl ipconfig</code> через https <br />
<code>pwsh -Command "Install-Module -Name PSWSMan"</code> установить модуль для использования в Linux системе</p>
<h3 id="kerberos"><a class="header" href="#kerberos">Kerberos</a></h3>
<p><code>.\CheckMaxTokenSize.ps1 -Principals login -OSEmulation $true -Details $true</code> узнать размер токена пользователя в домене <br />
<code>Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\Kerberos\Parameters | select maxtokensize</code> максимальный размер токена на сервере <br />
<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\HTTP\Parameters</code> изменить размера, если заголовок пакета аутентификации превышает 16 Кб (из за большого кол-ва групп) <br />
<code>MaxFieldLength увеличить до 0000ffff (65535)</code> <br />
<code>MaxRequestBytes увеличить до 0000ffff (65535)</code></p>
<div style="break-before: page; page-break-before: always;"></div><p>+++
title = "Windows Server"
[extra]
toc = true
toc_sidebar = true
go_to_top = true
+++</p>
<p>Заметки системного администрирования <code>Windows Server</code> через <code>PowerShell</code>.</p>
<hr />
<h1 id="active-directory"><a class="header" href="#active-directory">Active Directory</a></h1>
<h2 id="rsat-remote-server-administration-tools"><a class="header" href="#rsat-remote-server-administration-tools">RSAT (Remote Server Administration Tools)</a></h2>
<p><code>DISM.exe /Online /add-capability /CapabilityName:Rsat.ActiveDirectory.DS-LDS.Tools~~~~0.0.1.0 /CapabilityName:Rsat.GroupPolicy.Management.Tools~~~~0.0.1.0</code> <br />
<code>Add-WindowsCapability –online –Name Rsat.Dns.Tools~~~~0.0.1.0</code> <br />
<code>Add-WindowsCapability -Online -Name Rsat.DHCP.Tools~~~~0.0.1.0</code> <br />
<code>Add-WindowsCapability –online –Name Rsat.FileServices.Tools~~~~0.0.1.0</code> <br />
<code>Add-WindowsCapability -Online -Name Rsat.WSUS.Tools~~~~0.0.1.0</code> <br />
<code>Add-WindowsCapability -Online -Name Rsat.CertificateServices.Tools~~~~0.0.1.0</code> <br />
<code>Add-WindowsCapability -Online -Name Rsat.RemoteDesktop.Services.Tools~~~~0.0.1.0</code> <br />
<code>Get-WindowsCapability -Name RSAT* -Online | Select-Object -Property DisplayName, State</code> отобразить список установленных компанентов</p>
<h2 id="import-module-activedirectory"><a class="header" href="#import-module-activedirectory">Import-Module ActiveDirectory</a></h2>
<p><code>$Session = New-PSSession -ComputerName $srv</code> -Credential $cred <br />
<code>Export-PSsession -Session $Session -Module ActiveDirectory -OutputModule ActiveDirectory</code> экспортировать модуль из удаленной сесси (например, с DC) <br />
<code>Remove-PSSession -Session $Session</code> <br />
<code>Import-Module ActiveDirectory</code> <br />
<code>Get-Command -Module ActiveDirectory</code></p>
<h2 id="adsi-active-directory-service-interface"><a class="header" href="#adsi-active-directory-service-interface">ADSI (Active Directory Service Interface)</a></h2>
<p><code>$d0 = $env:userdnsdomain</code> <br />
<code>$d0 = $d0 -split "\."</code> <br />
<code>$d1 = $d0[0]</code> <br />
<code>$d2 = $d0[1]</code> <br />
<code>$group = [ADSI]"LDAP://OU=Domain Controllers,DC=$d1,DC=$d2"</code> <br />
<code>$group | select *</code></p>
<p><code>$Local_User = [ADSI]"WinNT://./Администратор,user"</code> <br />
<code>$Local_User | Get-Member</code> <br />
<code>$Local_User.Description</code> <br />
<code>$Local_User.LastLogin</code> время последней авторизации локального пользователя</p>
<h2 id="ldap-lightweight-directory-access-protocol"><a class="header" href="#ldap-lightweight-directory-access-protocol">LDAP (Lightweight Directory Access Protocol)</a></h2>
<p><code>$ldapsearcher = New-Object System.DirectoryServices.DirectorySearcher</code> <br />
<code>$ldapsearcher.SearchRoot = "LDAP://OU=Domain Controllers,DC=$d1,DC=$d2"</code> <br />
<code>$ldapsearcher.Filter = "(objectclass=computer)"</code> <br />
<code>$dc = $ldapsearcher.FindAll().path</code></p>
<p><code>$usr = $env:username</code> cписок групп текущего пользователя <br />
<code>$ldapsearcher = New-Object System.DirectoryServices.DirectorySearcher</code> <br />
<code>$ldapsearcher.Filter = "(&amp;(objectCategory=User)(samAccountName=$usr))"</code> <br />
<code>$usrfind = $ldapsearcher.FindOne()</code> <br />
<code>$groups = $usrfind.properties.memberof -replace "(,OU=.+)"</code> <br />
<code>$groups = $groups -replace "(CN=)"</code></p>
<p>DC (Domain Component) - компонент доменного имени <br />
OU (Organizational Unit) - организационные подразделения (type), используются для упорядочения объектов <br />
Container - так же используется для упорядочения объектов, контейнеры в отличии от подраделений не могут быть переименованы, удалены, созданы или связаны с объектом групповой политики (Computers, Domain Controllers, Users) <br />
DN (Distinguished Name) — уникальное имя объекта и местоположение в лесу AD. В DN описывается содержимое атрибутов в дереве (путь навигации), требуемое для доступа к конкретной записи или ее поиска <br />
CN (Common Name) - общее имя</p>
<p><code>(Get-ADObject (Get-ADRootDSE).DefaultNamingContext -Properties wellKnownObjects).wellKnownObjects</code> отобразить отобразить контейнеры по умолчанию <br />
<code>redircmp OU=Client Computers,DC=root,DC=domain,DC=local</code> изменить контейнер компьютеров по умолчанию <br />
<code>redirusr</code> изменить контейнер пользователей по умолчанию</p>
<h2 id="laps-local-admin-password-management"><a class="header" href="#laps-local-admin-password-management">LAPS (Local Admin Password Management)</a></h2>
<p><code>Import-module AdmPwd.ps</code> импортировать модуль <br />
<code>Get-AdmPwdPassword -ComputerName NAME</code> посмотреть пароль <br />
<code>Reset-AdmPwdPassword -ComputerName NAME</code> изменить пароль <br />
<code>Get-ADComputer -Filter * -SearchBase "DC=$d1,DC=$d2" | Get-AdmPwdPassword -ComputerName {$_.Name} | select ComputerName,Password,ExpirationTimestamp | Out-GridView</code> <br />
<code>Get-ADComputer -Identity $srv | Get-AdmPwdPassword -ComputerName {$_.Name} | select ComputerName,Password,ExpirationTimestamp</code></p>
<h2 id="recycle-bin"><a class="header" href="#recycle-bin">Recycle Bin</a></h2>
<p>Удаленные объекты хранятся в корзине AD в течении времени захоронения (определяется в атрибуте домена msDS-deletedObjectLifetime), заданном для леса. По умолчанию это 180 дней. Если данный срок прошел, объект все еще остается в контейнере Deleted Objects, но большинство его атрибутов и связей очищаются (Recycled Object). После истечения периода tombstoneLifetime (по умолчанию также 180 дней, но можно увеличить) объект полностью удаляется из AD автоматическим процессом очистки. <br />
<code>Get-ADForest domain.local</code> отобразить уровень работы леса <br />
<code>Set-ADForestMode -Identity domain.local -ForestMode Windows2008R2Forest -force</code> увеличить уровень работы леса <br />
<code>Enable-ADOptionalFeature –Identity "CN=Recycle Bin Feature,CN=Optional Features,CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration,DC=domain,DC=local" –Scope ForestOrConfigurationSet –Target "domain.local"</code> включить корзину <br />
<code>Get-ADOptionalFeature "Recycle Bin Feature" | select-object name,EnabledScopes</code> если значение EnabledScopes не пустое, значит в домене корзина Active Directory включена <br />
<code>Get-ADObject -Filter 'Name -like "*tnas*"' -IncludeDeletedObjects</code> найти удаленную (Deleted: True) УЗ (ObjectClass: user) в AD <br />
<code>Get-ADObject -Filter 'Name -like "*tnas*"' –IncludeDeletedObjects -Properties *| select-object Name, sAMAccountName, LastKnownParent, memberOf, IsDeleted | fl</code> проверить значение атрибута IsDeleted, контейнер, в котором находился пользователе перед удалением (LastKnownParent) и список групп, в которых он состоял <br />
<code>Get-ADObject –filter {Deleted -eq $True -and ObjectClass -eq "user"} –includeDeletedObjects</code> вывести список удаленных пользователей <br />
<code>Restore-ADObject -Identity "3dc33c7c-b912-4a19-b1b7-415c1395a34e"</code> восстановить по значению атрибута ObjectGUID <br />
<code>Get-ADObject -Filter 'SAMAccountName -eq "tnas-01"' –IncludeDeletedObjects | Restore-ADObject</code> восстановить по SAMAccountName <br />
<code>Get-ADObject -Filter {Deleted -eq $True -and ObjectClass -eq 'group' -and Name -like '*Allow*'} –IncludeDeletedObjects | Restore-ADObject –Verbose</code> восстановить группу или компьютер</p>
<h2 id="thumbnailphoto"><a class="header" href="#thumbnailphoto">thumbnailPhoto</a></h2>
<p><code>$photo = [byte[]](Get-Content C:\Install\adm.jpg -Encoding byte)</code> преобразовать файл картинки в массив байтов (jpeg/bmp файл, размером фото до 100 Кб и разрешением 96?96) <br />
<code>Set-ADUser support4 -Replace @{thumbnailPhoto=$photo}</code> задать значение атрибута thumbnailPhoto</p>
<h2 id="addomaincontroller"><a class="header" href="#addomaincontroller">ADDomainController</a></h2>
<p><code>Get-ADDomainController</code> выводит информацию о текущем контроллере домена (LogonServer), который используется данным компьютером для аутентификации (DC выбирается при загрузке в соответствии с топологией сайтов AD) <br />
<code>Get-ADDomainController -Discover -Service PrimaryDC</code> найти контроллер с ролью PDC в домене <br />
<code>Get-ADDomainController -Filter * | ft HostName,IPv4Address,Name,Site,OperatingSystem,IsGlobalCatalog</code> список все DC, принадлежность к сайту, версии ОС и GC</p>
<p>При загрузке ОС служба NetLogon делает DNS запрос со списком контроллеров домена (к SRV записи _ldap._tcp.dc.<em>msdcs.domain</em>), DNS возвращает список DC в домене с записью Service Location (SRV). Клиент делает LDAP запрос к DC для определения сайта AD по своему IP адресу. Клиент через DNS запрашивает список контроллеров домена в сайте (в разделе _tcp.sitename._sites...).</p>
<p>USN (Update Sequence Numbers) - счетчик номера последовательного обновления, который существует у каждого объекта AD. При репликации контроллеры обмениваются значениями USN, объект с более низким USN будет при репликации перезаписан объектом с более высоким USN. Находится в свойствах - Object (включить View - Advanced Features). Каждый контроллер домена содержит отдельный счетчик USN, который начинает отсчет в момент запуска процесса Dcpromo и продолжает увеличивать значения в течение всего времени существования контроллера домена. Значение счетчика USN увеличивается каждый раз, когда на контроллере домена происходит транзакция, это операции создания, обновления или удаления объекта.</p>
<p><code>Get-ADDomainController -Filter * | % {</code> отобразить USN объекта на всех DC в домене<code>\ </code>Get-ADUser -Server $_.HostName -Identity support4 -Properties uSNChanged | select SamAccountName,uSNChanged<code>\ </code>}`</p>
<p><code>dcpromo /forceremoval</code> принудительно выполнит понижение в роли контроллера домена до уровня рядового сервера. После понижения роли выполняется удаление всех ссылок в домене на этот контроллер. Далее производит включение сервера в состав домена, и выполнение обратного процесса, т.е. повышение сервера до уровня контроллера домена.</p>
<h2 id="adcomputer"><a class="header" href="#adcomputer">ADComputer</a></h2>
<p><code>nltest /DSGETDC:$env:userdnsdomain</code> узнать на каком DC аудентифицирован хост (Logon Server) <br />
<code>nltest /SC_RESET:$env:userdnsdomain\srv-dc2.$env:userdnsdomain</code> переключить компьютер на другой контроллер домена AD вручную (The command completed successfully) <br />
<code>Get-ADComputer –Identity $env:computername -Properties PasswordLastSet</code> время последней смены пароля на сервере <br />
<code>Test-ComputerSecureChannel –verbose</code> проверить доверительные отношения с доменом (соответствует ли локальный пароль компьютера паролю, хранящемуся в AD) <br />
<code>Reset-ComputerMachinePassword -Credential domain\admin</code> принудительно обновить пароль <br />
<code>Netdom ResetPWD /Server:dc-01 /UserD:domain\admin /PasswordD:*</code> сбросить хэш пароля компьютера в домене (перезагрузка не требуется) <br />
<code>Search-ADAccount -AccountDisabled -ComputersOnly | select Name,LastLogonDate,Enabled</code> отобразить все отключенные компьютеры</p>
<p><code>Get-ADComputer -Filter * -Properties * | select name</code> список всех компьютеров в домене (Filter), вывести все свойства (Properties) <br />
<code>Get-ADComputer -Identity $srv -Properties * | ft Name,LastLogonDate,PasswordLastSet,ms-Mcs-AdmPwd -Autosize</code> конкретного компьютера в AD (Identity) <br />
<code>Get-ADComputer -SearchBase "OU=Domain Controllers,DC=$d1,DC=$d2" -Filter * -Properties * | ft Name, LastLogonDate, distinguishedName -Autosize</code> поиск в базе по DN (SearchBase)</p>
<p><code>(Get-ADComputer -Filter {enabled -eq "true"}).count</code> получить общее количество активных (незаблокированных) компьютеров <br />
<code>(Get-ADComputer -Filter {enabled -eq "true" -and OperatingSystem -like "*Windows Server 2016*"}).count</code> кол-во активных копьютеров с ОС WS 2016</p>
<p><code>Get-ADComputer -Filter * -Properties * | select @{Label="Ping Status"; Expression={</code> <br />
<code>$ping = ping -n 1 -w 50 $_.Name</code> <br />
<code>if ($ping -match "TTL") {"Online"} else {"Offline"}</code> <br />
<code>}},</code> <br />
<code>@{Label="Status"; Expression={</code> <br />
<code>if ($_.Enabled -eq "True") {$_.Enabled -replace "True","Active"} else {$_.Enabled -replace "False","Blocked"}</code> <br />
<code>}}, Name, IPv4Address, OperatingSystem, @{Label="UserOwner"; Expression={$_.ManagedBy -replace "(CN=|,.+)"}</code> <br />
<code>},Created | Out-GridView</code></p>
<h2 id="aduser"><a class="header" href="#aduser">ADUser</a></h2>
<p><code>Get-ADUser -Identity support4 -Properties *</code> список всех атрибутов <br />
<code>Get-ADUser -Identity support4 -Properties DistinguishedName, EmailAddress, Description</code> путь DN, email и описание <br />
<code>Get-ADUser -Filter {(Enabled -eq "True") -and (mail -ne "null")} -Properties mail | ft Name,mail</code> список активных пользователей и есть почтовый ящик <br />
<code>Get-ADUser -Filter {SamAccountName -like "*"} | Measure-Object</code> посчитать кол-во всех аккаунтов (Count) <br />
<code>Get-ADUser -Filter * -Properties WhenCreated | sort WhenCreated | ft Name, whenCreated</code> дата создания <br />
<code>Get-ADUser -Identity support4 -property LockedOut | select samaccountName,Name,Enabled,Lockedout</code> <br />
<code>Enabled=True</code> учетная запись включена - да <br />
<code>Lockedout=False</code> учетная запись заблокирована (например, политикой паролей) - нет <br />
<code>Get-ADUser -Identity support4 | Unlock-ADAccount</code> разблокировать учетную запись <br />
<code>Disable-ADAccount -Identity support4</code> отключить учетную запись <br />
<code>Enable-ADAccount -Identity support4</code> включить учетную запись <br />
<code>Search-ADAccount -LockedOut</code> найти все заблокированные учетные записи <br />
<code>Search-ADAccount -AccountDisabled | select Name,LastLogonDate,Enabled</code> отобразить все отключенные учетные записи с временем последнего входа</p>
<p><code>Get-ADUser -Identity support4 -Properties PasswordLastSet,PasswordExpired,PasswordNeverExpires</code> <br />
<code>PasswordLastSet</code> время последней смены пароля <br />
<code>PasswordExpired=False</code> пароль истек - нет <br />
<code>PasswordNeverExpires=True</code> срок действия пароля не истекает - да <br />
<code>Set-ADAccountPassword support4 -Reset -NewPassword (ConvertTo-SecureString -AsPlainText "password" -Force -Verbose)</code> изменить пароль учетной записи <br />
<code>Set-ADUser -Identity support4 -ChangePasswordAtLogon $True</code> смена пароля при следующем входе в систему</p>
<p><code>$day = (Get-Date).adddays(-90)</code> <br />
<code>Get-ADUser -filter {(passwordlastset -le $day)} | ft</code> пользователи, которые не меняли свой пароль больше 90 дней</p>
<p><code>$day = (Get-Date).adddays(-30)</code> <br />
<code>Get-ADUser -filter {(Created -ge $day)} -Property Created | select Name,Created</code> Новые пользователи за 30 дней</p>
<p><code>$day = (Get-Date).adddays(-360)</code> <br />
<code>Get-ADUser -Filter {(LastLogonTimestamp -le $day)} -Property LastLogonTimestamp | select Name,SamAccountName,@{n='LastLogonTimestamp';e={[DateTime]::FromFileTime($_.LastLogonTimestamp)}} | sort -Descending LastLogonTimestamp</code> пользователи, которые не логинились больше 360 дней. Репликация атрибута LastLogonTimestamp составляет от 9 до 14 дней. <br />
<code>| Disable-ADAccount $_.SamAccountName</code> заблокировать <br />
<code>-WhatIf</code> отобразить вывод без применения изменений</p>
<h2 id="adgroupmember"><a class="header" href="#adgroupmember">ADGroupMember</a></h2>
<p><code>(Get-ADUser -Identity support4 -Properties MemberOf).memberof</code> список групп в которых состоит пользователь <br />
<code>Get-ADGroupMember -Identity "Domain Admins" | Select Name,SamAccountName</code> список пользователей в группе <br />
<code>Add-ADGroupMember -Identity "Domain Admins" -Members support5</code> добавить в группу <br />
<code>Remove-ADGroupMember -Identity "Domain Admins" -Members support5 -force</code> удалить из группы <br />
<code>Get-ADGroup -filter * | where {!($_ | Get-ADGroupMember)} | Select Name</code> отобразить список пустых групп (-Not)</p>
<h2 id="adreplication"><a class="header" href="#adreplication">ADReplication</a></h2>
<p><code>Get-Command -Module ActiveDirectory -Name *Replication*</code> список всех командлетов модуля <br />
<code>Get-ADReplicationFailure -Target dc-01</code> список ошибок репликации с партнерами <br />
<code>Get-ADReplicationFailure -Target $env:userdnsdomain -Scope Domain</code> <br />
<code>Get-ADReplicationPartnerMetadata -Target dc-01 | select Partner,LastReplicationAttempt,LastReplicationSuccess,LastReplicationResult,LastChangeUsn</code> время последней и время успешной репликации с партнерами <br />
<code>Get-ADReplicationUpToDatenessVectorTable -Target dc-01</code> Update Sequence Number (USN) увеличивается каждый раз, когда на контроллере домена происходит транзакция (операции создания, обновления или удаления объекта), при репликации DC обмениваются значениями USN, объект с более низким USN при репликации будет перезаписан высоким USN.</p>
<h1 id="repadmin"><a class="header" href="#repadmin">repadmin</a></h1>
<p><code>repadmin /replsummary</code> отображает время последней репликации на всех DC по направлению (Source и Destination) и их состояние с учетом партнеров <br />
<code>repadmin /showrepl $srv</code> отображает всех партнеров по реплкации и их статус для всех разделов Naming Contexts (DC=ForestDnsZones, DC=DomainDnsZones, CN=Schema, CN=Configuration) <br />
<code>repadmin /replicate $srv2 $srv1 DC=domain,DC=local </code> выполнить репликацию с $srv1 на $srv2 только указанный раздела домена <br />
<code>repadmin /SyncAll /AdeP</code> запустить межсайтовую исходящую репликацию всех разделов от текущего сервера со всеми партнерами по репликации <br />
<code>/A</code> выполнить для всех разделов NC <br />
<code>/d</code> в сообщениях идентифицировать серверы по DN (вместо GUID DNS - глобальным уникальным идентификаторам) <br />
<code>/e</code> межсайтовая синхронизация (по умолчанию синхронизирует только с DC текущего сайта) <br />
<code>/P</code> извещать об изменениях с этого сервера (по умолчанию: опрашивать об изменениях) <br />
<code>repadmin /Queue $srv</code> отображает кол-во запросов входящей репликации (очередь), которое необходимо обработать (причиной может быть большое кол-во партнеров или формирование 1000 объектов скриптом) <br />
<code>repadmin /showbackup *</code> узнать дату последнего Backup</p>
<p><code>Error: 1722</code> сервер rpc недоступен (ошибка отката репликации). Проверить имя домена в настройках сетевого адаптера, первым должен идти адрес DNS-сервера другого контроллера домена, вторым свой адрес. <br />
<code>Get-Service -ComputerName $srv | select name,status | ? name -like "RpcSs"</code> <br />
<code>Get-Service -ComputerName $srv -Name RpcSs -RequiredServices</code> зависимые службы <br />
Зависимые службы RPC: <br />
"Служба сведений о подключенных сетях" - должен быть включен отложенный запуск. Если служба срабатывает до "службы списка сетей", может падать связь с доменом (netlogon) <br />
"Центр распространения ключей Kerberos" <br />
"DNS-сервер" <br />
<code>nslookup $srv</code> <br />
<code>tnc $srv -p 135</code> <br />
<code>repadmin /retry</code> повторить попытку привязки к целевому DC, если была ошибка 1722 или 1753 (RPC недоступен)</p>
<p><code>repadmin /showrepl $srv</code> <br />
<code>Last attempt @ 2022-07-15 10:46:01 завершена с ошибкой, результат 8456 (0x2108)</code> при проверки showrepl этого партнера, его ошибка: 8457 (0x2109) <br />
<code>Last success @ 2022-07-11 02:29:46</code> последний успех <br />
Когда репликация автоматически отключена, ОС записывает в DSA - not writable одно из четырех значений: <br />
<code>Path: HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NTDS\Parameters</code> <br />
<code>Dsa Not Writable</code> <br />
<code>#define DSA_WRITABLE_GEN 1</code> версия леса несовместима с ОС <br />
<code>#define DSA_WRITABLE_NO_SPACE 2</code> на диске, где размещена база данных Active Directory или файлы журналов (логи), недостаточно свободного места <br />
<code>#define DSA_WRITABLE_USNROLLBCK 4</code> откат USN произошел из-за неправильного отката базы данных Active Directory во времени (восстановление из снапшота) <br />
<code>#define DSA_WRITABLE_CORRUPT_UTDV 8</code> вектор актуальности поврежден на локальном контроллере домена</p>
<h1 id="dcdiag"><a class="header" href="#dcdiag">dcdiag</a></h1>
<p><code>dcdiag /s:&lt;DomainController&gt; [/n:&lt;NamingContext&gt;] [[/u:&lt;domain\user&gt;] [/p:&lt;password&gt;]] [{/a|/e}{/q|/v}] [/f:&lt;LogFile&gt;] [/ferr:&lt;ErrorLog&gt;] [/test:&lt;test&gt;] [/fix]</code> <br />
<code>dcdiag /Test:replications /s:dc-01</code> отображает ошибки репликации <br />
<code>dcdiag /Test:DNS /e /v /q</code> тест DNS <br />
<code>/a</code> проверка всех серверов данного сайта <br />
<code>/e</code> проверка всех серверов предприятия <br />
<code>/q</code> выводить только сообщения об ошибках <br />
<code>/v</code> выводить подробную информацию <br />
<code>/fix</code> автоматически исправляет ошибки <br />
<code>/test:</code> <br />
<code>NetLogons</code> проверка наличие прав на выполнение репликации <br />
<code>Connectivity</code> проверяет регистрацию DNS для каждого контроллера домена, отправляет тестовый эхо-пакет на каждый контроллер домена и проверяет подключение по протоколам LDAP и RPC к каждому контроллеру домена <br />
<code>Services</code> проверяет работоспособность всех служб, необходимых для работы контроллера домена, на указанном контроллере домена <br />
<code>Systemlog</code> проверяет наличие ошибок в журналах контроллера домена <br />
<code>FRSEvent</code> проверяет ошибки репликации в работе службы репликации файлов, что может означать наличие проблем в репликации SYSVOL и, таким образом, целостности копий объектов групповых политик <br />
<code>FSMOCheck</code> не проверяет роли хозяев операций, а вместо этого запрашивает сервер глобального каталога, первичный контроллер домена, предпочтительный сервер времени, сервер времени и центр распространения ключей (контроллер домена может подключиться к KDC, PDC, серверу глобального каталога) <br />
<code>KnowsOfRoleHolders</code> пgроверяет возможность подключения контроллеров домена ко всем пяти хозяевам операций (ролями FSMO) <br />
<code>MachineAccount</code> проверяет правильность регистрации учетной записи целевого компьютера и правильность объявлений служб этого компьютера (корректность доверительных отношения с доменом). Если обнаружена ошибка, ее можно исправить с помощью утилиты dcdiag, указав параметры /fixmachineaccount или /recreatemachineaccount <br />
<code>Advertising</code> проверяет, правильно ли контроллер домена сообщает о себе и о своей роли хозяина операций. Этот тест завершиться неудачно, если служба NetLogon не запущена <br />
<code>CheckSDRefDom</code> проверяет правильность доменов ссылок дескрипторов безопасности для каждого раздела каталогов программ <br />
<code>CrossRefValidation</code> проверяет правильность перекрестных ссылок для доменов <br />
<code>RRSSysvol</code> проверяет состояние готовности для FRS SYSVOL <br />
<code>Intersite</code> проверяет наличие ошибок, которые могут помешать нормальной репликации между сайтами. Компания Microsoft предупреждает, что иногда результаты этого теста могут оказаться неточными <br />
<code>KCCEvent</code> проверяет безошибочность создания объектов соединений для репликации между сайтами <br />
<code>NCSecDesc</code> проверяет правильность разрешений для репликации в дескрипторах безопасности для заголовков контекста именования <br />
<code>ObjectsReplicated</code> проверяет правильность репликации агента сервера каталогов и объектов учетных записей компьютеров <br />
<code>OutboundSecureChannels</code> проверяется наличие безопасных каналов между всеми контроллерами домена в интересующем домене <br />
<code>Replications</code> проверяет возможность репликации между контроллерами домена и сообщает обо всех ошибках при репликации <br />
<code>RidManager</code> проверяет работоспособность и доступность хозяина относительных идентификаторов <br />
<code>VerifyEnterpriseReferences</code> проверяет действительность системных ссылок службы репликации файлов для всех объектов на всех контроллерах домена в лесу <br />
<code>VerifyReferences</code> проверяет действительность системных ссылок службы репликации файлов для всех объектов на указанном контроллере домена <br />
<code>VerifyReplicas</code> проверяет действительность всех разделов каталога приложения на всех серверах, принимающих участие в репликации</p>
<h1 id="ntdsutil"><a class="header" href="#ntdsutil">ntdsutil</a></h1>
<p>Перенос БД AD (ntds.dit): <br />
<code>Get-Acl C:\Windows\NTDS | Set-Acl D:\AD-DB</code> скопировать NTFS разрешения на новый каталог <br />
<code>Stop-Service -ComputerName dc -name NTDS</code> остановить службу Active Directory Domain Services <br />
<code>ntdsutil</code> запустить утилиту ntdsutil <br />
<code>activate instance NTDS</code> выбрать активный экземпляр базы AD <br />
<code>files</code> перейдем в контекст files, в котором возможно выполнение операция с файлами базы ntds.dit <br />
<code>move DB to D:\AD-DB\</code> перенести базу AD в новый каталог (предварительно нужно его создать) <br />
<code>info</code> проверить, что БД находится в новом каталоге <br />
<code>move logs to D:\AD-DB\</code> переместим в тот же каталог файлы с журналами транзакций <br />
<code>quit</code> <br />
<code>Start-Service -ComputerName dc -name NTDS</code></p>
<p>Сброс пароля DSRM (режим восстановления служб каталогов):  <br />
<code>ntdsutil</code> <br />
<code>set dsrm password</code> <br />
<code>reset password on server NULL</code> <br />
новый пароль <br />
подтверждение пароля <br />
<code>quit</code> <br />
<code>quit</code></p>
<p>Синхронизировать с паролем УЗ в AD: <br />
<code>ntdsutil</code> <br />
<code>set dsrm password</code> <br />
<code>sync from domain account dsrmadmin</code> <br />
<code>quit</code> <br />
<code>quit</code></p>
<p>Ошибка 0x00002e2 при загрузке ОС. <br />
Загрузиться в режиме восстанавления WinRE (Windows Recovery Environment) - Startup Settings - Restart - DSRM (Directory Services Restore Mode) <br />
<code>reagentc /boottore</code> shutdown /f /r /o /t 0 перезагрузка в режиме WinRE - ОС на базе WinPE (Windows Preinstallation Environment), образ winre.wim находится на скрытом разделе System Restore <br />
На контроллере домена единственная локальная учетная запись — администратор DSRM. Пароль создается при установке роли контроллера домена ADDS на сервере (SafeModeAdministratorPassword). <br />
<code>ntdsutil</code> <br />
<code>activate instance ntds</code> <br />
<code>Files</code> <br />
<code>Info</code> <br />
<code>integrity</code> проверить целостность БД <br />
Ошибка: Failed to open DIT for AD DS/LDS instance NTDS. Error -2147418113 <br />
<code>mkdir c:\ntds_bak</code> <br />
<code>xcopy c:\Windows\NTDS\*.* c:\ntds_bak</code> backup содержимого каталога с БД <br />
<code>esentutl /g c:\windows\ntds\ntds.dit</code> проверим целостность файла <br />
Вывод: Integrity check completed. Database is CORRUPTED ошибка, база AD повреждена <br />
<code>esentutl /p c:\windows\ntds\ntds.dit</code> исправить ошибки <br />
Вывод: Operation completed successfully in xx seconds. нет ошибок <br />
<code>esentutl /g c:\windows\ntds\ntds.dit</code> проверим целостность файла <br />
Выполнить анализ семантики базы с помощью ntdsutil: <br />
<code>ntdsutil</code> <br />
<code>activate instance ntds</code> <br />
<code>semantic database analysis</code> <br />
<code>go</code> <br />
<code>go fixup</code> исправить семантические ошибки <br />
Сжать файл БД: <br />
<code>activate instance ntds</code> <br />
<code>files</code> <br />
<code>compact to C:\Windows\NTDS\TEMP</code> <br />
<code>copy C:\Windows\NTDS\TEMP\ntds.dit C:\Windows\NTDS\ntds.dit</code> заменить оригинальный файл ntds.dit <br />
<code>Del C:\Windows\NTDS\*.log</code> удалить все лог файлы из каталога NTDS</p>
<h1 id="gpo"><a class="header" href="#gpo">GPO</a></h1>
<p><code>Get-Command -Module GroupPolicy</code> <br />
<code>Get-GPO -Domain domain.local -All | ft</code> <br />
<code>Get-GPO -Name LAPS</code> <br />
<code>[xml](Get-GPOReport LAPS -ReportType Xml)</code> <br />
<code>Get-GPPermission -Name LAPS -All</code> <br />
<code>Get-GPO LAPS | New-GPLink -Target "ou=servers,dc=domain,dc=local"</code> <br />
<code>Set-GPLink -Name LAPS -Target "ou=servers,dc=domain,dc=local" -LinkEnabled No</code> <br />
<code>Backup-GPO -Name LAPS -Path "$home\Desktop"</code> <br />
<code>Backup-GPO -All -Path "$home\Desktop"</code> <br />
<code>Restore-GPO -Name LAPS -Path C:\Backup\GPOs\</code></p>
<h1 id="ms-exchange"><a class="header" href="#ms-exchange">MS Exchange</a></h1>
<p><code>$srv_cas = "exchange-cas"</code> <br />
<code>$session_exchange = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri http://$srv_cas/PowerShell/</code> -Credential $Cred -Authentication Kerberos <br />
<code>Get-PSSession</code> <br />
<code>Import-PSSession $session_exchange -DisableNameChecking</code> импортировать в текущую сессию</p>
<p><code>Get-ExchangeServer | select name,serverrole,admindisplayversion,Edition,OriginatingServer,WhenCreated,WhenChanged,DataPath | ft</code> список всех серверов</p>
<p><code>Get-ImapSettings</code> настройки IMAP <br />
<code>Get-ExchangeCertificate</code> список сертификатов <br />
<code>Get-ExchangeCertificate -Thumbprint "5CEC8544D4743BC279E5FEA1679F79F5BD0C2B3A" | Enable-ExchangeCertificate -Services  IMAP, POP, IIS, SMTP</code> <br />
<code>iisreset</code> <br />
<code>Get-ClientAccessService | fl identity, *uri*</code> настройки службы автообнаружения в Exchange 2016 <br />
<code>Get-ClientAccessService -Identity $srv | Set-ClientAccessService -AutoDiscoverServiceInternalUri https://mail.domain.ru/Autodiscover/Autodiscover.xml</code> изменить на внешний адрес <br />
<code>Get-OutlookAnywhere</code> OA позволяет клиентам Outlook подключаться к своим почтовым ящикам за пределами локальной сети (без использования VPN) <br />
<code>Get-WebServicesVirtualDirectory</code> <br />
<code>Get-OwaVirtualDirectory</code> <br />
<code>Get-ActiveSyncVirtualDirectory</code> <br />
<code>Get-OabVirtualDirectory</code> виртуальная директория автономной адресной книги <br />
<code>Get-OabVirtualDirectory -Server $srv | Set-OabVirtualDirectory -InternalUrl "https://mail.domain.ru/OAB" -ExternalUrl "https://mail.domain.ru/OAB"</code></p>
<h2 id="roles"><a class="header" href="#roles">Roles</a></h2>
<p>MS (Mailbox) - сервер с БД почтовых ящиков и общих папок, отвечает только за их размещение и не выполняет маршрутизацию никаких сообщений. <br />
CAS (Client Access Server) - обработка клиентских подключений к почтовым ящикам, которые создаются клиентами Outlook Web Access (HTTP для Outlook Web App), Outlook Anywhere, ActiveSync (для мобильных устройств), интернет протоколы POP3 и IMAP4, MAPI для клиентов Microsoft Outlook. <br />
Hub Transort - ответвечает за маршрутизацию сообщений интернета и инфраструктурой Exchange, а также между серверами Exchange. Сообщения всегда маршрутизируются с помощью роли транспортного сервера-концентратора, даже если почтовые ящики источника и назначения находятся в одной базе данных почтовых ящиков. <br />
Relay - роль пограничного транспортного сервера (шлюз SMTP в периметре сети).</p>
<p>SCP (Service Connection Point) - запись прописывается в AD, при создание сервера CAS. Outlook запрашивает SCP, выбирает те, которые находятся в одном сайте с ним и по параметру WhenCreated – по дате создания, выбирая самый старый. <br />
Autodiscover. Outlook выбирает в качестве сервера Client Access тот, который прописан в атрибуте RPCClientAccessServer базы данных пользователя. Сведения о базе данных и сервере mailbox, на котором она лежит, берутся из AD.</p>
<h2 id="messagetrackinglog"><a class="header" href="#messagetrackinglog">MessageTrackingLog</a></h2>
<p><code>Get-MessageTrackingLog -ResultSize Unlimited | select Timestamp,Sender,Recipients,RecipientCount,MessageSubject,Source,EventID,ClientHostname,ServerHostname,ConnectorId, @{Name="MessageSize"; Expression={[string]([int]($_.TotalBytes / 1024))+" KB"}},@{Name="MessageLatency"; Expression={$_.MessageLatency -replace "\.\d+$"}}</code> <br />
<code>Get-MessageTrackingLog -Start (Get-Date).AddHours(-24) -ResultSize Unlimited | where {[string]$_.recipients -like "*@yandex.ru"}</code> вывести сообщения за последние 24 часа, где получателем был указанный домен <br />
-Start "04/01/2023 09:00:00" -End "04/01/2023 18:00:00" - поиск по указанному промежутку времени <br />
-MessageSubject "Тест" - поиск по теме письма <br />
-Recipients "support4@domain.ru" - поиск по получателю <br />
-Sender - поиск по отправителю <br />
-EventID – поиск по коду события сервера (RECEIVE, SEND, FAIL, DSN, DELIVER, BADMAIL, RESOLVE, EXPAND, REDIRECT, TRANSFER, SUBMIT, POISONMESSAGE, DEFER) <br />
-Server – поиск на определенном транспортном сервере <br />
-messageID – трекинг письма по его ID</p>
<h2 id="mailbox"><a class="header" href="#mailbox">Mailbox</a></h2>
<p><code>Get-Mailbox -Database "it2"</code> список почтовых серверов в базе данных <br />
<code>Get-Mailbox -resultsize unlimited | ? Emailaddresses -like "support4" | format-list name,emailaddresses,database,servername</code> какую БД, сервер и smtp-адреса использует почтовый ящик <br />
<code>Get-Mailbox -Database $db_name -Archive</code> отобразить архивные почтовые ящики</p>
<p><code>Get-MailboxFolderStatistics -Identity "support4" -FolderScope All | select Name,ItemsInFolder,FolderSize</code> отобразить кол-во писем и размер в каждой папке <br />
<code>Get-MailboxStatistics "support4" | select DisplayName,LastLoggedOnUserAccount,LastLogonTime,LastLogoffTime,ItemCount,TotalItemSize,DeletedItemCount,TotalDeletedItemSize,Database,ServerName</code> общее кол-во писем, их размер, время последнего входа и выхода, имя сервера и БД <br />
<code>Get-Mailbox -Server s2 | Get-MailboxStatistics | where {$_.Lastlogontime -lt (get-date).AddDays(-30)} | Sort Lastlogontime -desc | ft displayname,Lastlogontime,totalitemsize</code> ящики, которые не использовались 30 и более дней</p>
<p><code>Enable-Mailbox -Identity support9 -Database test_base</code> создать почтовый ящик для существующего пользователя в AD <br />
<code>New-Mailbox -Name $login -UserPrincipalName "$login@$domain" -Database $select_db -OrganizationalUnit $path -Password (ConvertTo-SecureString -String "$password" -AsPlainText -Force)</code> создать новый почтовый ящик без привязки к пользователю AD <br />
<code>Get-MailboxDatabase -Database $db_name | Remove-MailboxDatabase</code> удалить БД</p>
<p><code>Set-MailBox "support4" -PrimarySmtpAddress support24@domain.ru -EmailAddressPolicyEnabled $false</code> добавить и изменить основной SMTP-адрес электронной почты для пользователя <br />
<code>Set-Mailbox -Identity "support4" -DeliverToMailboxAndForward $true -ForwardingSMTPAddress "username@outlook.com"</code> включить переадресацию почты (электронная почта попадает в почтовый ящик пользователя support4 и одновременно пересылается по адресу username@outlook.com)</p>
<h2 id="moverequest"><a class="header" href="#moverequest">MoveRequest</a></h2>
<p><code>Get-Mailbox -Database $db_in | New-MoveRequest -TargetDatabase $db_out</code> переместить все почтовые ящики из одной БД в другую <br />
<code>New-MoveRequest -Identity $db_in -TargetDatabase $db_out</code> переместить один почтовый ящик <br />
<code>Get-MoveRequest | Suspend-MoveRequest</code> остановить запросы перемещения <br />
<code>Get-MoveRequest | Remove-MoveRequest</code> удалить запросы на перемещение <br />
<code>Get-MoveRequest | Get-MoveRequestStatistics</code> статус перемещения</p>
<p>Status: <br />
Cleanup - нужно подождать <br />
Queued - в очереди <br />
InProgress - в процессе <br />
Percent Complete - процент выполнения <br />
CompletionInProgress - завершение процесса <br />
Completed - завершено</p>
<p><code>Remove-MoveRequest -Identity $db_name</code> завершить процесс перемещения (убрать статус перемещения с почтового ящика и очистить список перемещений) <br />
<code>Get-MailboxDatabase | Select Name, MailboxRetention</code> после перемещения ящиков, размер базы не изменится, полное удаление из базы произойдет, как пройдет количество дней, выставленное в параметре MailboxRetention <br />
<code>Set-MailboxDatabase -MailboxRetention '0.00:00:00' -Identity $db_name</code> изменить значение</p>
<h2 id="archive-1"><a class="header" href="#archive-1">Archive</a></h2>
<p><code>Enable-Mailbox -Identity $name -Archive</code> включить архив для пользователя <br />
<code>Get-Mailbox $name | New-MoveReques –ArchiveOnly –ArchiveTargetDatabase DBArch</code> переместить архивный почтовый ящик в другую БД <br />
<code>Get-Mailbox $name | fl Name,Database,ArchiveDatabase</code> место расположения БД пользователя и БД его архива <br />
<code>Disable-Mailbox -Identity $name -Archive</code> отключить архив <br />
<code>Connect-Mailbox -Identity "8734c04e-981e-4ccf-a547-1c1ac7ebf3e2" -Archive -User $name -Database it2</code> подключение архива пользователя к указанному почтовому ящику <br />
<code>Get-Mailbox $name | Set-Mailbox -ArchiveQuota 20GB -ArchiveWarningQuota 19GB</code> настроить квоты хранения архива</p>
<h2 id="quota-1"><a class="header" href="#quota-1">Quota</a></h2>
<p><code>Get-Mailbox -Identity $mailbox | fl IssueWarningQuota, ProhibitSendQuota, ProhibitSendReceiveQuota, UseDatabaseQuotaDefaults</code> отобразить квоты почтового ящика <br />
IssueWarningQuota — квота, при достижении которой Exchange отправит уведомление <br />
ProhibitSendQuota — при достижении будет запрещена отправка <br />
ProhibitSendReceiveQuota — при достижении будет запрещена отправка и получение <br />
UseDatabaseQuotaDefaults — используется ли квота БД или false - индвидиуальные <br />
<code>Set-Mailbox -Identity $mailbox -UseDatabaseQuotaDefaults $false -IssueWarningQuota "3 GB" -ProhibitSendQuota "4 GB" -ProhibitSendReceiveQuota "5 GB"</code> задать квоту для пользователя</p>
<p><code>Get-MailboxDatabase $db_name | fl Name, *Quota</code> отобразить квоты наложенные на БД <br />
<code>Set-MailboxDatabase $db -ProhibitSendReceiveQuota "5 GB" -ProhibitSendQuota "4 GB" -IssueWarningQuota "3 GB"</code> настроить квоты на БД</p>
<h2 id="database"><a class="header" href="#database">Database</a></h2>
<p><code>Get-MailboxDatabase -Status | select ServerName,Name,DatabaseSize</code> список и размер всех БД на всех MX-серверах <br />
<code>New-MailboxDatabase -Name it_2022 -EdbFilePath E:\Bases\it_2022\it_2022.edb -LogFolderPath G:\Logs\it_2022 -OfflineAddressBook "Default Offline Address List" -server exch-mx-01</code> создать БД <br />
<code>Restart-Service MSExchangeIS</code> <br />
<code>Get-Service | Where {$_ -match "exchange"} | Restart-Service</code> <br />
<code>Get-MailboxDatabase -Server exch-01</code> список баз данных на MX-сервере <br />
<code>New-MoveRequest -Identity "support4" -TargetDatabase it_2022</code> переместить почтовый ящик в новую БД <br />
<code>Move-Databasepath $db_name –EdbFilepath "F:\DB\$db_name\$db_name.edb" –LogFolderpath "E:\DB\$db_name\logs\"</code> переместить БД и транзакционные логи на другой диск <br />
<code>Set-MailboxDatabase -CircularLoggingEnabled $true -Identity $db_name</code> включить циклическое ведение журнала (Circular Logging), где последовательно пишутся 4 файла логов по 5 МБ, после чего первый лог-файл перезаписывается <br />
<code>Set-MailboxDatabase -CircularLoggingEnabled $false -Identity $db_name</code> отключить циклическое ведение журнала <br />
<code>Get-MailboxDatabase -Server "exch-mx-01" -Status | select EdbFilePath,LogFolderPath,LogFilePrefix</code> путь к БД, логам, имя текущего актуального лог-файла</p>
<h2 id="mailboxrepairrequest"><a class="header" href="#mailboxrepairrequest">MailboxRepairRequest</a></h2>
<p><code>New-MailboxRepairRequest -Database it2 -CorruptionType ProvisionedFolder, SearchFolder, AggregateCounts, Folderview</code> запустить последовательный тест (в конкретный момент времени не доступен один почтовый ящик) и исправление ошибок на прикладном уровне <br />
<code>Get-MailboxRepairRequest -Database it2</code> прогресс выполнения <br />
Позволяет исправить: <br />
ProvisionedFolder – нарушения логической структуры папок <br />
SearchFolder – ошибки в папках поиска <br />
AggregateCounts – проверка и исправление информации о количестве элементов в папках и их размере <br />
FolderView – неверное содержимое, отображаемое представлениями папок</p>
<h2 id="eseutil"><a class="header" href="#eseutil">eseutil</a></h2>
<p>При отправке/получении любого письма Exchange сначала вносит информацию в транзакционный лог, и только потом сохраняет элемент непосредственно в базу данных. Размер одного лог файла - 1 Мб. Есть три способа урезания логов: DAG, Backup на базе Volume Shadow Copy, Circular Logging.</p>
<p>Ручное удаление журналов транзакций: <br />
<code>cd E:\MS_Exchange_2010\MailBox\Reg_v1_MailBoxes\</code> перейти в каталог с логами <br />
<code>ls E*.chk</code> узнать имя файла, в котором находится информация из контрольной точки фиксации журналов <br />
<code>eseutil /mk .\E18.chk</code> узнать последний файл журнала, действия из которого были занесены в БД Exchange <br />
<code>Checkpoint: (0x561299,8,16)</code> 561299 имя файла, который был последним зафиксирован (его информация уже в базе данных) <br />
Находим в проводнике файл E0500561299.txt, можно удалять все файлы журналов, которые старше найденного файла</p>
<p>Восстановление БД (если две копии БД с ошибкой): <br />
<code>Get-MailboxDatabaseCopyStatus -Identity db_name\* | Format-List Name,Status,ContentIndexState</code> <br />
Status            : FailedAndSuspended <br />
ContentIndexState : Failed <br />
Status            : Dismounted <br />
ContentIndexState : Failed</p>
<p><code>Get-MailboxDatabase -Server exch-mx-01 -Status | fl Name,EdbFilePath,LogFolderPath</code> проверить расположение базы и транзакционных логов <br />
LogFolderPath - директория логов <br />
E18 - имя транкзакционного лога (из него читаются остальные логи) <br />
<code>dismount-Database db_name</code> отмантировать БД <br />
<code>eseutil /mh D:\MS_Exchange_2010\Mailbox\db_name\db_name.edb</code> проверить базу <br />
State: Dirty Shutdown - несогласованное состояние, означает, что часть транзакций не перенесена в базу, например, после того, как была осуществлена аварийная перезагрузка сервера. <br />
<code>eseutil /ml E:\MS_Exchange_2010\MailBox\db_name\E18</code> проверка целостности транзакционных логи, если есть логи транзакций и они не испорчены, то можно восстановить из них, из файла E18 считываются все логи, должен быть статус - ОК</p>
<p>Soft Recovery (мягкое восстановление) - необходимо перевести базу в состояние корректного отключения (Clear shutdown) путем записи недостающих файлов журналов транзакций в БД. <br />
<code>eseutil /R E18 /l E:\MS_Exchange_2010\MailBox\db_name\ /d D:\MS_Exchange_2010\Mailbox\db_name\db_name.edb</code> <br />
<code>eseutil /R E18 /a /i /l E:\MS_Exchange_2010\MailBox\db_name\ /d D:\MS_Exchange_2010\Mailbox\db_name\db_name.edb</code> если с логами что-то не так, можно попробовать восстановить базу игнорируя ошибку в логах <br />
<code>eseutil /mk D:\MS_Exchange_2010\Mailbox\db_name\db_name.edb</code> cостоянии файла контрольных точек <br />
<code>eseutil /g D:\MS_Exchange_2010\Mailbox\db_name\db_name.edb</code> проверка целостности БД <br />
<code>eseutil /k D:\MS_Exchange_2010\Mailbox\db_name\db_name.edb</code> проверка контрольных сумм базы (CRC)</p>
<p>Hard Recovery - если логи содержат ошибки и база не восстанавливается, то восстанавливаем базу без логов. <br />
<code>eseutil /p D:\MS_Exchange_2010\Mailbox\db_name\db_name.edb</code> <br />
/p - удалит поврежденные страницы, эта информация будет удалена из БД и восстановит целостность <br />
<code>esetuil /d D:\MS_Exchange_2010\Mailbox\db_name\db_name.edb</code> выполнить дефрагментацию (если был потерян большой объем данных, то может сильно снизиться производительность) <br />
После выполнения команд необходимо вручную удалить все файлы с расширением log в папке MDBDATA, перед попыткой смонтировать базу данных. <br />
<code>isinteg -s "db_name.edb" -test alltests</code> проверьте целостность базы данных <br />
<code>isinteg -s "server_name" -fix -test -alltests</code> если проверка будет провалена. Выполнять команду до тех пор, пока у всех ошибок не станет статус 0 или статус не перестанет меняться, иногда необходимо 3 прохода для достижения результата. <br />
<code>eseutil /mh D:\MS_Exchange_2010\Mailbox\db_name\db_name.edb | Select-String -Pattern "State:","Log Required:"</code> проверить статус <br />
State: Clear shutdown - успешный статус <br />
<code>Log Required</code> требуются ли файлы журналов, необходимые базе, чтобы перейти в согласованное состояние. Если база размонтирована корректно, то это значение будет равняться 0. <br />
<code>mount-Database -force db_name</code> примонтировать БД <br />
<code>Get-MailboxDatabase –Status db_name | fl Mounted</code> статус БД <br />
<code>New-MailboxRepairRequest -Database db_name -CorruptionType SearchFolder,AggregateCounts,ProvisionedFolder,FolderView</code> восстановление логической целостности данных <br />
После этого восстановить Index. <br />
Если индексы не восстанавливаются, но БД монтируется, то перенести почтовые ящики в новую БД.</p>
<p>Восстановление БД из Backup:</p>
<p>1-й вариант:</p>
<ol>
<li>Отмантировать текущую БД и удалить или переименовать директорию с файлами текущей БД.</li>
<li>Восстановить в ту же директорию из Backup базу с логами.</li>
<li>Запустить мягкое восстановление БД (Soft Recovery).</li>
<li>Примониторвать.</li>
</ol>
<p>2-й вариант:</p>
<ol>
<li>Отмантировать и удалить текущую БД.</li>
<li>Восстановить БД с логами из Backup в любое место.</li>
<li>Запустить мягкое восстановление БД (Soft Recovery).</li>
<li>Создать новую БД.</li>
<li>Создать Recovery Database и смонтировать в нее восстановленную из бэкапа БД, скопировать из неё почтовые ящики в новую БД и переключить на них пользователей.</li>
<li>Если использовать Dial Tone Recovery, то так же перенести из временной БД промежуточные данные почтовых ящиков.</li>
</ol>
<p>3-й вариант:</p>
<ol>
<li>Восстановить целостность Soft Repair или Hard Recovery.</li>
<li>Создать новую БД. Указывать в свойствах: «база может быть перезаписана при восстановлении».</li>
<li>Если база была только что оздана и еще не была подмонтирована, то эта папка будет пуста, туда перемещаем базу из Backup, которая была обработана ESEUTIL вместе со всеми файлами. Указать имя .edb такое же, которое было при создании новой базы.</li>
<li>Монтируем базу.</li>
<li>Перенацеливаем ящики со старой (Mailbox_DB_02), неисправной базы, на новую базу (Mailbox_DB_02_02):
<code>Get-Mailbox -Database Mailbox_DB_02 | where {$_.ObjectClass -NotMatch '(SystemAttendantMailbox|ExOleDbSystemMailbox)'} | Set-Mailbox -Database Mailbox_DB_02_02</code></li>
<li>Восстановление логической целостности данных:
<code>New-MailboxRepairRequest -Database "Mailbox_DB_02_02" -CorruptionType ProvisionedFolder, SearchFolder, AggregateCounts, Folderview</code></li>
</ol>
<h2 id="dial-tone-recovery"><a class="header" href="#dial-tone-recovery">Dial Tone Recovery</a></h2>
<p><code>Get-Mailbox -Database "MailboxDB" | Set-Mailbox -Database "TempDB"</code> перенацелить ящики с одной БД (нерабочей) на другую (пустую) <br />
<code>Get-Mailbox -Database TempDB</code> отобразить почтовые ящики в БД TempDB <br />
<code>Restart-Service MSExchangeIS</code> перезапустить службу Mailbox Information Store (банка данных), иначе пользователи будут по-прежнему пытаться подключиться к старой БД <br />
<code>iisreset</code> <br />
<code>Get-Mailbox -Database "TempDB" | Set-Mailbox -Database "MailboxDB"</code> после восстановления старой БД, нужно переключить пользователей с временной БД обратно <br />
После этого сделать слияние с временной БД с помощью Recovery.</p>
<h2 id="recovery-database-rdb"><a class="header" href="#recovery-database-rdb">Recovery database (RDB)</a></h2>
<p><code>New-MailboxDatabase –Recovery –Name RecoveryDB –Server $exch_mx –EdbFilePath "D:\TempDB\TempDB.edb" -LogFolderPath "D:\TempDB"</code> для переноса новых писем из временной БД в основную необходим только сам файл TempDB.edb со статусом Clean Shutdown, из нее необходимо создать служебную БД (ключ -Recovery) <br />
<code>Mount-Database "D:\TempDB\TempDB.edb"</code> примонтировать БД <br />
<code>Get-MailboxStatistics -Database RecoveryDB</code> <br />
<code>New-MailboxRestoreRequest –SourceDatabase RecoveryDB –SourceStoreMailbox support –TargetMailbox support</code> скопировать данные почтового ящика с DisplayName: support из RecoveryDB в почтовый ящик с псевдонимом support существующей базы. По умолчанию ищет в почтовой базе совпадающие LegacyExchangeDN либо проверяет совпадение адреса X500, если нужно восстановить данные в другой ящик, нужно указывать ключ -AllowLegacyDNMisMatch <br />
<code>New-MailboxRestoreRequest –SourceDatabase RecoveryDB –SourceStoreMailbox support –TargetMailbox support –TargetRootFolder "Restore"</code> скопировать письма в отдельную папку в ящике назначения (создается автоматически), возможно восстановить содержимое конкретной папки -IncludeFolders "#Inbox#" <br />
<code>Get-MailboxRestoreRequest | Get-MailboxRestoreRequestStatistics</code> статус запроса восстановления <br />
<code>Get-MailboxRestoreRequestStatistics -Identity support</code> <br />
<code>Get-MailboxRestoreRequest -Status Completed | Remove-MailboxRestoreRequest</code> удалить все успешные запросы</p>
<h2 id="transport"><a class="header" href="#transport">Transport</a></h2>
<p><code>Get-TransportServer $srv_cas | select MaxConcurrentMailboxDeliveries,MaxConcurrentMailboxSubmissions,MaxConnectionRatePerMinute,MaxOutboundConnections,MaxPerDomainOutboundConnections,PickupDirectoryMaxMessagesPerMinute</code> настройки пропускной способности транспортного сервера <br />
MaxConcurrentMailboxDeliveries — максимальное количество одновременных потоков, которое может открыть сервер для отправки писем. <br />
MaxConcurrentMailboxSubmissions — максимальное количество одновременных потоков, которое может открыть сервер для получения писем. <br />
MaxConnectionRatePerMinute — максимальное возможная скорость открытия входящих соединений в минуту. <br />
MaxOutboundConnections — максимальное возможное количество соединений, которое может открыть Exchange для отправки. <br />
MaxPerDomainOutboundConnections — максимальное возможное количество исходящих соединений, которое может открыть Exchange для одного удаленного домена. <br />
PickupDirectoryMaxMessagesPerMinute — скорость внутренней обработки сообщений в минуту (распределение писем по папкам). <br />
<code>Set-TransportServer exchange-cas -MaxConcurrentMailboxDeliveries 21 -MaxConcurrentMailboxSubmissions 21 -MaxConnectionRatePerMinute 1201 -MaxOutboundConnections 1001 -MaxPerDomainOutboundConnections 21 -PickupDirectoryMaxMessagesPerMinute 101</code> изменить значения</p>
<p><code>Get-TransportConfig | select MaxSendSize, MaxReceiveSize</code> ограничение размера сообщения на уровне траспорта (наименьший приоритет, после коннектора и почтового ящика). <br />
<code>New-TransportRule -Name AttachmentLimit -AttachmentSizeOver 15MB -RejectMessageReasonText "Sorry, messages with attachments over 15 MB are not accepted"</code> создать транспортное правило для проверки размера вложения</p>
<h2 id="connector"><a class="header" href="#connector">Connector</a></h2>
<p><code>Get-ReceiveConnector | select Name,MaxMessageSize,RemoteIPRanges,WhenChanged</code> ограничения размера сообщения на уровне коннектора (приоритет ниже, чем у почтового ящика) <br />
<code>Set-ReceiveConnector ((Get-ReceiveConnector).Identity)[-1] -MaxMessageSize 30Mb</code> изменить размер у последнего коннектора в списке (приоритет выше, чем у траспорта) <br />
<code>Get-Mailbox "support4" | select MaxSendSize, MaxReceiveSize</code> наивысший приоритет <br />
<code>Set-Mailbox "support4" -MaxSendSize 30MB -MaxReceiveSize 30MB</code> изменить размер</p>
<p><code>Set-SendConnector -Identity "ConnectorName" -Port 26</code> изменить порт коннектора отправки <br />
<code>Get-SendConnector "proxmox" | select port</code></p>
<p><code>Get-ReceiveConnector | select Name,MaxRecipientsPerMessage</code> по умолчанию Exchange принимает ограниченное количество адресатов в одном письме (200) <br />
<code>Set-ReceiveConnector ((Get-ReceiveConnector).Identity)[-1] -MaxRecipientsPerMessage 50</code> изменить значение <br />
<code>Set-ReceiveConnector ((Get-ReceiveConnector).Identity)[-1] -MessageRateLimit 1000</code> задать лимит обработки сообщений в минуту для коннектора</p>
<p><code>Get-OfflineAddressbook | Update-OfflineAddressbook</code> обновить OAB <br />
<code>Get-ClientAccessServer | Update-FileDistributionService</code></p>
<h2 id="pst"><a class="header" href="#pst">PST</a></h2>
<p><code>New-MailboxExportRequest -Mailbox $name -filepath "\\$srv\pst\$name.PST" # -ContentFilter {(Received -lt "01/01/2021")} -Priority Highest/Lower # -IsArchive</code> выполнить экспорт из архива пользователя <br />
<code>New-MailboxExportRequest -Mailbox $name -IncludeFolders "#Inbox#" -FilePath "\\$srv\pst\$name.PST"</code> только папку входящие <br />
<code>New-MailboxImportRequest -Mailbox $name "\\$srv\pst\$name.PST"</code> импорт из PST <br />
<code>Get-MailboxExportRequest</code> статус запросов <br />
<code>Get-MailboxExportRequest -Status Completed | Remove-MailboxExportRequest</code> удалить успешно завершенные запросы <br />
<code>Remove-MailboxExportRequest -RequestQueue MBXDB01 -RequestGuid 25e0eaf2-6cc2-4353-b83e-5cb7b72d441f</code> отменить экспорт</p>
<h2 id="distributiongroup"><a class="header" href="#distributiongroup">DistributionGroup</a></h2>
<p><code>Get-DistributionGroup</code> список групп рассылки <br />
<code>Get-DistributionGroupMember "!_Офис"</code> список пользователей в группе <br />
<code>Add-DistributionGroupMember -Identity "!_Офис" -Member "$name@$domain"</code> добавить в группу рассылки <br />
<code>Remove-DistributionGroupMember -Identity "!_Офис" -Member "$name@$domain"</code> <br />
<code>New-DistributionGroup -Name "!_Тест" -Members "$name@$domain"</code> создать группу <br />
<code>Set-DistributionGroup -Identity "support4" -HiddenFromAddressListsEnabled $true (или Set-Mailbox)</code> скрыть из списка адресов Exchange</p>
<h2 id="search"><a class="header" href="#search">Search</a></h2>
<p><code>Search-Mailbox -Identity "support4" -SearchQuery 'Тема:"Mikrotik DOWN"'</code> поиск писем по теме <br />
<code>Search-Mailbox -Identity "support4" -SearchQuery 'Subject:"Mikrotik DOWN"'</code><br />
<code>Search-Mailbox -Identity "support4" -SearchQuery 'attachment -like:"*.rar"'</code><br />
<code>Search-Mailbox -Identity "support4" -SearchQuery "отправлено: &lt; 01/01/2020" -DeleteContent -Force</code> удаление писем по дате</p>
<p>Формат даты в зависимости от региональных настроек сервера: <br />
<code>20/07/2018</code> <br />
<code>07/20/2018</code> <br />
<code>20-Jul-2018</code> <br />
<code>20/July/2018</code></p>
<h2 id="auditlog"><a class="header" href="#auditlog">AuditLog</a></h2>
<p><code>Get-AdminAuditLogConfig</code> настройки аудита <br />
<code>Set-Mailbox -Identity "support4" -AuditOwner HardDelete</code> добавить логирование HardDelete писем <br />
<code>Set-mailbox -identity "support4" -AuditlogAgelimit 120</code> указать время хранения <br />
<code>Get-mailbox -identity "support4" | Format-list Audit*</code> данные аудита <br />
<code>Search-MailboxAuditLog -Identity "support4" -LogonTypes Delegate -ShowDetails -Start "2022-02-22 18:00" -End "2022-03-22 18:00"</code> просмотр логов <br />
<code>Search-AdminAuditLog -StartDate "02/20/2022" | ft CmdLetName,Caller,RunDate,ObjectModified -Autosize</code> поиск событий истории выполненых команд в журнале аудита Exchange</p>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<p><code>Test-ServiceHealth</code> проверить доступность ролей сервера: почтовых ящиков, клиентского доступа, единой системы обмена сообщениями, траспортного сервера <br />
<code>$mx_srv_list | %{Test-MapiConnectivity -Server $_}</code> проверка подключения MX-серверов к БД <br />
<code>Test-MAPIConnectivity -Database $db</code> проверка возможности логина в базу <br />
<code>Test-MAPIConnectivity –Identity $user@$domain</code> проверка возможности логина в почтовый ящик <br />
<code>Test-ComputerSecureChannel</code> проверка работы службы AD <br />
<code>Test-MailFlow</code> результат тестового потока почты</p>
<h2 id="queue"><a class="header" href="#queue">Queue</a></h2>
<p><code>Get-TransportServer | %{Get-Queue -Server $_.Name}</code> отобразить очереди на всех транспортных серверах <br />
<code>Get-Queue -Identity EXCHANGE-CAS\155530 | Format-List</code> подробная информация об очереди <br />
<code>Get-Queue -Identity EXCHANGE-CAS\155530 | Get-Message -ResultSize Unlimited | Select FromAddress,Recipients</code> отобразить список отправителей (FromAddress) и список получателей в очереди (Recipients) <br />
<code>Get-Message -Queue EXCHANGE-CAS\155530</code> отобразить индентификатор сообщений в конкретной очереди (сервер\очередь\идентификатор письма) <br />
<code>Resume-Message EXCHANGE-CAS\155530\444010</code> повторить отправку письма из очереди <br />
<code>Retry-Queue -Filter {Status -eq "Retry"}</code> принудительно повторить отправку всех сообщений c статусом "Повторить" <br />
<code>Get-Queue -Identity EXCHANGE-CAS\155530 | Get-Message -ResultSize unlimited | Remove-Message -WithNDR $False</code> очистить очередь <br />
<code>Get-transportserver EXCHANGE-CAS | Select MessageExpirationTimeout</code> отобразить время жизни сообщений в очереди (по умолчанию, 2 дня)</p>
<p>Error Exchange 452 4.3.1 Insufficient system resources - окончание свободного места на диске, на котором находятся очереди службы Exchange Hub Transport, за мониторинг отвечает компонент доступных ресурсов Back Pressure, который в том числе отслеживает свободное место на диске <br />
Порог Medium (90%) — перестать принимать по SMTP почту от внешних отправителей (почта от MAPI клиентов при этом обрабатывается) <br />
Порог High (99%) — обработка потока почты полностью прекращается <br />
Решение: очистить, например логи IIS (C:\inetpub\logs\LogFiles\W3SVC1), увеличить размер диска, отключить мониторинг Back Pressure (плохой вариант) или перенести транспортные очередь на другой диск достаточного объёма.</p>
<p><code>Get-Service | ? name -like "MSExchangeTransport" | Stop-Service</code> остановить служу очереди <br />
<code>Rename-Item "C:\Program Files\Microsoft\Exchange Server\V15\TransportRoles\data\Queue" "C:\Program Files\Microsoft\Exchange Server\V15\TransportRoles\data\Queue_old"</code> очистить базу очереди <br />
<code>C:\Program Files\Microsoft\Exchange Server\V15\Bin\EdgeTransport.exe.config</code> конфигурационный файл, который содержит путь к бд с очередью (блок <appSettings> ключи <add key="QueueDatabasePath" value="$new_path" /> и QueueDatabaseLoggingPath) <br />
Для переноса БД, необходимо переместить существующие файлы базы данных Mail.que и Trn.chk (контрольные точки для отслеживания записи в логах) из исходного местоположения в новое. Переместите существующие файлы журнала транзакций Trn.log, Trntmp.log, Trn nnnn.log , Trnres00001.jrs, Trnres00002.jrs и Temp.edb из старого расположения в новое. tmp.edb — временный файл для проверки схемы самой базы, перености не нужно. <br />
После запуска службы транспорта удалить старую базу данных очереди и файлы журнала транзакций из старого расположения.</p>
<h2 id="defrag"><a class="header" href="#defrag">Defrag</a></h2>
<p><code>Get-MailboxDatabase -Status | ft Name, DatabaseSize, AvailableNewMailboxSpace</code> <br />
DatabaseSize - текущий размер базы <br />
AvailableNewMailboxSpace - объём пустых страниц, пространство, которое можно освободить при дефрагментации <br />
(DatabaseSize — AvailableNewMailboxSpace) x 1,1 - необходимо дополнительно иметь свободного места не менее 110% от текущего размера базы (без учета пустых страниц) <br />
<code>cd $path</code> <br />
<code>Dismount-Database "$path\$db_name"</code> отмонтировать БД <br />
<code>eseutil /d "$path\$db_name.edb"</code> <br />
<code>Mount-Database "$path\$db"</code> примонтировать БД</p>
<h2 id="dag-database-availability-group"><a class="header" href="#dag-database-availability-group">DAG (Database Availability Group)</a></h2>
<p><code>Install-WindowsFeature -Name Failover-Clustering -ComputerName EXCH-MX-01</code> основывается на технологии Windows Server Failover Cluster <br />
<code>New-DatabaseAvailabilityGroup -Name dag-01 -WitnessServer fs-05 -WitnessDirectory C:\witness_exchange1</code> создать группу с указанием файлового свидетеля для кворума <br />
Quorum - это процесс голосования, в котором для принятия решения нужно иметь большинство голосов, что бы сделать текущую копию базы данных активной. <br />
WitnessDirectory — используется для хранения данных файлового ресурса-свидетеля. <br />
<code>Set-DatabaseAvailabilityGroup dag-01 –DatabaseAvailabilityGroupIPAdress $ip</code> изменить ip-адрес группы <br />
<code>Get-DatabaseAvailabilityGroup</code> список всех групп <br />
<code>Get-DatabaseAvailabilityGroup -Identity dag-01</code> <br />
<code>Add-DatabaseAvailabilityGroupServer -Identity dag-01 -MailboxServer EXCH-MX-01</code> добавить первый сервер (все БД на серверах в DAG должны храниться по одинаковому пути) <br />
<code>Add-MailboxDatabaseCopy -Identity db_name -MailboxServer EXCH-MX-04</code> добавить копию БД <br />
<code>Get-MailboxDatabaseCopyStatus -Identity db_name\* | select Name,Status,LastInspectedLogTime</code> статус и время последнего копирования журнала транзакий</p>
<p>Status: <br />
Mounted - рабочая база <br />
Suspended - приостановлено копирование <br />
Healthy - рабочая пассивная копия <br />
ServiceDown - недоступна (выключен сервер) <br />
Dismounted - отмонтирована <br />
FailedAndSuspended - ошибка и приостановка копирования <br />
Resynchronizing - процесс синхронизация, где будет постепенно уменьшаться длина очереди <br />
CopyQueue Length - длина репликационной очереди копирования (0 - значит все изменения из активной базы реплицированы в пассивную копию)</p>
<p><code>Resume-MailboxDatabaseCopy -Identity db_name\EXCH-MX-04</code> возобновить (Resume) или запустить копирование бд на EXCH-MX-04 (из статуса Suspended в Healthy) <br />
<code>Suspend-MailboxDatabaseCopy -Identity db_name\EXCH-MX-04</code> остановить копирование (в статус Suspended) <br />
<code>Update-MailboxDatabaseCopy -Identity db_name\EXCH-MX-04 -DeleteExistingFiles</code> обновить копию БД (сделать Full Backup) <br />
<code>Set-MailboxDatabaseCopy -Identity db_name\EXCH-MX-04 -ActivationPreference 1</code> изменить приоритет для активации копий БД (какую использовать, 1 – самое высокое значение) <br />
<code>Move-ActiveMailboxDatabase db_name -ActivateOnServer EXCH-MX-04 -MountDialOverride:None -Confirm:$false</code> включить копию БД в DAG (переключиться на активную копию) <br />
<code>Remove-MailboxDatabaseCopy -Identity db_name\EXCH-MX-04 -Confirm:$False</code> удалить копии пассивной базы в DAG-группе (у БД должно быть отключено ведение циклического журнала) <br />
<code>Remove-DatabaseAvailabilityGroupServer -Identity dag-01 -MailboxServer EXCH-MX-04 -ConfigurationOnly</code> удалить MX сервер из группы DAG <br />
<code>Import-Module FailoverClusters</code> <br />
<code>Get-ClusterNode EXCH-MX-04 | Remove-ClusterNode -Force</code> удалить отказавший узел из Windows Failover Cluster</p>
<p><code>Get-DatabaseAvailabilityGroup | Get-DatabaseAvailabilityGroupHealth</code> мониторинг</p>
<h2 id="index-1"><a class="header" href="#index-1">Index</a></h2>
<p><code>Get-MailboxDatabaseCopyStatus * | select name,status,ContentIndexState,ContentIndexErrorMessage,ActiveDatabaseCopy,LatestCopyBackupTime,CopyQueueLength</code> узнать состояние работы индксов БД и текст ошибки, на каком сервере активная копия БД, дата последней копии и текущая очередь <br />
<code>Get-MailboxDatabaseCopyStatus -Identity $db_name\* | Format-List Name,ContentIndexState</code> отобразить список всех копий конкретной БД на всех серверах, и статус их индексов, если у второго сервера статус Healthy, можно восстановить из него <br />
<code>Get-MailboxDatabaseCopyStatus -Identity $db_name\EXCH-MX-04 | Update-MailboxDatabaseCopy -SourceServer EXCH-MX-01 -CatalogOnly</code> восстановить БД из копии <br />
<code>cd %PROGRAMFILES%\Microsoft\Exchange Server\V14\Scripts</code> или v15 для Exchange 2016 <br />
<code>.\ResetSearchIndex.ps1 $db_name</code> скрипт восстановления индекса</p>
<p><code>Get-MailboxDatabaseCopyStatus * | where {$_.ContentIndexState -eq "Failed" -or $_.ContentIndexState -eq "FailedAndSuspended"}</code> отобразить у какой БД произошел сбой работы (FailedAndSuspended) или индекса (ContentIndexState)</p>
<h1 id="servermanager"><a class="header" href="#servermanager">ServerManager</a></h1>
<p><code>Get-Command *WindowsFeature*</code> source module ServerManager <br />
<code>Get-WindowsFeature -ComputerName "localhost"</code> <br />
<code>Get-WindowsFeature | where Installed -eq $True</code> список установленных ролей и компонентов <br />
<code>Get-WindowsFeature | where FeatureType -eq "Role"</code> отсортировать по списку ролей <br />
<code>Install-WindowsFeature -Name DNS</code> установить роль <br />
<code>Get-Command *DNS*</code> <br />
<code>Get-DnsServerSetting -ALL</code> <br />
<code>Uninstall-WindowsFeature -Name DNS</code> удалить роль</p>
<h2 id="pswa"><a class="header" href="#pswa">PSWA</a></h2>
<p><code>Install-WindowsFeature -Name WindowsPowerShellWebAccess -IncludeManagementTools</code> <br />
<code>Install-PswaWebApplication -UseTestCertificate</code> Создать веб-приложение /pswa <br />
<code>Add-PswaAuthorizationRule -UserGroupName "$domain\Domain Admins" -ComputerName * -ConfigurationName * -RuleName "For Admins"</code> добавить права авторизации</p>
<h2 id="wsb-windows-server-backup"><a class="header" href="#wsb-windows-server-backup">WSB (Windows Server Backup)</a></h2>
<p>При создании backup DC через WSB, создается копия состояния системы (System State), куда попадает база AD (NTDS.DIT), объекты групповых политик, содержимое каталога SYSVOL, реестр, метаданные IIS, база AD CS, и другие системные файлы и ресурсы. Резервная копия создается через службу теневого копирования VSS. <br />
<code>Get-WindowsFeature Windows-Server-Backup</code> проверить установлена ли роль <br />
<code>Add-Windowsfeature Windows-Server-Backup –Includeallsubfeature</code> установить роль</p>
<pre><code class="language-PowerShell">$path="\\$srv\bak-dc\dc-03\"
[string]$TargetUNC=$path+(get-date -f 'yyyy-MM-dd')
if ((Test-Path -Path $path) -eq $true) {New-Item -Path $TargetUNC -ItemType directory} # если путь доступен, создать новую директорию по дате
$WBadmin_cmd = "wbadmin.exe START BACKUP -backupTarget:$TargetUNC -systemState -noverify -vssCopy -quiet"
# $WBadmin_cmd = "wbadmin start backup -backuptarget:$path -include:C:\Windows\NTDS\ntds.dit -quiet" # Backup DB NTDS
Invoke-Expression $WBadmin_cmd
</code></pre>
<h2 id="rds"><a class="header" href="#rds">RDS</a></h2>
<p><code>Get-Command -Module RemoteDesktop</code> <br />
<code>Get-RDServer -ConnectionBroker $broker</code> список всех серверов в фермеы, указывается полное доменное имя при обращение к серверу с ролью RDCB <br />
<code>Get-RDRemoteDesktop -ConnectionBroker $broker</code> список коллекций <br />
<code>(Get-RDLicenseConfiguration -ConnectionBroker $broker | select *).LicenseServer</code> список серверов с ролью RDL <br />
<code>Get-RDUserSession -ConnectionBroker $broker</code> список всех активных пользователей <br />
<code>Disconnect-RDUser -HostServer $srv -UnifiedSessionID $id -Force</code> отключить сессию пользователя <br />
<code>Get-RDAvailableApp -ConnectionBroker $broker -CollectionName C03</code> список установленного ПО на серверах в коллекции <br />
<code>(Get-RDSessionCollectionConfiguration -ConnectionBroker $broker -CollectionName C03 | select *).CustomRdpProperty</code> use redirection server name:i:1 <br />
<code>Get-RDConnectionBrokerHighAvailability</code></p>
<h1 id="dnsserver"><a class="header" href="#dnsserver">DNSServer</a></h1>
<p><code>Get-Command -Module DnsServer</code> <br />
<code>Show-DnsServerCache</code> отобразить весь кэш DNS-сервера <br />
<code>Show-DnsServerCache | where HostName -match ru</code> <br />
<code>Clear-DnsServerCache</code> <br />
<code>Get-DnsServerCache</code> <br />
<code>Get-DnsServerDiagnostics</code></p>
<pre><code class="language-PowerShell">$zone = icm $srv {Get-DnsServerZone} | select ZoneName,ZoneType,DynamicUpdate,ReplicationScope,SecureSecondaries,
DirectoryPartitionName | Out-GridView -Title "DNS Server: $srv" –PassThru
$zone_name = $zone.ZoneName
if ($zone_name -ne $null) {
    icm $srv {
        Get-DnsServerResourceRecord -ZoneName $using:zone_name | sort RecordType | select RecordType,HostName, @{
        Label="IPAddress"; Expression={$_.RecordData.IPv4Address.IPAddressToString}},TimeToLive,Timestamp
    } | select RecordType,HostName,IPAddress,TimeToLive,Timestamp | Out-GridView -Title "DNS Server: $srv"
}
</code></pre>
<p><code>Sync-DnsServerZone –passthru</code> синхронизировать зоны с другими DC в домене <br />
<code>Remove-DnsServerZone -Name domain.local</code> удалить зону <br />
<code>Get-DnsServerResourceRecord -ZoneName domain.local -RRType A</code> вывести все А-записи в указанной зоне <br />
<code>Add-DnsServerResourceRecordA -Name new-host-name -IPv4Address 192.168.1.100 -ZoneName domain.local -TimeToLive 01:00:00 -CreatePtr</code> создать А-запись и PTR для нее <br />
<code>Remove-DnsServerResourceRecord -ZoneName domain.local -RRType A -Name new-host-name –Force</code> удалить А-запись</p>
<pre><code class="language-PowerShell">$DNSServer = "DC-01"
$DNSFZone = "domain.com"
$DataFile = "C:\Scripts\DNS-Create-A-Records-from-File.csv"
# cat $DataFile
# "HostName;IP"
# "server-01;192.168.1.10"
$DNSRR = [WmiClass]"\\$DNSServer\root\MicrosoftDNS:MicrosoftDNS_ResourceRecord"
$ConvFile = $DataFile + "_unicode"
Get-Content $DataFile | Set-Content $ConvFile -Encoding Unicode
Import-CSV $ConvFile -Delimiter ";" | ForEach-Object {
    $FQDN = $_.HostName + "." + $DNSFZone
    $IP = $_.HostIP
    $TextA = "$FQDN IN A $IP"
    [Void]$DNSRR.CreateInstanceFromTextRepresentation($DNSServer,$DNSFZone,$TextA)
}
</code></pre>
<h1 id="dhcpserver"><a class="header" href="#dhcpserver">DHCPServer</a></h1>
<p><code>Get-Command -Module DhcpServer</code></p>
<pre><code class="language-PowerShell">$mac = icm $srv -ScriptBlock {Get-DhcpServerv4Scope | Get-DhcpServerv4Lease} | select AddressState,
HostName,IPAddress,ClientId,DnsRegistration,DnsRR,ScopeId,ServerIP | Out-GridView -Title "HDCP Server: $srv" –PassThru
(New-Object -ComObject Wscript.Shell).Popup($mac.ClientId,0,$mac.HostName,64)
</code></pre>
<p><code>Add-DhcpServerv4Reservation -ScopeId 192.168.1.0 -IPAddress 192.168.1.10 -ClientId 00-50-56-C0-00-08 -Description "new reservation"</code></p>
<h1 id="dfs"><a class="header" href="#dfs">DFS</a></h1>
<p><code>dfsutil /root:\\domain.sys\public /export:C:\export-dfs.txt</code> экспорт конфигурации namespace root <br />
<code>dfsutil /AddFtRoot /Server:\\$srv /Share:public</code> на новой машине предварительно создать корень на основе домена <br />
<code>dfsutil /root:\\domain.sys\public /import:C:\export-dfs.txt /&lt;verify /set</code> Import (перед импортом данных в существующий корень DFS, утилита создает резервную копию конфигурации корня в текущем каталоге, из которого запускается утилита dfsutil) <br />
<code>/verify</code> выводит изменения, которые будут внесены в процессе импорта, без применения <br />
<code>/set</code> меняет целевое пространство имен путем полной перезаписи и замены на конфигурацию пространства имен из импортируемого файла <br />
<code>/merge</code> импортирует конфигурацию пространства имен в дополнение к существующей конфигурации для слияния, параметры из файла конфигурации будут иметь больший приоритет, чем существующие параметры пространства имен</p>
<p><code>Export-DfsrClone</code> экспортирует клонированную базу данных репликации DFS и параметры конфигурации тома <br />
<code>Get-DfsrCloneState</code> получает состояние операции клонирования базы данных <br />
<code>Import-DfsrClone</code> импортирует клонированную базу данных репликации DFS и параметры конфигурации тома</p>
<p><code>net use x: \\$srv1\public\*</code> примонтировать диск <br />
<code>Get-DfsrFileHash x:\* | Out-File C:\$srv1.txt</code> забрать hash всех файлов диска в файл (файлы с одинаковыми хешами всегда являются точными копиями друг друга) <br />
<code>net use x: /d</code> отмонтировать <br />
<code>net use x: \\$srv2\public\*</code> <br />
<code>Get-DfsrFileHash x:\* | Out-File C:\$srv2.txt</code> <br />
<code>net use x: /d</code> <br />
<code>Compare-Object -ReferenceObject (Get-Content C:\$srv1.txt) -DifferenceObject (Get-Content C:\$srv2.txt) -IncludeEqual</code> сравнить содержимое файлов</p>
<p><code>Get-DfsrBacklog -DestinationComputerName "fs-06" -SourceComputerName "fs-05" -GroupName "folder-rep" -FolderName "folder" -Verbose</code> получает список ожидающих обновлений файлов между двумя партнерами репликации DFS <br />
<code>Get-DfsrConnection</code> отображает группы репликации, участников и статус <br />
<code>Get-DfsReplicatedFolder</code> отображает имя и полный путь к папкам реликации в системе DFS <br />
<code>Get-DfsrState -ComputerName fs-06 -Verbose</code> состояние репликации DFS для члена группы <br />
<code>Get-DfsReplicationGroup</code> отображает группы репликации и их статус <br />
<code>Add-DfsrConnection</code> создает соединение между членами группы репликации <br />
<code>Add-DfsrMember</code> добавляет компьютеры в группу репликации <br />
<code>ConvertFrom-DfsrGuid</code> преобразует идентификаторы GUID в понятные имена в заданной группы репликации <br />
<code>Get-DfsrConnectionSchedule</code> получает расписание соединений между членами группы репликации <br />
<code>Get-DfsrGroupSchedule</code> извлекает расписание группы репликации <br />
<code>Get-DfsrIdRecord</code> получает записи ID для реплицированных файлов или папок из базы данных репликации DFS <br />
<code>Get-DfsrMember</code> получает компьютеры в группе репликации <br />
<code>Get-DfsrMembership</code> получает параметры членства для членов групп репликации <br />
<code>Get-DfsrPreservedFiles</code> получает список файлов и папок, ранее сохраненных репликацией DFS <br />
<code>Get-DfsrServiceConfiguration</code> получает параметры службы репликации DFS для членов группы <br />
<code>Grant-DfsrDelegation</code> предоставляет разрешения участникам безопасности для группы репликации <br />
<code>Revoke-DfsrDelegation</code> отменяет разрешения участников безопасности для группы репликации <br />
<code>New-DfsReplicationGroup</code> создает группу репликации <br />
<code>New-DfsReplicatedFolder</code> создает реплицированную папку в группе репликации <br />
<code>Remove-DfsrConnection</code> удаляет соединение между членами группы репликации <br />
<code>Remove-DfsReplicatedFolder</code> удаляет реплицированную папку из группы репликации <br />
<code>Remove-DfsReplicationGroup</code> удаляет группу репликации <br />
<code>Remove-DfsrMember</code> удаляет компьютеры из группы репликации <br />
<code>Restore-DfsrPreservedFiles</code> восстанавливает файлы и папки, ранее сохраненные репликацией DFS <br />
<code>Set-DfsrConnection</code> изменяет параметры соединения между членами группы репликации <br />
<code>Set-DfsrConnectionSchedule</code> изменяет параметры расписания соединений между членами группы репликации <br />
<code>Set-DfsReplicatedFolder</code> изменяет настройки реплицированной папки <br />
<code>Set-DfsReplicationGroup</code> изменяет группу репликации <br />
<code>Set-DfsrGroupSchedule</code> изменяет расписание группы репликации <br />
<code>Set-DfsrMember</code> изменяет информацию о компьютере-участнике в группе репликации <br />
<code>Set-DfsrMembership</code> настраивает параметры членства для членов группы репликации <br />
<code>Set-DfsrServiceConfiguration</code> изменяет параметры службы репликации DFS <br />
<code>Sync-DfsReplicationGroup</code> синхронизирует репликацию между компьютерами независимо от расписания <br />
<code>Suspend-DfsReplicationGroup</code> приостанавливает репликацию между компьютерами независимо от расписания <br />
<code>Update-DfsrConfigurationFromAD</code> инициирует обновление службы репликации DFS <br />
<code>Write-DfsrHealthReport</code> создает отчет о работоспособности репликации DFS <br />
<code>Write-DfsrPropagationReport</code> создает отчеты для тестовых файлов распространения в группе репликации <br />
<code>Start-DfsrPropagationTest</code> создает тестовый файл распространения в реплицированной папке</p>
<h1 id="storagereplica"><a class="header" href="#storagereplica">StorageReplica</a></h1>
<p><code>Install-WindowsFeature Storage-Replica –IncludeManagementTools -Restart</code> <br />
<code>Get-Command -Module StorageReplica</code> <br />
<code>Test-SRTopology</code> проверить соответствует ли сервер и канал связи технологии Storage Replica <br />
<code>New-SRPartnership -SourceComputerName srv-01 -SourceRGName srv-01-rep-group-01 -SourceVolumeName D: -SourceLogVolumeName L: -DestinationComputerName srv-02 -DestinationRGName srv-02-rep-group-01 -DestinationVolumeName D: -DestinationLogVolumeName L: -LogSizeInBytes 1GB</code> <br />
<code>Get-Counter -Counter "\Storage Replica Statistics(*)"</code> <br />
<code>Get-WinEvent -ProviderName Microsoft-Windows-StorageReplica -max 10</code> <br />
<code>Set-SRPartnership -ReplicationMode Asynchronous</code> переключить режим репликации на асинхронный <br />
<code>Set-SRPartnership -NewSourceComputerName srv-02 -SourceRGName srv-02-rep-group-01 -DestinationComputerName srv-01 -DestinationRGName srv-01-rep-group-01</code> изменить вручную направление репликации данных, переведя вторичную копию в онлайн режим (при выходе из строя основного сервера) <br />
<code>Get-SRGroup</code> информация о состояние группы реплизации <br />
<code>Get-SRPartnerShip</code> информация о направлении репликации <br />
<code>(Get-SRGroup).Replicas | Select-Object numofbytesremaining</code> проверить длину очереди копирования <br />
<code>Get-SRPartnership | Remove-SRPartnership</code> удалить реплизацию на основном сервере <br />
<code>Get-SRGroup | Remove-SRGroup</code> удалить реплизацию на обоих серверах</p>
<h1 id="smb-1"><a class="header" href="#smb-1">SMB</a></h1>
<p><code>Get-SmbServerConfiguration</code> <br />
<code>Set-SmbServerConfiguration -EnableSMB1Protocol $false -Force</code> отключить протокол SMB v1 <br />
<code>Get-WindowsFeature | Where-Object {$_.name -eq "FS-SMB1"} | ft Name,Installstate</code> модуль ServerManager, проверить установлен ли компонент SMB1 <br />
<code>Install-WindowsFeature FS-SMB1</code> установить SMB1 <br />
<code>Uninstall-WindowsFeature –Name FS-SMB1 –Remove</code> удалить SMB1 клиента (понадобится перезагрузка) <br />
<code>Get-WindowsOptionalFeature -Online</code> модуль DISM, для работы с компонентами Windows <br />
<code>Disable-WindowsOptionalFeature -Online -FeatureName SMB1Protocol -Remove</code> удалить SMB1 <br />
<code>Set-SmbServerConfiguration –AuditSmb1Access $true</code> включить аудит SMB1 <br />
<code>Get-SmbConnection</code> список активных сессий и используемая версия SMB (Dialect) <br />
<code>Get-SmbOpenFile | select ClientUserName,ClientComputerName,Path,SessionID</code> список открытых файлов <br />
<code>Get-SmbShare</code> список сетевых папок <br />
<code>New-SmbShare -Name xl-share -Path E:\test</code> создать новую общую сетевую папку (расшарить) <br />
<code>-EncryptData $True</code> включить шифрование SMB <br />
<code>-Description</code> имя в сетевом окружении <br />
<code>-ReadAccess "domain\username"</code> доступ на чтение <br />
<code>-ChangeAccess</code> доступ на запись <br />
<code>-FullAccess</code> полный доступ <br />
<code>-NoAccess ALL</code> нет прав <br />
<code>-FolderEnumerationMode [AccessBased | Unrestricted]</code> позволяет скрыть в сетевой папке объекты, на которых у пользователя нет доступа с помощью Access-Based Enumeration (ABE) <br />
<code>Get-SmbShare xl-share | Set-SmbShare -FolderEnumerationMode AccessBased</code> ключить ABE для всех расшаренных папок <br />
<code>Remove-SmbShare xl-share -force</code> удалить сетевой доступ (шару) <br />
<code>Get-SmbShareAccess xl-share</code> вывести список доступов безопасности к шаре <br />
<code>Revoke-SmbShareAccess xl-share -AccountName Everyone –Force</code> удалить группу из списка доступов <br />
<code>Grant-SmbShareAccess -Name xl-share -AccountName "domain\XL-Share" -AccessRight Change –force</code> изменить/добавить разрешения на запись (Full,Read) <br />
<code>Grant-SmbShareAccess -Name xl-share -AccountName "все" -AccessRight Change –force</code> <br />
<code>Block-SmbShareAccess -Name xl-share -AccountName "domain\noAccess" -Force</code> принудительный запрет <br />
<code>New-SmbMapping -LocalPath X: -RemotePath \\$srv\xl-share -UserName support4 -Password password –Persistent $true</code> подключить сетевой диск <br />
<code>-Persistent</code> восстановление соединения после отключения компьютера или сети <br />
<code>-SaveCredential</code> позволяет сохранить учетные данные пользователя для подключения в диспетчер учетных данных Windows Credential Manager <br />
<code>Stop-Process -Name "explorer" | Start-Process -FilePath "C:\Windows\explorer.exe"</code> перезапустить процесс для отображения в проводнике <br />
<code>Get-SmbMapping</code> список подключенных сетевых дисков <br />
<code>Remove-SmbMapping X: -force</code> отмонтировать сетевой диск <br />
<code>$CIMSession = New-CIMSession –Computername $srv</code> создать сеанс CIM (аудентификация на SMB) <br />
<code>Get-SmbOpenFile -CIMSession $CIMSession | select ClientUserName,ClientComputerName,Path | Out-GridView -PassThru | Close-SmbOpenFile -CIMSession $CIMSession -Confirm:$false –Force</code> закрыть файлы (открыть к ним сетевой доступ)</p>
<h2 id="get-acl"><a class="header" href="#get-acl">Get-Acl</a></h2>
<p><code>(Get-Acl \\$srv\xl-share).access</code> доступ ACL на уровне NTFS <br />
<code>Get-Acl C:\Drivers | Set-Acl C:\Distr</code> скопировать NTFS разрешения с одной папки и применить их на другую</p>
<h2 id="ntfssecurity"><a class="header" href="#ntfssecurity">NTFSSecurity</a></h2>
<p><code>Install-Module -Name NTFSSecurity -force</code> <br />
<code>Get-Item "\\$srv\xl-share" | Get-NTFSAccess</code> <br />
<code>Add-NTFSAccess -Path "\\$srv\xl-share" -Account "domain\xl-share" -AccessRights Fullcontrol -PassThru</code> добавить <br />
<code>Remove-NTFSAccess -Path "\\$srv\xl-share" -Account "domain\xl-share" -AccessRights FullControl -PassThru</code> удалить <br />
<code>Get-ChildItem -Path "\\$srv\xl-share" -Recurse -Force | Clear-NTFSAccess</code> удалить все разрешения, без удаления унаследованных разрешений <br />
<code>Get-ChildItem -Path "\\$srv\xl-share" -Recurse -Force | Enable-NTFSAccessInheritance</code> включить NTFS наследование для всех объектов в каталоге</p>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<p><code>Get-Command -Module Storage</code> <br />
<code>Get-Disk</code> список логических дисков <br />
<code>Get-Partition</code> отобразить разделы на всех дисках <br />
<code>Get-Volume</code> список логичких разделов <br />
<code>Get-PhysicalDisk</code> список физических дисков <br />
<code>Initialize-Disk 1 –PartitionStyle MBR</code> инициализировать диск <br />
<code>New-Partition -DriveLetter D –DiskNumber 1 -Size 500gb</code> создать раздел (выделить все место -UseMaximumSize) <br />
<code>Format-Volume -DriveLetter D -FileSystem NTFS -NewFileSystemLabel Disk-D</code> форматировать раздел <br />
<code>Set-Partition -DriveLetter D -IsActive $True</code> сделать активным <br />
<code>Remove-Partition -DriveLetter D –DiskNumber 1</code> удалить раздел <br />
<code>Clear-Disk -Number 1 -RemoveData</code> очистить диск <br />
<code>Repair-Volume –driveletter C –Scan</code> Check disk <br />
<code>Repair-Volume –driveletter C –SpotFix</code> <br />
<code>Repair-Volume –driverletter C -Scan –Cimsession $CIMSession</code></p>
<h2 id="iscsi"><a class="header" href="#iscsi">iSCSI</a></h2>
<p><code>New-IscsiVirtualDisk -Path D:\iSCSIVirtualDisks\iSCSI2.vhdx -Size 20GB</code> создать динамический vhdx-диск (для фиксированного размера -UseFixed) <br />
<code>New-IscsiServerTarget -TargetName iscsi-target-2 -InitiatorIds "IQN:iqn.1991-05.com.microsoft:srv3.contoso.com"</code> создать Target <br />
<code>Get-IscsiServerTarget | fl TargetName, LunMappings</code> <br />
<code>Connect-IscsiTarget -NodeAddress "iqn.1995-05.com.microsoft:srv2-iscsi-target-2-target" -IsPersistent $true</code> подключиться инициатором к таргету <br />
<code>Get-IscsiTarget | fl</code> <br />
<code>Disconnect-IscsiTarget -NodeAddress "iqn.1995-05.com.microsoft:srv2-iscsi-target-2-target" -Confirm:$false</code> отключиться</p>
<h1 id="wsus"><a class="header" href="#wsus">WSUS</a></h1>
<p><code>Get-Hotfix | Sort-Object -Descending  InstalledOn</code> список установленных обновлений (информация из cimv2) <br />
<code>Get-Hotfix -Description "Security update"</code> <br />
<code>Get-CimInstance Win32_QuickFixEngineering</code> <br />
<code>Get-Service uhssvc</code> служба Microsoft Health Update Tools, которая отвечает за предоставление обновлений</p>
<h2 id="windowsupdate"><a class="header" href="#windowsupdate">WindowsUpdate</a></h2>
<p><code>Get-Command -Module WindowsUpdate</code> <br />
<code>Get-WindowsUpdateLog</code> формирует отчет в $home\AppData\Local\Temp\WindowsUpdateLog в формате csv</p>
<h2 id="pswindowsupdate"><a class="header" href="#pswindowsupdate">PSWindowsUpdate</a></h2>
<p><code>Install-Module -Name PSWindowsUpdate -Scope CurrentUser</code> <br />
<code>Import-Module PSWindowsUpdate</code> <br />
<code>Get-Command -Module PSWindowsUpdate</code> <br />
<code>Get-WindowsUpdate</code> список обновлений для скачать и установить с сервера WSUS или Microsoft Update <br />
<code>Get-WindowsUpdate -Download</code> загрузить все обновления <br />
<code>Get-WindowsUpdate –Install</code> установить все обновления <br />
<code>Install-WindowsUpdate -MicrosoftUpdate -AcceptAll -IgnoreReboot</code> установить все обновления без перезагрузки <br />
<code>Get-WindowsUpdate -KBArticleID KB2267602, KB4533002 -Install</code> <br />
<code>Get-WindowsUpdate -KBArticleID KB2538243 -Hide</code> скрыть обновления, что бы они никогда не устанавливались <br />
<code>Get-WindowsUpdate –IsHidden</code> отобразить скрытые обновления (Hide-WindowsUpdate) <br />
<code>Remove-WindowsUpdate -KBArticleID KB4011634 -NoRestart</code> удалить обновление <br />
<code>Uninstall-WindowsUpdate</code> удалить обновление <br />
<code>Add-WUServiceManager</code> регистрация сервера обновления (Windows Update Service Manager) <br />
<code>Enable-WURemoting</code> включить правила Windows Defender, разрешающие удаленное использование командлета PSWindowsUpdate <br />
<code>Get-WUApiVersion</code> версия Windows Update Agent <br />
<code>Get-WUHistory</code> список всех установленных обновлений (история обновлений) <br />
<code>Get-WUHistory | Where-Object {$_.Title -match "KB4517389"}</code> поиск обновления <br />
<code>Get-WULastResults</code> даты последнего поиска и установки обновлений <br />
<code>Get-WURebootStatus</code> проверить, нужна ли перезагрузка для применения конкретного обновления <br />
<code>Get-WUServiceManager</code> выводит источники обновлений <br />
<code>Get-WUInstallerStatus</code> статус службы Windows Installer <br />
<code>Remove-WUServiceManager</code> отключить Windows Update Service Manager</p>
<h2 id="updateservices"><a class="header" href="#updateservices">UpdateServices</a></h2>
<p><code>Install-WindowsFeature -Name UpdateServices-RSAT</code> установить роль UpdateServices <br />
<code>$UpdateScope = New-Object Microsoft.UpdateServices.Administration.UpdateScope</code> <br />
<code>[enum]::GetValues([Microsoft.UpdateServices.Administration.ApprovedStates])</code> список утвержденных состояний <br />
<code>[enum]::GetValues([Microsoft.UpdateServices.Administration.UpdateInstallationStates])</code> статус установки (неизвестный, непригодный, не установлен, скачено, установлен, неуспешный, установлен и ожидает перезагрузки, все) <br />
<code>$UpdateScope.ApprovedStates = [Microsoft.UpdateServices.Administration.ApprovedStates]"NotApproved"</code> выставляем статус не утвержденных обновлений на сервере WSUS <br />
<code>$UpdateScope.IncludedInstallationStates = [Microsoft.UpdateServices.Administration.UpdateInstallationStates]"NotInstalled"</code> выставляем статус не установленных обновлений <br />
<code>$UpdateScope.IncludedInstallationStates = [Microsoft.UpdateServices.Administration.UpdateInstallationStates]"NotInstalled,Downloaded"</code> обновления загружены, но не установлены</p>
<h2 id="poshwsus"><a class="header" href="#poshwsus">PoshWSUS</a></h2>
<p><code>Install-Module -Name PoshWSUS</code> <br />
<code>Get-Command -Module PoshWSUS</code> нужны права администратора <br />
<code>Add-PSWSUSClientToGroup</code> добавление клиента в группу <br />
<code>Approve-PSWSUSUpdate</code> утверждение обновления <br />
<code>Connect-PSWSUSDatabaseServer</code> подключение к серверу базы данных WSUS <br />
<code>Connect-PSWSUSServer</code> подключение к серверу WSUS <br />
<code>Deny-PSWSUSUpdate</code> отклонение обновления <br />
<code>Disconnect-PSWSUSServer</code> отключение от сервера WSUS <br />
<code>Export-PSWSUSMetaData</code> экспорт метаданных WSUS <br />
<code>Get-PoshWSUSSyncUpdateCategories</code> получение категорий обновлений для синхронизации <br />
<code>Get-PoshWSUSSyncUpdateClassifications</code> получение классификаций обновлений для синхронизации <br />
<code>Get-PSWSUSCategory</code> получение категории WSUS <br />
<code>Get-PSWSUSChildServer</code> получение дочернего сервера WSUS <br />
<code>Get-PSWSUSClassification</code> получение классификации WSUS <br />
<code>Get-PSWSUSClient</code> получение информации о клиенте <br />
<code>Get-PSWSUSClientGroupMembership</code> получение групповой принадлежности клиента <br />
<code>Get-PSWSUSClientPerUpdate</code> получение информации о клиентах по обновлениям <br />
<code>Get-PSWSUSClientsInGroup</code> получение клиентов в группе <br />
<code>Get-PSWSUSCommand</code> получение информации о командах WSUS <br />
<code>Get-PSWSUSConfig</code> получение конфигурации WSUS <br />
<code>Get-PSWSUSConfigEnabledUpdateLanguages</code> получение включенных языков обновлений <br />
<code>Get-PSWSUSConfigProxyServer</code> получение конфигурации прокси-сервера <br />
<code>Get-PSWSUSConfigSupportedUpdateLanguages</code> получение поддерживаемых языков обновлений <br />
<code>Get-PSWSUSConfigSyncSchedule</code> получение расписания синхронизации <br />
<code>Get-PSWSUSConfigSyncUpdateCategories</code> получение категорий обновлений для синхронизации <br />
<code>Get-PSWSUSConfigSyncUpdateClassifications</code> получение классификаций обновлений для синхронизации <br />
<code>Get-PSWSUSConfigUpdateFiles</code> получение конфигурации файлов обновлений <br />
<code>Get-PSWSUSConfigUpdateSource</code> получение источника обновлений <br />
<code>Get-PSWSUSConfiguration</code> получение полной конфигурации WSUS <br />
<code>Get-PSWSUSContentDownloadProgress</code> получение прогресса загрузки контента <br />
<code>Get-PSWSUSCurrentUserRole</code> получение роли текущего пользователя <br />
<code>Get-PSWSUSDatabaseConfig</code> получение конфигурации базы данных <br />
<code>Get-PSWSUSDownstreamServer</code> получение конфигурации нижестоящего сервера <br />
<code>Get-PSWSUSEmailConfig</code> получение конфигурации электронной почты <br />
<code>Get-PSWSUSEnabledUpdateLanguages</code> получение включенных языков обновлений <br />
<code>Get-PSWSUSEvent</code> получение событий WSUS <br />
<code>Get-PSWSUSGroup</code> получение информации о группе <br />
<code>Get-PSWSUSInstallableItem</code> получение информации об установленных элементах <br />
<code>Get-PSWSUSInstallApprovalRule</code> получение правил утверждения установки <br />
<code>Get-PSWSUSProxyServer</code> получение информации о прокси-сервере <br />
<code>Get-PSWSUSServer</code> получение информации о сервере WSUS <br />
<code>Get-PSWSUSStatus</code> получение статуса WSUS <br />
<code>Get-PSWSUSSubscription</code> получение подписки WSUS <br />
<code>Get-PSWSUSSupportedUpdateLanguages</code> получение поддерживаемых языков обновлений <br />
<code>Get-PSWSUSSyncEvent</code> получение событий синхронизации <br />
<code>Get-PSWSUSSyncHistory</code> получение истории синхронизаций <br />
<code>Get-PSWSUSSyncProgress</code> получение прогресса синхронизации <br />
<code>Get-PSWSUSSyncSchedule</code> получение расписания синхронизации <br />
<code>Get-PSWSUSUpdate</code> получение информации об обновлении <br />
<code>Get-PSWSUSUpdateApproval</code> получение информации об утверждении обновлений <br />
<code>Get-PSWSUSUpdateCategory</code> получение категории обновлений <br />
<code>Get-PSWSUSUpdateClassification</code> получение классификации обновлений <br />
<code>Get-PSWSUSUpdateFile</code> получение файлов обновлений <br />
<code>Get-PSWSUSUpdateFiles</code> получение списка файлов обновлений <br />
<code>Get-PSWSUSUpdatePerClient</code> получение информации об обновлениях по клиентам <br />
<code>Get-PSWSUSUpdateSource</code> получение источника обновлений <br />
<code>Get-PSWSUSUpdateSummary</code> получение сводки по обновлениям <br />
<code>Get-PSWSUSUpdateSummaryPerClient</code> получение сводки по обновлениям для каждого клиента <br />
<code>Get-PSWSUSUpdateSummaryPerGroup</code> получение сводки по обновлениям для каждой группы <br />
<code>Import-PSWSUSMetaData</code> импорт метаданных WSUS <br />
<code>New-PSWSUSComputerScope</code> создание области охвата компьютеров <br />
<code>New-PSWSUSGroup</code> создание новой группы <br />
<code>New-PSWSUSInstallApprovalRule</code> создание правила утверждения установки <br />
<code>New-PSWSUSUpdateScope</code> создание области охвата обновлений <br />
<code>Remove-PSWSUSClient</code> удаление клиента <br />
<code>Remove-PSWSUSClientFromGroup</code> удаление клиента из группы <br />
<code>Remove-PSWSUSGroup</code> удаление группы <br />
<code>Remove-PSWSUSInstallApprovalRule</code> удаление правила утверждения установки <br />
<code>Remove-PSWSUSUpdate</code> удаление обновления <br />
<code>Reset-PSWSUSContent</code> сброс контента WSUS <br />
<code>Resume-PSWSUSDownload</code> возобновление загрузки <br />
<code>Resume-PSWSUSUpdateDownload</code> возобновление загрузки обновлений <br />
<code>Set-PoshWsusClassification</code> установка классификации WSUS <br />
<code>Set-PoshWSUSProduct</code> установка продукта WSUS <br />
<code>Set-PSWSUSConfigEnabledUpdateLanguages</code> установка включенных языков обновлений <br />
<code>Set-PSWSUSConfigProduct</code> установка продукта конфигурации WSUS <br />
<code>Set-PSWsusConfigProxyServer</code> установка прокси-сервера конфигурации WSUS <br />
<code>Set-PSWSUSConfigSyncSchedule</code> установка расписания синхронизации <br />
<code>Set-PSWSUSConfigTargetingMode</code> установка режима таргетирования <br />
<code>Set-PSWSUSConfigUpdateClassification</code> установка классификации обновлений <br />
<code>Set-PSWSUSConfigUpdateFiles</code> установка файлов обновлений <br />
<code>Set-PSWSUSConfigUpdateSource</code> установка источника обновлений <br />
<code>Set-PSWSUSEmailConfig</code> установка конфигурации электронной почты <br />
<code>Set-PSWSUSEnabledUpdateLanguages</code> установка включенных языков обновлений <br />
<code>Set-PSWSUSInstallApprovalRule</code> установка правила утверждения установки <br />
<code>Set-PSWSUSProxyServer</code> установка прокси-сервера <br />
<code>Set-PSWSUSSyncSchedule</code> установка расписания синхронизации <br />
<code>Set-PSWSUSTargetingMode</code> установка режима таргетирования <br />
<code>Set-PSWSUSUpdateFiles</code> установка файлов обновлений <br />
<code>Set-PSWSUSUpdateSource</code> установка источника обновлений <br />
<code>Start-PSWSUSCleanup</code> запуск очистки WSUS <br />
<code>Start-PSWSUSInstallApprovalRule</code> запуск правила утверждения установки <br />
<code>Start-PSWSUSSync</code> запуск синхронизации <br />
<code>Stop-PSWSUSDownload</code> остановка загрузки <br />
<code>Stop-PSWSUSSync</code> остановка синхронизации <br />
<code>Stop-PSWSUSUpdateDownload</code> остановка загрузки обновлений <br />
<code>Test-PSWSUSDatabaseServerConnection</code> тестирование подключения к серверу базы данных</p>
<h1 id="vmware"><a class="header" href="#vmware">VMWare</a></h1>
<p><code>Install-Module -Name VMware.PowerCLI # -AllowClobber</code> установить модуль (PackageProvider: nuget) <br />
<code>Get-Module -ListAvailable VMware* | Select Name,Version</code> <br />
<code>Import-Module VMware.VimAutomation.Core</code> импортировать в сессию <br />
<code>Get-PSProvider | format-list Name,PSSnapIn,ModuleName</code> список оснасток Windows PowerShell</p>
<p><code>Get-PowerCLIConfiguration</code> конфигурация подключения <br />
<code>Set-PowerCLIConfiguration -Scope AllUsers -InvalidCertificateAction ignore -confirm:$false</code> eсли используется самоподписанный сертификат, изменить значение параметра InvalidCertificateAction с Unset на Ignore/Warn <br />
<code>Set-PowerCLIConfiguration -Scope AllUsers -ParticipateInCeip $false</code> отключить уведомление сбора данных через VMware Customer Experience Improvement Program (CEIP)</p>
<p><code>Read-Host –AsSecureString | ConvertFrom-SecureString | Out-File "$home\Documents\vcsa_password.txt"</code> зашифровать пароль и сохранить в файл <br />
<code>$esxi = "vcsa.domain.local"</code> <br />
<code>$user = "administrator@vsphere.local"</code> <br />
<code>$pass = Get-Content "$home\Documents\vcsa_password.txt" | ConvertTo-SecureString</code> прочитать пароль <br />
<code>$pass = "password"</code> <br />
<code>$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $user ,$pass</code> <br />
<code>Connect-VIServer $esxi -User $Cred.Username -Password $Cred.GetNetworkCredential().password</code> подключиться, используя PSCredential ($Cred) <br />
<code>Connect-VIServer $esxi -User $user -Password $pass</code> подключиться, используя логин и пароль</p>
<p><code>Get-Command –Module *vmware*</code> отобразить список команд модуля VMware <br />
<code>Get-Command –Module *vmware* -name *get*iscsi*</code> найти команды модуля VMware, связанные с iSCSI <br />
<code>Get-IScsiHbaTarget</code> получить цели iSCSI HBA (Host Bus Adapter) <br />
<code>Get-Datacenter</code> получить список датацентров в инфраструктуре VMware <br />
<code>Get-Cluster</code> список кластеров <br />
<code>Get-VMHost</code> список хостов виртуальных машин (ESXi хостов) <br />
<code>Get-VMHost | Select-Object Name,Model,ProcessorType,MaxEVCMode,NumCpu,CpuTotalMhz,CpuUsageMhz,MemoryTotalGB,MemoryUsageGB</code> получить информацию о хостах виртуальных машин, включая имя, модель, тип процессора и использование ресурсов <br />
<code>Get-VMHostDisk | Select-Object VMHost,ScsiLun,TotalSectors</code> получить информацию о дисках хостов виртуальных машин, включая хост, SCSI LUN и общее количество секторов</p>
<p><code>Get-Datastore</code> список всех хранилищ данных <br />
<code>Get-Datastore TNAS-vmfs-4tb-01</code> получить информацию о хранилище данных с именем TNAS-vmfs-4tb-01 <br />
<code>Get-Datastore TNAS-vmfs-4tb-01 | get-vm</code> получить список виртуальных машин, которые используют хранилище данных <br />
<code>Get-Datastore -RelatedObject vm-01</code> получить информацию о хранилищах данных, связанных с виртуальной машиной <br />
<code>$(Get-Datastore TNAS-vmfs-4tb-01).ExtensionData.Info.GetType()</code> получить тип информации о хранилище данных <br />
<code>$(Get-Datastore TNAS-vmfs-4tb-01).ExtensionData.Info.Vmfs.Extent</code> получить информацию о том, на каких дисках находится хранилище данных</p>
<p><code>Get-Command –Module *vmware* -name *disk*</code> найти команды модуля VMware, связанные с дисками <br />
<code>Get-VM vm-01 | Get-Datastore</code> получить информацию о хранилищах данных, используемых виртуальной машиной <br />
<code>Get-VM vm-01 | Get-HardDisk</code> получить информацию о подключенных дисках к виртуальной машины <br />
<code>Get-VM | Get-HardDisk | select Parent,Name,CapacityGB,StorageFormat,FileName | ft</code> получить информацию о дисках всех виртуальных машин, включая родительскую ВМ, имя, емкость, формат и имя файла <br />
<code>Copy-HardDisk</code> скопировать жесткий диск виртуальной машины <br />
<code>Get-VM | Get-Snapshot</code> список всех снимков виртуальных машин <br />
<code>Get-VM | where {$_.Powerstate -eq "PoweredOn"}</code> список всех включенных виртуальных машин <br />
<code>Get-VMHost esxi-05 | Get-VM | where {$_.Powerstate -eq "PoweredOff"} | Move-VM –Destination (Get-VMHost esxi-06)</code> переместить все выключенные виртуальные машины с хоста esxi-05 на хост esxi-06</p>
<pre><code class="language-PowerShell">Get-VM | select Name,VMHost,PowerState,NumCpu,MemoryGB,
@{Name="UsedSpaceGB"; Expression={[int32]($_.UsedSpaceGB)}},
@{Name="ProvisionedSpaceGB"; Expression={[int32]($_.ProvisionedSpaceGB)}},
CreateDate,CpuHotAddEnabled,MemoryHotAddEnabled,CpuHotRemoveEnabled,Notes
</code></pre>
<p><code>Get-VMGuest vm-01 | Update-Tools</code> обновить VMware Tools на виртуальной машине vm-01 <br />
<code>Get-VMGuest vm-01 | select OSFullName,IPAddress,HostName,State,Disks,Nics,ToolsVersion</code> получить информацию о гостевой операционной системе виртуальной машины vm-01 (имя ОС, IP-адрес, имя хоста, состояние, диски, сетевые адаптеры и версию VMware Tools) <br />
<code>Get-VMGuest * | select -ExpandProperty IPAddress</code> получить IP-адреса всех гостевых ОС виртуальных машин <br />
<code>Restart-VMGuest -vm vm-01 -Confirm:$False</code> перезагрузить гостевую ОС виртуальной машины без запроса подтверждения <br />
<code>Start-VM -vm vm-01 -Confirm:$False</code> включить виртуальную машину без запроса подтверждения <br />
<code>Shutdown-VMGuest -vm vm-01 -Confirm:$false</code> выключить</p>
<p><code>New-VM –Name vm-01 -VMHost esxi-06 –ResourcePool Production –DiskGB 60 –DiskStorageFormat Thin –Datastore TNAS-vmfs-4tb-01</code> создать новую виртуальную машину vm-01 на хосте esxi-06 в пуле ресурсов Production с диском 60 ГБ в формате Thin и размещением на хранилище данных TNAS-vmfs-4tb-01</p>
<p><code>Get-VM vm-01 | Copy-VMGuestFile -Source "\\$srv\Install\Soft\Btest.exe" -Destination "C:\Install\" -LocalToGuest -GuestUser USER -GuestPassword PASS -force</code> Скопировать файл с хоста на гостевую ОС виртуальной машины vm-01 с принудительным выполнением</p>
<p><code>Get-VM -name vm-01 | Export-VApp -Destination C:\Install -Format OVF</code> экспортировать виртуальную машину vm-01 в шаблон OVF (.ovf, .vmdk, .mf) <br />
<code>Get-VM -name vm-01 | Export-VApp -Destination C:\Install -Format OVA</code> экспортировать виртуальную машину vm-01 в шаблон OVA</p>
<p><code>Get-VMHostNetworkAdapter | select VMHost,Name,Mac,IP,@{Label="Port Group"; Expression={$_.ExtensionData.Portgroup}} | ft</code> получить информацию о сетевых адаптерах хостов виртуальных машин, включая хост, имя, MAC-адрес, IP-адрес и портовую группу <br />
<code>Get-VM | Get-NetworkAdapter | select Parent,Name,Id,Type,MacAddress,ConnectionState,WakeOnLanEnabled | ft</code> получить информацию о сетевых адаптерах виртуальных машин, включая родительскую ВМ, имя, идентификатор, тип, MAC-адрес, состояние подключения и поддержку Wake-on-LAN</p>
<p><code>Get-Command –Module *vmware* -name *event*</code> <br />
<code>Get-VIEvent -MaxSamples 1000 | where {($_.FullFormattedMessage -match "power")} | select username,CreatedTime,FullFormattedMessage</code> получить последние 1000 событий, связанных с питанием, включая имя пользователя, время создания и полное сообщение <br />
<code>Get-logtype | select Key,SourceEntityId,Filename,Creator,Info</code> получить информацию о типах логов <br />
<code>$(Get-Log vpxd:vpxd.log).Entries | select -Last 50</code> получить последние 50 записей из лога vpxd</p>
<p><code>Get-Command –Module *vmware* -name *syslog*</code> <br />
<code>Set-VMHostSysLogServer -VMHost esxi-05 -SysLogServer "tcp://192.168.3.100" -SysLogServerPort 3515</code> установить сервер syslog сервер для хранения системных логов для хоста esxi-05 <br />
<code>Get-VMHostSysLogServer -VMHost esxi-05</code></p>
<h1 id="hyper-v"><a class="header" href="#hyper-v">Hyper-V</a></h1>
<p><code>Install-WindowsFeature -Name Hyper-V -IncludeManagementTools -Restart</code> установить роль на Windows Server <br />
<code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V –All</code> установить роль на Windows Desktop <br />
<code>Get-Command -Module hyper-v</code> <br />
<code>Get-VMHost</code></p>
<pre><code class="language-PowerShell">New-VMSwitch -name NAT -SwitchType Internal # создать виртуальный коммутатор и адаптер для него
Get-NetAdapter | where InterfaceDescription -match Hyper-V # список сетевых адаптеров
New-NetNat -Name LocalNat -InternalIPInterfaceAddressPrefix "192.168.3.0/24" # задать сеть
Get-NetAdapter "vEthernet (NAT)" | New-NetIPAddress -IPAddress 192.168.3.200 -AddressFamily IPv4 -PrefixLength 24 # присвоить адрес, необходимо на ВМ указать шлюз 192.168.3.200, что бы находиться за NAT, или в настройка ВМ указать соответствующий адаптер
Add-NetNatStaticMapping -NatName LocalNat -Protocol TCP -ExternalIPAddress 0.0.0.0 -ExternalPort 2222 -InternalIPAddress 192.168.3.103 -InternalPort 2121 # проброс, вест трафик который приходит на хост Hyper-V TCP/2222, будет перенаправляться на соответствующий порт виртуальной машины за NAT.
(Get-NetAdapter | where Name -match NAT).Status
</code></pre>
<p><code>Get-NetNatStaticMapping</code> отобразить пробросы (NAT) <br />
<code>Get-NetNat</code> список сетей <br />
<code>Remove-NetNatStaticMapping -StaticMappingID 0</code> удалить проброс <br />
<code>Remove-NetNat -Name LocalNat</code> удалить сеть</p>
<p><code>New-VMSwitch -Name Local -AllowManagementOS $True -NetAdapterName "Ethernet 4" -SwitchType External</code> создать вшений (External) виртуальный коммутатор</p>
<pre><code class="language-PowerShell">$VMName = "hv-dc-01"
$VM = @{
    Name = $VMName
    MemoryStartupBytes = 4Gb
    Generation = 2
    NewVHDPath = "D:\VM\$VMName\$VMName.vhdx"
    NewVHDSizeBytes = 50Gb
    BootDevice = "VHD"
    Path = "D:\VM\$VMName"
    SwitchName = "NAT"
}
</code></pre>
<p><code>New-VM @VM</code> создать виртуальную машину с параметрами</p>
<p><code>Set-VMDvdDrive -VMName $VMName -Path "C:\Users\Lifailon\Documents\WS-2016.iso"</code> примонтировать образ <br />
<code>New-VHD -Path "D:\VM\$VMName\disk_d.vhdx" -SizeBytes 10GB</code> создать VHDX диск <br />
<code>Add-VMHardDiskDrive -VMName $VMName -Path "D:\VM\$VMName\disk_d.vhdx"</code> примонтировать диск <br />
<code>Get-VM –VMname $VMName | Set-VM –AutomaticStartAction Start</code> автозапуск <br />
<code>Get-VM -Name $VMName | Set-VMMemory -StartupBytes 8Gb</code> назначить стартовый размер оперативной памяти при запуске <br />
<code>Set-VMProcessor $VMName -Count 2</code> количество виртуальных процессоров (vCPU: ядер/потоков) <br />
<code>Set-VMProcessor $VMName -Count 2 -Maximum 4 -Reserve 50 -RelativeWeight 200</code> указать максимальное количество выделяемых процессоров, резервируется 50% ресурсов процессора хоста и установить относительный вес 200 для приоритизации распределения ресурсов процессора относительно других виртуальных машин <br />
<code>Get-VM -Name $VMName | Checkpoint-VM -SnapshotName "Snapshot-1"</code> создать снапшот <br />
<code>Restore-VMCheckpoint -Name "Snapshot-1" -VMName $VMName -Confirm:$false</code> восстановление из снапшота <br />
<code>Get-VM | Select -ExpandProperty NetworkAdapters | Select VMName,IPAddresses,Status</code> получить IP адрес всех ВМ</p>
<h2 id="vmconnect-via-rdcman"><a class="header" href="#vmconnect-via-rdcman">VMConnect via RDCMan</a></h2>
<p><code>vmconnect.exe localhost $VMHost</code> подключиться к виртуальной машине через VMConnect (используется в диспетчере Hyper-V) <br />
<code>Get-NetTCPConnection -State Established,Listen | Where-Object LocalPort -Match 2179</code> найти порт слушателя  <br />
<code>Get-Process -Id (Get-NetTCPConnection -State Established,Listen | Where-Object LocalPort -Match 2179).OwningProcess</code> найти процесс по ID (vmms/VMConnect) <br />
<code>New-NetFirewallRule -Name "Hyper-V" -DisplayName "Hyper-V" -Group "Hyper-V" -Direction Inbound -Protocol TCP -LocalPort 2179 -Action Allow -Profile Public</code> открыть порт в локальном Firewall <br />
<code>Get-LocalGroupMember -Group "Администраторы Hyper-V"</code> <br />
<code>Get-LocalGroupMember -Group "Hyper-V Administrators"</code> <br />
<code>Add-LocalGroupMember -Group "Администраторы Hyper-V" -Member "lifailon"</code> добавить пользователя в группу администраторов (для возможности подключения) <br />
<code>Get-VM * | Select-Object Name,Id</code> добавить id в RDCMan для подключения <br />
<code>Grant-VMConnectAccess -ComputerName plex-01 -VMName hv-devops-01 -UserName lifailon</code> дать доступ на подключение не администратору <br />
<code>Get-VMConnectAccess</code> <br />
<code>Revoke-VMConnectAccess -VMName hv-devops-01 -UserName lifailon</code> забрать доступ</p>
<p>Error: <code>Unknown disconnection reason 3848</code> - добавить ключи реестра на стороне клиента</p>
<pre><code class="language-PowerShell">New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\Credssp\PolicyDefaults\AllowFreshCredentialsDomain -Name Hyper-V -PropertyType String -Value "Microsoft Virtual Console Service/*" -Force
New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\Credssp\PolicyDefaults\AllowDefaultCredentials -Name Hyper-V -PropertyType String -Value "Microsoft Virtual Console Service/*" -Force
New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\Credssp\PolicyDefaults\AllowFreshCredentialsWhenNTLMOnlyDomain -Name Hyper-V -PropertyType String -Value "Microsoft Virtual Console Service/*" -Force
ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\Credssp\PolicyDefaults\AllowDefaultCredentialsDomain -Name Hyper-V -PropertyType String -Value "Microsoft Virtual Console Service/*" -Force
New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\Credssp\PolicyDefaults\AllowFreshCredentials -Name Hyper-V -PropertyType String -Value "Microsoft Virtual Console Service/*" -Force
New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\Credssp\PolicyDefaults\AllowFreshCredentialsWhenNTLMOnly -Name Hyper-V -PropertyType String -Value "Microsoft Virtual Console Service/*" -Force
New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\Credssp\PolicyDefaults\AllowSavedCredentialsWhenNTLMOnly -Name Hyper-V -PropertyType String -Value "Microsoft Virtual Console Service/*" -Force
New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\Credssp\PolicyDefaults\AllowSavedCredentials -Name Hyper-V -PropertyType String -Value "Microsoft Virtual Console Service/*" -Force
New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\Credssp\PolicyDefaults\AllowSavedCredentialsDomain -Name Hyper-V -PropertyType String -Value "Microsoft Virtual Console Service/*" -Force
</code></pre>
<h1 id="azure"><a class="header" href="#azure">Azure</a></h1>
<p><code>Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force</code> установить все модули для работы с Azure <br />
<code>Get-Module *Az.*</code> список всех модулей</p>
<p><code>Get-Command -Module Az.Accounts</code> отобразить список команд модуля Az.Accounts <br />
<code>Connect-AzAccount</code> подключиться у учетной записи Azure <br />
<code>Get-AzContext</code> получить текущий статус подключения к Azure <br />
<code>Get-AzSubscription</code> получить список подписок Azure, доступных для текущего пользователя <br />
<code>Set-AzContext</code> установить контекст Azure для конкретной подписки и/или учетной записи <br />
<code>Disconnect-AzAccount</code> отключиться от учетной записи Azure</p>
<p><code>Get-Command -Module Az.Compute</code> <br />
<code>Get-AzVM</code> получить список виртуальных машин в текущей подписке или группе ресурсов <br />
<code>Get-AzVMSize</code> получить список доступных размеров виртуальных машин в определенном регионе <br />
<code>Get-AzVMImage</code> получить список доступных образов виртуальных машин <br />
<code>New-AzVM</code> создать новую виртуальную машину <br />
<code>Remove-AzVM</code> удалить виртуальную машину <br />
<code>Start-AzVM</code> запустить виртуальную машину <br />
<code>Stop-AzVM</code> остановить виртуальную машину <br />
<code>Restart-AzVM</code> перезагрузить виртуальную машину</p>
<p><code>Get-Command -Module Az.Network</code> <br />
<code>Get-AzVirtualNetwork</code> получить список виртуальных сетей в текущей подписке или группе ресурсов <br />
<code>New-AzVirtualNetwork</code> создать новую виртуальную сеть <br />
<code>Remove-AzVirtualNetwork</code> удалить виртуальную сеть <br />
<code>Get-AzNetworkInterface</code> получить список сетевых интерфейсов <br />
<code>New-AzNetworkInterface</code> создать новый сетевой интерфейс <br />
<code>Remove-AzNetworkInterface</code> удалить сетевой интерфейс</p>
<p><code>Get-Command -Module Az.Storage</code> <br />
<code>Get-AzStorageAccount</code> получить список учетных записей хранилища <br />
<code>New-AzStorageAccount</code> создать новую учетную запись хранилища <br />
<code>Remove-AzStorageAccount</code> удалить учетную запись хранилища <br />
<code>Get-AzStorageContainer</code> список контейнеров в учетной записи хранилища <br />
<code>New-AzStorageContainer</code> создать новый контейнер в учетной записи хранилища <br />
<code>Remove-AzStorageContainer</code> удалить контейнер</p>
<p><code>Get-Command -Module Az.ResourceManager</code> <br />
<code>Get-AzResourceGroup</code> получить список групп ресурсов в текущей подписке <br />
<code>New-AzResourceGroup</code> создать новую группу ресурсов <br />
<code>Remove-AzResourceGroup</code> удалить группу ресурсов <br />
<code>Get-AzResource</code> получить список ресурсов <br />
<code>New-AzResource</code> создать новый ресурс <br />
<code>Remove-AzResource</code> удалить ресурс</p>
<p><code>Get-Command -Module Az.KeyVault</code> <br />
<code>Get-AzKeyVault</code> список хранилищ ключей <br />
<code>New-AzKeyVault</code> создать новое хранилище ключей в Azure <br />
<code>Remove-AzKeyVault</code> удалить хранилище ключей в Azure</p>
<p><code>Get-Command -Module Az.Identity</code> <br />
<code>Get-AzADUser</code> получить информацию о пользователях Azure Active Directory <br />
<code>New-AzADUser</code> создать нового пользователя <br />
<code>Remove-AzADUser</code> удалить пользователя <br />
<code>Get-AzADGroup</code> получить информацию о группах <br />
<code>New-AzADGroup</code> создать новую группу <br />
<code>Remove-AzADGroup</code> удалить группу</p>
<h2 id="manage-vm"><a class="header" href="#manage-vm">Manage-VM</a></h2>
<p>Source: https://learn.microsoft.com/ru-ru/azure/virtual-machines/windows/tutorial-manage-vm</p>
<p><code>New-AzResourceGroup -Name "Resource-Group-01" -Location "EastUS"</code> создать группу ресурсов (логический контейнер, в котором происходит развертывание ресурсов Azure) <br />
<code>Get-AzVMImageOffer -Location "EastUS" -PublisherName "MicrosoftWindowsServer"</code> список доступных образов Windows Server для установки <br />
<code>$cred = Get-Credential</code> <br />
<code>New-AzVm -ResourceGroupName "Resource-Group-01" -Name "vm-01" -Location 'EastUS' -Image "MicrosoftWindowsServer:WindowsServer:2022-datacenter-azure-edition:latest" -Size "Standard_D2s_v3" -OpenPorts 80,3389 --Credential $cred</code> создать виртуальную машину <br />
<code>Get-AzVM -ResourceGroupName "Resource-Group-01" -Name "vm-01" -Status | Select @{n="Status"; e={$_.Statuses[1].Code}}</code> статус виртуальной машины <br />
<code>Start-AzVM -ResourceGroupName "Resource-Group-01" -Name "vm-01"</code> запустить виртуальную машину <br />
<code>Stop-AzVM -ResourceGroupName "Resource-Group-01" -Name "vm-01" -Force</code> остановить виртуальную машину <br />
<code>Invoke-AzVMRunCommand -ResourceGroupName "Resource-Group-01" -VMName "vm-01" -CommandId "RunPowerShellScript" -ScriptString "Install-WindowsFeature -Name Web-Server -IncludeManagementTools"</code> установить роль веб-сервера IIS</p>
<h2 id="manage-disk"><a class="header" href="#manage-disk">Manage-Disk</a></h2>
<p>Source: https://learn.microsoft.com/ru-ru/azure/virtual-machines/windows/tutorial-manage-data-disk</p>
<p><code>$diskConfig = New-AzDiskConfig -Location "EastUS" -CreateOption Empty -DiskSizeGB 512 -SkuName "Standard_LRS"</code> создать диск на 512 Гб <br />
<code>$dataDisk = New-AzDisk -ResourceGroupName "Resource-Group-01" -DiskName "disk-512" -Disk $diskConfig</code> создание объекта диска для подготовки диска данных к работе <br />
<code>Get-AzDisk -ResourceGroupName "Resource-Group-01" -DiskName "disk-512"</code> список дисков <br />
<code>$vm = Get-AzVM -ResourceGroupName "Resource-Group-01" -Name "vm-01"</code> <br />
<code>Add-AzVMDataDisk -VM $vm -Name "Resource-Group-01" -CreateOption Attach -ManagedDiskId $dataDisk.Id -Lun 1</code> подключить диск к виртуальной машине <br />
<code>Update-AzVM -ResourceGroupName "Resource-Group-01" -VM $vm</code> обновить конфигурацию виртуальной машины <br />
<code>Get-Disk | Where PartitionStyle -eq 'raw' | Initialize-Disk -PartitionStyle MBR -PassThru | New-Partition -AssignDriveLetter -UseMaximumSize | Format-Volume -FileSystem NTFS -NewFileSystemLabel "disk-512" -Confirm:$false</code> инициализировать диск в ОС (необходимо подключиться к виртуальной машине) с таблицей MBR, создать раздел и назначить все пространство и форматировать в файловую систему NTFS</p>
<h1 id="nas"><a class="header" href="#nas">NAS</a></h1>
<h2 id="truenas"><a class="header" href="#truenas">TrueNAS</a></h2>
<p>Module: <a href="https://github.com/PowerTrueNas/TrueNas">PowerTrueNas</a></p>
<p><code>Install-Module TrueNas</code> <br />
<code>Import-Module TrueNas</code> <br />
<code>$(Get-Module TrueNas).ExportedCommands</code> <br />
<code>Connect-TrueNasServer -Server tnas-01 -SkipCertificateCheck</code> <br />
<code>Get-TrueNasCertificate</code> настройки сертификата <br />
<code>Get-TrueNasSetting</code> настройки языка, time zone, syslog level и server, https port <br />
<code>Get-TrueNasUser</code> список пользователей <br />
<code>Get-TrueNasSystemVersion</code> характеристики (Physical Memory, Model, Cores) и Uptime <br />
<code>Get-TrueNasSystemAlert</code> snmp для оповещений <br />
<code>Get-TrueNasSystemNTP</code> список используемых NTP серверов <br />
<code>Get-TrueNasDisk</code> список разделов физического диска <br />
<code>Get-TrueNasInterface</code> сетевые интерфейсы <br />
<code>Get-TrueNasGlobalConfig</code> сетевые настройки <br />
<code>Get-TrueNasDnsServer</code> настроенные DNS-сервера <br />
<code>Get-TrueNasIscsiTarget</code> отобразить ID группы инициаторов использующих таргет, используемый portal, authentification и authen-method <br />
<code>Get-TrueNasIscsiInitiator</code> отобразить группы инициаторов <br />
<code>Get-TrueNasIscsiPortal</code> слушатель (Listen) и порт <br />
<code>Get-TrueNasIscsiExtent</code> список ISCSi Target (статус работы, путь) <br />
<code>Get-TrueNasPool</code> список pool (Id, Path, Status, Healthy) <br />
<code>Get-TrueNasVolume -Type FILESYSTEM</code> список pool файловых систем <br />
<code>Get-TrueNasVolume -Type VOLUME</code> список разделов в pool и их размер <br />
<code>Get-TrueNasService | ft</code> список служб и их статус <br />
<code>Start-TrueNasService ssh</code> запустить службу <br />
<code>Stop-TrueNasService ssh</code> остановить службу</p>
<h2 id="synology"><a class="header" href="#synology">Synology</a></h2>
<p>Module: <a href="https://github.com/pspete/pSynology">pSynology</a></p>
<p><code>New-SYNOSession</code> аутентификация на Synology Diskstation и запуск нового сеанса API <br />
<code>Close-SYNOSession</code> выход из сеанса API <br />
<code>Get-SYNOInfo</code> получить информацию об API DiskStation <br />
<code>Add-SYNOFSFAvorite</code> добавить папку в избранное пользователя <br />
<code>Add-SYNOFSFile</code> загрузить файл <br />
<code>Clear-SYNOFSBackgroundTask</code> удалить все завершенные фоновые задачи <br />
<code>Clear-SYNOFSFavoriteStatus</code> удалить все избранное с неработающим статусом <br />
<code>Clear-SYNOFSSharingLink</code> удалить все просроченные и неработающие ссылки для обмена <br />
<code>Get-SYNOFSArchiveCompress</code> получить статус задачи сжатия <br />
<code>Get-SYNOFSArchiveContent</code> вывести содержимое архива <br />
<code>Get-SYNOFSArchiveExtract</code> получить статус задачи извлечения <br />
<code>Get-SYNOFSBackgroundTask</code> список всех фоновых задач, включая копирование <br />
<code>Get-SYNOFSCopy</code> получить статус операции копирования <br />
<code>Get-SYNOFSDeleteItem</code> получить статус задачи удаления <br />
<code>Get-SYNOFSDirSize</code> получить статус задачи расчета размера <br />
<code>Get-SYNOFSFavorite</code> список избранного пользователя <br />
<code>Get-SYNOFSFile</code> перечислить файлы в заданной папке <br />
<code>Get-SYNOFSFileInfo</code> получить информацию о файлах или файле <br />
<code>Get-SYNOFSInfo</code> получить информацию о файловой станции <br />
<code>Get-SYNOFSMD5</code> получить статус вычислительной задачи MD5 <br />
<code>Get-SYNOFSSearch</code> перечислить совпадающие файлы во временной базе данных поиска <br />
<code>Get-SYNOFSShare</code> список всех общих папок <br />
<code>Get-SYNOFSSharingLink</code> список ссылок пользователя на общий доступ к файлам <br />
<code>Get-SYNOFSSharingLinkInfo</code> получить информацию о ссылке общего доступа по идентификатору ссылки общего доступа <br />
<code>Get-SYNOFSThumbnail</code> получить миниатюру файла <br />
<code>Get-SYNOFSVirtualFolder</code> список всех папок точек монтирования заданного типа виртуальной файловой системы <br />
<code>New-SYNOFSFolder</code> создать папку <br />
<code>New-SYNOFSSharingLink</code> создать одну или несколько ссылок для общего доступа по пути к файл или папку <br />
<code>Remove-SYNOFSFAvorite</code> удаление избранного из избранного пользователя <br />
<code>Remove-SYNOFSItem</code> удалить файл или папку <br />
<code>Remove-SYNOFSSearch</code> удалить временные базы данных поиска <br />
<code>Remove-SYNOFSSharingLink</code> удалить одну или несколько ссылок общего доступа <br />
<code>Rename-SYNOFSItem</code> переименовываем файл или папку <br />
<code>Save-SYNOFSFile</code> загрузить файл или папку <br />
<code>Set-SYNOFSFAvorite</code> редактировать избранное имя <br />
<code>Set-SYNOFSSharingLink</code> изменить ссылку для общего доступа <br />
<code>Start-SYNOFSArchiveCompress</code> запустить задание сжатия файла или папки <br />
<code>Start-SYNOFSArchiveExtract</code> запустить задание распаковки архива <br />
<code>Start-SYNOFSCopy</code> запустить задание копирования файлов <br />
<code>Start-SYNOFSDeleteItem</code> запустить задание удаления файлов или папок <br />
<code>Start-SYNOFSDirSize</code> расчитать размер для одного или нескольких путей к файлам или папкам <br />
<code>Start-SYNOFSMD5</code> получить MD5 файла <br />
<code>Start-SYNOFSSearch</code> поиск файлов по заданным критериям <br />
<code>Stop-SYNOFSArchiveCompress</code> остановить задачу сжатия <br />
<code>Stop-SYNOFSArchiveExtract</code> остановить задачу извлечения <br />
<code>Stop-SYNOFSCopy</code> остановить задачу копирования <br />
<code>Stop-SYNOFSDeleteItem</code> остановить задачу удаления <br />
<code>Stop-SYNOFSDirSize</code> остановить расчет размера <br />
<code>Stop-SYNOFSMD5</code> остановить вычисление MD5 файла <br />
<code>Stop-SYNOFSSearch</code> остановить задачу поиска <br />
<code>Test-SYNOFSPermission</code> проверить, имеет ли вошедший в систему пользователь разрешение на запись в данную папку <br />
<code>Update-SYNOFSFAvorite</code> заменить несколько избранных папок в избранном пользователя</p>
<h1 id="veeam"><a class="header" href="#veeam">Veeam</a></h1>
<p>Modules: <a href="https://github.com/VeeamHub/powershell">VeeamHub</a></p>
<h2 id="get-vbrcommand"><a class="header" href="#get-vbrcommand">Get-VBRCommand</a></h2>
<p><code>Set-ExecutionPolicy AllSigned</code> <br />
<code>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))</code> установить choco <br />
<code>choco install veeam-backup-and-replication-console</code> установить консоль управления (https://community.chocolatey.org/packages/veeam-backup-and-replication-console) <br />
<code>Get-Module Veeam.Backup.PowerShell</code> модуль, который устанавливается вместе с клиентской консолью по умолчанию <br />
<code>Get-Command -Module Veeam.Backup.PowerShell</code> <br />
<code>Get-Command -Module Get-VBRCommand</code> <br />
<code>Connect-VBRServer -Server $srv -Credential $cred -Port 9392</code> <br />
<code>Get-VBRJob</code> <br />
<code>Get-VBRCommand *get*backup*</code> <br />
<code>Get-VBRComputerBackupJob</code> <br />
<code>Get-VBRBackup</code> <br />
<code>Get-VBRBackupRepository</code> <br />
<code>Get-VBRBackupSession</code> <br />
<code>Get-VBRBackupServerCertificate</code> <br />
<code>Get-VBRRestorePoint</code> <br />
<code>Get-VBRViProxy</code></p>
<h2 id="veeam-restat"><a class="header" href="#veeam-restat">Veeam-REStat</a></h2>
<p>Install module <a href="https://github.com/Lifailon/Veeam-REStat">Veeam-REStat</a>: <code>Install-Module Veeam-REStat -Repository NuGet</code></p>
<pre><code class="language-PowerShell">$path = ($env:PSModulePath.Split(";")[0])+"\Veeam-REStat\Veeam-REStat.psm1"
if (!(Test-Path $path)) {
    New-Item $path -ItemType "File" -Force
}
$(iwr https://raw.githubusercontent.com/Lifailon/Veeam-REStat/rsa/Veeam-REStat/Veeam-REStat.psm1).Content | Out-File $path -Force
</code></pre>
<p><code>Veeam-REStat -Server srv-veeam-11 -Port 9419</code> при первом запуске необходимо заполнить Credential для подключения к экземпляру сервера VBR, которые сохраняются в файл с именем сервера в формате xml с применением шифрования PSCredential для последующего подключения <br />
<code>Veeam-REStat -Reset</code> сброс учетных данных для подключения к серверу VBR <br />
<code>Veeam-REStat -Statistic</code> статистика всех заданий с сортировкой по дате (выводит время начала, завершения и статус работы, процент прогресса, результат выполнений и сообщение с причиной в случае ошибки: Warning или Failed) <br />
<code>Veeam-REStat -Jobs</code> подробная статистика по всем настроенным заданиям резеврного копирования: статус работы (In Active/disabled), результат последнего задания (LastResult), тип аутентификации (Standard/Linux), имя и размер виртуальной машины, тип резервного копирования (например, Incremental), дату и время последнего и следущего выполнения <br />
<code>Veeam-REStat -ConfigBackup</code> отображает статус состояния работы резервного копирования конфигурации сервера VBR, кол-во точек восстановления, дату и время последней копии <br />
<code>Veeam-REStat -Repositories</code> статистика по инвентарным данным репозиториев: тип хранилища, путь на сервере до директории хранения, общий (capacityGB), свободный (freeGB) и используемый (usedSpaceGB) размер диска под данные <br />
<code>Veeam-REStat -Backup</code> список заданий резервного копирования, тип копирования (VM/Directory) и кол-во точек восстановления <br />
<code>Veeam-REStat -Points</code> история статистики всех точек восстановления с датой создания <br />
<code>Veeam-REStat -Hosts</code> список физически (в ручную) добавленных хостов в инфраструктуру VBR <br />
<code>Veeam-REStat -Proxy</code> список серверов с ролью Proxy <br />
<code>Veeam-REStat -Users</code> список УЗ, добавленных для подключения к серверам <br />
<code>Veeam-REStat -Service</code> выводит информацию о связанных внутренних службах, подключение к этим службам может потребоваться только для интеграции с VBR</p>
<div style="break-before: page; page-break-before: always;"></div><p>+++
title = "Database"
[extra]
toc = true
toc_sidebar = true
go_to_top = true
+++</p>
<p>Заметки по работе с различными базами данных через <code>PowerShell</code>.</p>
<hr />
<h1 id="sqlite"><a class="header" href="#sqlite">SQLite</a></h1>
<pre><code class="language-PowerShell">$path = "$home\Documents\Get-Service.db"
$Module = Get-Module MySQLite
if ($Module -eq $null) {
    Install-Module MySQLite -Repository PSGallery -Scope CurrentUser
}
Import-Module MySQLite
New-MySQLiteDB -Path $path # создать БД
Invoke-MySQLiteQuery -Path $path -Query "CREATE TABLE Service (Name TEXT NOT NULL, DisplayName TEXT NOT NULL, Status TEXT NOT NULL);" # создать таблицу

$Service = Get-Service | select Name,DisplayName,Status
foreach ($S in $Service) {
    $Name = $S.Name
    $DName = $S.DisplayName
    $Status = $S.Status
    Invoke-MySQLiteQuery -Path $path -Query "INSERT INTO Service (Name, DisplayName, Status) VALUES ('$Name', '$DName', '$Status');"
}
</code></pre>
<p><code>(Get-MySQLiteDB $path).Tables</code> список таблиц в базе <br />
<code>Invoke-MySQLiteQuery -Path $path -Query "SELECT name FROM sqlite_master WHERE type='table';"</code> список таблиц в базе <br />
<code>Invoke-MySQLiteQuery -Path $path -Query "DROP TABLE Service;"</code> удалить таблицу</p>
<pre><code class="language-PowerShell">$TableName = "Service"
Invoke-MySQLiteQuery -Path $path -Query "SELECT * FROM $TableName" # прочитать содержимое таблицы (в формате объекта)
</code></pre>
<p><code>Get-Service | select  Name,DisplayName,Status | ConvertTo-MySQLiteDB -Path $path -TableName Service -force</code> конвертировать объект в таблицу</p>
<h3 id="database-password"><a class="header" href="#database-password">Database password</a></h3>
<pre><code class="language-PowerShell">$Connection = New-SQLiteConnection -DataSource $path
$Connection.ChangePassword("password")
$Connection.Close()
Invoke-SqliteQuery -Query "SELECT * FROM Service" -DataSource "$path;Password=password"
</code></pre>
<h1 id="keepass"><a class="header" href="#keepass">KeePass</a></h1>
<pre><code class="language-PowerShell"># Определяем переменные до исполняемого файла, базы и пароль
$KeePassExecPath = "C:\Program Files\KeePass Password Safe 2\KeePass.exe"
$basePath = "$home\Documents\KeePass\base.kdbx"
$basePass = "12345"

# Загружаем сборку
[System.Reflection.Assembly]::LoadFrom($KeePassExecPath) | Out-Null
[KeePass.Program]::CommonInitialize()

# Открываем базу
$IOConnectionInfo = [KeePassLib.Serialization.IOConnectionInfo]::FromPath($basePath)
$CompositeKey = New-Object KeePassLib.Keys.CompositeKey
$KcpPassword = New-Object KeePassLib.Keys.KcpPassword @($basePass)
$CompositeKey.AddUserKey($KcpPassword)
$PwDatabase = New-Object KeePassLib.PwDatabase
$PwDatabase.Open($IOConnectionInfo, $CompositeKey, $null)

# Поиск в базе по частичному совпадению (фильтрация)
$SearchParameters = New-Object KeePassLib.SearchParameters
$SearchParameters.SearchString = 'test'
$PwObjectList = New-Object KeePassLib.Collections.PwObjectList[KeePassLib.PwEntry]
$PwDatabase.RootGroup.SearchEntries($SearchParameters, $PwObjectList)
$ucount = $PwObjectList.UCount - 1
if ($ucount -ne 0) {
    foreach ($index in $(0..$ucount)) {
        $PwObjectList.GetAt($index).Strings.ReadSafe([KeePassLib.PwDefs]::UserNameField)
    }
}

# Получаем список групп
$Groups = $PwDatabase.RootGroup.Groups
$groupCollections = New-Object System.Collections.Generic.List[System.Object]
# Проходим по группам
foreach ($Group in $Groups) {
    $entryCollections = New-Object System.Collections.Generic.List[System.Object]
    # Проходим по записям группы и добавляем во временную коллекцию
	foreach ($entry in $Group.Entries) {
        $entryCollections.Add([PSCustomObject]@{
            Title    = $entry.Strings.Get("Title").ReadString()
            Login    = $entry.Strings.Get("UserName").ReadString()
            Password = $entry.Strings.Get("Password").ReadString()
            Url = $entry.Strings.Get("URL").ReadString()
            Description = $entry.Strings.Get("Notes").ReadString()
        })
    }
    # Добавляем запись в основную коллекцию групп (название группы используется как ключ)
    $groupCollections += [PSCustomObject]@{
        # ($Group.Name) = $entryCollections
		Group = $Group.Name
		Modification = $Group.LastAccessTime.ToString()
        Entries = $entryCollections
    }
}

# Преобразуем структуру в JSON
$jsonData = $groupCollections | ConvertTo-Json -Depth 3
$jsonData

# Закрываем базу
$PwDatabase.Close()
</code></pre>
<h1 id="mysql"><a class="header" href="#mysql">MySQL</a></h1>
<p><code>apt -y install mysql-server mysql-client</code> <br />
<code>mysql -V</code> <br />
<code>systemctl status mysql</code> <br />
<code>mysqladmin -u root password</code> задать пароль root</p>
<p><code>nano /etc/mysql/mysql.conf.d/mysqld.cnf</code></p>
<pre><code>[mysqld]
user                    = mysql
# pid-file              = /var/run/mysqld/mysqld.pid
# socket                = /var/run/mysqld/mysqld.sock
# port                  = 3306
# datadir               = /var/lib/mysql
# tmpdir                = /tmp
bind-address            = 0.0.0.0
mysqlx-bind-address     = 0.0.0.0
log_error = /var/log/mysql/error.log
</code></pre>
<p><code>systemctl restart mysql</code> <br />
<code>ss -tulnp | grep 3306</code> <br />
<code>ufw allow 3306/tcp</code> <br />
<code>nc -zv 192.168.1.253 3306</code> <br />
<code>tnc 192.168.1.253 -p 3306</code></p>
<p><code>mysql -u root -p</code> <br />
<code>SELECT user(), now(), version();</code> <br />
<code>quit;</code></p>
<p><code>mysql -u root -p -e 'SHOW TABLES FROM db_aduser;'</code> отобразить список таблиц без подключения к консоли MySQL</p>
<p><code>CREATE</code> создать БД, пользователя, таблицу <br />
<code>ALTER</code>  управление столбцами таблице <br />
<code>DROP</code> удалить БД, пользователя, таблицу <br />
<code>USE</code> выбрать БД <br />
<code>SHOW</code> вывесли список БД, прав доступа пользователя (GRANTS), названия столбцов и их свойства <br />
<code>GRANT</code> дать доступ пользователю к БД <br />
<code>REVOKE</code>  удалить доступ пользователя к БД <br />
<code>UPDATE</code> изменить права доступа, значения с таблице <br />
<code>FLUSH</code> обновить права доступа <br />
<code>SELECT</code> отобразить выбранную БД, вывести список пользователей, выборка данных в таблице <br />
<code>INSERT</code> внести данные <br />
<code>DELETE</code> удалить данные в (FROM) таблице</p>
<h3 id="data-type"><a class="header" href="#data-type">DATA TYPE</a></h3>
<p><code>VARCHAR(N)</code> строка переменной длины, в формате ASCII, где один символ занимает 1 байт, числом N указывается максимальная возможная длина строки <br />
<code>NVARCHAR(N)</code> строка переменной длины, в формате Unicode, где один символ занимает 2 байта <br />
<code>CHAR(N)/nchar(N)</code> строка фиксированной длины, которая всегда дополняется справа пробелами до длины N и в базе данных она занимает ровно N символов <br />
<code>INT</code> целое число, от -2147483648 до 2147483647, занимает 4 байта <br />
<code>FLOAT</code> число, в котором может присутствовать десятичная точка (запятая) <br />
<code>BIT</code> флаг, Да - 1 или Нет - 0 <br />
<code>DATE</code> формат даты, например 25.05.2023 <br />
<code>TIME</code> 23:30:55.1234567 <br />
<code>DATETIME</code> 25.05.2023 23:30:55.1234567</p>
<h3 id="database-1"><a class="header" href="#database-1">DATABASE</a></h3>
<pre><code>SHOW databases;                                                                     # вывести список БД
CREATE DATABASE db_aduser;                                                          # создать БД
CREATE DATABASE db_rep DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;  # создать БД с кодировкой UTF-8
DROP DATABASE db_rep;                                                               # удалить БД
USE db_aduser;                                                                      # выбрать/переключиться на выбранную БД
SELECT database();                                                                  # отобразить выбранную БД
</code></pre>
<h3 id="user"><a class="header" href="#user">USER</a></h3>
<pre><code>SELECT USER,HOST FROM mysql.user;                                     # вывести список УЗ
CREATE USER posh@localhost IDENTIFIED BY '1qaz!QAZ';                  # создать УЗ, которая будет подключаться с локального сервера
CREATE USER posh@localhost IDENTIFIED BY '1qaz!QAZ';                  # создать УЗ, которая будет подключаться с указанного сервера
CREATE USER posh@'192.168.3.99' IDENTIFIED BY '1qaz!QAZ';             # УЗ для доступа с конкретного сервера
CREATE USER 'admin'@'%' IDENTIFIED BY 'Admin12#';                     # УЗ для доступа с любого сервера (% - wildcard)
DROP USER posh@localhost;                                             # удалить пользователя
SHOW GRANTS FOR posh@'%';                                             # отобразить права доступа пользователя
GRANT ALL PRIVILEGES ON db_aduser.* TO posh@'192.168.3.99';           # полный доступ для posh к БД db_aduser
GRANT ALL PRIVILEGES ON *.* TO posh@'%';                              # доступ к всем БД c любого клиентского хоста
GRANT SELECT,DELETE ON mysql.* TO posh@'%';                           # права SELECT и DELETE на встроенную БД mysql
REVOKE DELETE ON mysql.* FROM posh@'%';                               # удалить доступ DELETE
UPDATE mysql.user SET super_priv='Y' WHERE USER='posh' AND host='%';  # изменить привелегии для пользователя
SELECT USER,HOST,super_priv FROM mysql.user;                          # список УЗ и таблица с правами SUPER privilege
FLUSH PRIVILEGES;                                                     # обновить права доступа
</code></pre>
<h3 id="table"><a class="header" href="#table">TABLE</a></h3>
<pre><code>SHOW TABLES;               # отобразить список всех таблиц
SHOW TABLES LIKE '%user';  # поиск таблицы по wildcard-имени
CREATE TABLE table_aduser (id INT NOT NULL AUTO_INCREMENT, Name VARCHAR(100), email VARCHAR(100), PRIMARY KEY (ID));  # создать таблицу
DROP TABLE table_aduser;   # удалить таблицу
</code></pre>
<h3 id="column"><a class="header" href="#column">COLUMN</a></h3>
<pre><code>SHOW COLUMNS FROM table_aduser;                                                         # отобразить название стобцов и их свойства
ALTER TABLE table_aduser DROP COLUMN id;                                                # удалить столбец id
ALTER TABLE table_aduser ADD COLUMN info VARCHAR(10);                                   # добавить столбец info
ALTER TABLE table_aduser CHANGE info new_info VARCHAR(100);                             # изменить имя столбца info на new_info и его тип данных
ALTER TABLE table_aduser ADD COLUMN (id INT NOT NULL AUTO_INCREMENT, PRIMARY KEY (ID)); # добавить столбец id
</code></pre>
<h3 id="insert"><a class="header" href="#insert">INSERT</a></h3>
<pre><code>INSERT table_aduser (Name,email) VALUES ('Alex','no-email');
INSERT table_aduser (Name,email) VALUES ('Alex','no-email');
INSERT table_aduser (Name) VALUES ('Support');
INSERT table_aduser (Name) VALUES ('Jack');
</code></pre>
<h3 id="select"><a class="header" href="#select">SELECT</a></h3>
<pre><code>SELECT * FROM table_aduser;                     # содержимое всех стобцов в выбранной (FROM) таблице
SELECT Name,email FROM table_aduser;            # содержимое указанных стобцов
SELECT DISTINCT Name,Email FROM table_aduser;   # отобразить уникальные записи (без повторений)
SELECT * FROM table_aduser ORDER BY Name;       # отсортировать по Name
SELECT * FROM table_aduser ORDER BY Name DESC;  # обратная сортировка
SELECT COUNT(*) FROM table_aduser;              # количество строк в таблице
SELECT COUNT(new_info) FROM table_aduser;       # количество строк в столбце
</code></pre>
<h3 id="where"><a class="header" href="#where">WHERE</a></h3>
<pre><code>NOT; AND; OR                                                  # по приоритетам условий
SELECT * FROM table_aduser WHERE Name = 'Alex';               # поиск по содержимому
SELECT * FROM table_aduser WHERE NOT Name != 'Alex';          # условие NOT где Name не равен значению
SELECT * FROM table_aduser WHERE email != '';                 # вывести строки, где содержимое email не рано null
SELECT * FROM table_aduser WHERE email != '' OR id &gt; 1000;    # или id выше 1000
SELECT * FROM table_aduser WHERE Name RLIKE "support";        # регистронезависемый (RLIKE) поиск
SELECT * FROM table_aduser WHERE Name RLIKE "^support";       # начинаются только с этого словосочетания
</code></pre>
<h3 id="delete"><a class="header" href="#delete">DELETE</a></h3>
<pre><code>SELECT * FROM table_aduser WHERE Name RLIKE "alex";   # найти и проверить значения перед удалением
DELETE FROM table_aduser WHERE Name RLIKE "alex";     # Query OK, 2 rows affected # удалено две строки
DELETE FROM table_aduser;                             # удалить ВСЕ значения
</code></pre>
<h3 id="update-1"><a class="header" href="#update-1">UPDATE</a></h3>
<pre><code>SELECT * FROM table_aduser WHERE Name = 'Jack';             # найти и проверить значение перед изменением
UPDATE table_aduser SET Name = 'Alex' WHERE Name = 'Jack';  # изменить значение 'Jack' на 'Alex'
UPDATE db_aduser.table_aduser SET Name='BCA' WHERE id=1;    # изменить значение в строке с ID 1
</code></pre>
<h3 id="check"><a class="header" href="#check">CHECK</a></h3>
<pre><code>CHECK TABLE db_aduser.table_aduser;     # проверить
ANALYZE TABLE db_aduser.table_aduser;   # анализировать
OPTIMIZE TABLE db_aduser.table_aduser;  # оптимизировать
REPAIR TABLE db_aduser.table_aduser;    # восстановить
TRUNCATE TABLE db_aduser.table_aduser;  # очистить
</code></pre>
<h3 id="dump"><a class="header" href="#dump">DUMP</a></h3>
<pre><code>mysqldump -u root -p --databases db_aduser &gt; /bak/db_aduser.sql
mysql -u root -p db_aduser &lt; /bak/db_aduser.sql

crontab -e
00 22 * * * /usr/bin/mysqldump -uroot -p1qaz!QAZ db_zabbix | /bin/bzip2 &gt; `date +/dump/zabbix/zabbix-\%d-\%m-\%Y-\%H:\%M.bz2`
00 23 * * * /usr/bin/mysqldump -uroot -p1qaz!QAZ db_zabbix &gt; `date +/dump/smb/zabbix-\%d-\%m-\%Y-\%H:\%M.sql`
0 0 * * * find /dump/zabbix -mtime +7 -exec rm {} \;

mysqldump -u root --single-transaction db_zabbix &gt; /dump/zabbix/db_zabbix.sql
mysql -u user_zabbix -p -e 'CREATE DATABASE db_zabbix;'
mysql -u user_zabbix -p db_zabbix &lt; /root/db_zabbix.sql
</code></pre>
<h3 id="innodb-force-recovery"><a class="header" href="#innodb-force-recovery">innodb force recovery</a></h3>
<pre><code>sed -i '/innodb_force_recovery/d' /etc/mysql/my.cnf # удалить
mode=6; sed -i "/^\[mysqld\]/{N;s/$/\ninnodb_force_recovery=$mode/}" /etc/mysql/my.cnf # добавить mode 6
systemctl restart mysql

[mysqld]
innodb_force_recovery=1 # сервер пытается начать работу независимо от того, есть ли поврежденные данные InnoDB или нет
innodb_force_recovery=2 # удается восстановить работу за счет остановки потока команд, которые были частично выполнены или не выполнены (не запускает фоновые операции)
innodb_force_recovery=3 # отменяет откат после восстановления поврежденных файлов (не пытается откатить транзакции)
innodb_force_recovery=6 # запуск СУБД в режиме read only
</code></pre>
<h3 id="mysql-connector-net"><a class="header" href="#mysql-connector-net">MySQL Connector NET</a></h3>
<h3 id="add-aduser"><a class="header" href="#add-aduser">Add-ADUser</a></h3>
<pre><code class="language-PowerShell">$ip = "192.168.1.253"
$user = "posh"
$pass = "1qaz!QAZ"
$db = "db_aduser"
Add-Type –Path "$home\Documents\MySQL-Connector-NET\8.0.31-4.8\MySql.Data.dll"
$Connection = [MySql.Data.MySqlClient.MySqlConnection]@{
    ConnectionString="server=$ip;uid=$user;pwd=$pass;database=$db"
}
$Connection.Open()
$Command = New-Object MySql.Data.MySqlClient.MySqlCommand
$Command.Connection = $Connection
$UserList = Get-ADUser -filter * -properties name,EmailAddress
foreach ($user in $UserList) {
    $uname=$user.Name
    $uemail=$user.EmailAddress
    $Command.CommandText = "INSERT INTO table_aduser (Name,Email) VALUES ('$uname','$uemail')"
    $Command.ExecuteNonQuery()
}
$Connection.Close()
</code></pre>
<h3 id="get-aduser"><a class="header" href="#get-aduser">Get-ADUser</a></h3>
<pre><code class="language-PowerShell">$ip = "192.168.1.253"
$user = "posh"
$pass = "1qaz!QAZ"
$db = "db_aduser"
Add-Type –Path "$home\Documents\MySQL-Connector-NET\8.0.31-4.8\MySql.Data.dll"
$Connection = [MySql.Data.MySqlClient.MySqlConnection]@{
    ConnectionString = "server=$ip;uid=$user;pwd=$pass;database=$db"
}
$Connection.Open()
$Command = New-Object MySql.Data.MySqlClient.MySqlCommand
$Command.Connection = $Connection
$MYSQLDataAdapter = New-Object MySql.Data.MySqlClient.MySqlDataAdapter
$MYSQLDataSet = New-Object System.Data.DataSet
$Command.CommandText = "SELECT * FROM table_aduser"
$MYSQLDataAdapter.SelectCommand = $Command
$NumberOfDataSets = $MYSQLDataAdapter.Fill($MYSQLDataSet, "data")
$Collections = New-Object System.Collections.Generic.List[System.Object]
foreach($DataSet in $MYSQLDataSet.tables[0]) {
    $Collections.Add([PSCustomObject]@{
    Name = $DataSet.name;
    Mail = $DataSet.email
})
}
$Connection.Close()
$Collections
</code></pre>
<h1 id="mssql"><a class="header" href="#mssql">MSSQL</a></h1>
<p><code>wget -qO- https://packages.microsoft.com/keys/microsoft.asc | apt-key add -</code> импортировать GPG-ключ для репозитория <br />
<code>https://packages.microsoft.com/config/ubuntu/</code> выбрать репозиторий и скопировать URL <br />
<code>add-apt-repository "$(wget -qO- https://packages.microsoft.com/config/ubuntu/20.04/mssql-server-2019.list)"</code> <br />
<code>apt-get update</code> обновить список пакетов <br />
<code>apt-get install mssql-server</code> <br />
<code>/opt/mssql/bin/mssql-conf setup</code> скрипт начальной конфигурации (выбрать редакцию, 3 - express и русский язык 9 из 11) <br />
<code>systemctl status mssql-server</code> <br />
<code>curl https://packages.microsoft.com/keys/microsoft.asc | apt-key add -</code> установить клиент <br />
<code>curl https://packages.microsoft.com/config/ubuntu/20.04/prod.list | tee /etc/apt/sources.list.d/msprod.list</code> <br />
<code>apt-get update</code> <br />
<code>apt-get install mssql-tools</code> <br />
<code>echo 'export PATH="$PATH:/opt/mssql-tools/bin"' &gt;&gt; ~/.bashrc</code> добавить в домашний каталог файла bashrc, что бы не писать путь к исполняемому файлу <br />
<code>export PATH="$PATH:/opt/mssql-tools/bin"</code> <br />
<code>iptables -I INPUT 1 -p tcp --dport 1433 -j ACCEPT</code></p>
<pre><code>sqlcmd -S localhost -U SA
CREATE DATABASE itinvent
go
SELECT name FROM master.dbo.sysdatabases
go
</code></pre>
<h3 id="system-data-sqlclient"><a class="header" href="#system-data-sqlclient">System Data SqlClient</a></h3>
<pre><code class="language-PowerShell">$user = "itinvent"
$pass = "itinvent"
$db   = "itinvent"
$srv  = "192.168.3.103"
$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
$SqlConnection.ConnectionString = "server=$srv;database=$db;user id=$user;password=$pass;Integrated Security=false"

$SqlCommand = New-Object System.Data.SqlClient.SqlCommand` класс формата команды
$SqlCommand.CommandText = "SELECT * FROM ITINVENT.dbo.USERS"` отобразить содержимое таблицы
#$SqlCommand.CommandText = "SELECT LICENCE_DATE,DESCR,MODEL_NO,TYPE_NO FROM ITINVENT.dbo.ITEMS where LICENCE_DATE IS NOT NULL"
$SqlCommand.Connection = $SqlConnection` передать формат подключения
$SqlAdapter = New-Object System.Data.SqlClient.SqlDataAdapter` создать адаптер подключения для выполнения SELECT запросов к БД
$SqlAdapter.SelectCommand = $SqlCommand` передать команду

$DataSet = New-Object System.Data.DataSet` создать объект приема данных формата XML
$SqlAdapter.Fill($DataSet)` заполнить данными полученные от адаптера (возвращает кол-во объектов)
$SqlConnection.Close()
$Data = $DataSet.Tables
$Data[0] | ft
</code></pre>
<h3 id="sqlclient-insert"><a class="header" href="#sqlclient-insert">SqlClient INSERT</a></h3>
<pre><code class="language-PowerShell">$user = "itinvent"
$pass = "itinvent"
$db   = "db_test"
$srv  = "192.168.3.103"
$sql = "INSERT INTO table_test (column_user) VALUES ('lifailon')"` добавить данные в таблицу table_test в колонку column_user
$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
$SqlConnection.ConnectionString = "server=$srv;database=$db;user id=$user;password=$pass;Integrated Security=false"
$SqlCommand = New-Object System.Data.SqlClient.SqlCommand
$SqlCommand.CommandText = $sql
$SqlCommand.Connection = $SqlConnection
$SqlConnection.Open()
$rowsAffected = $SqlCommand.ExecuteNonQuery();` для запросов INSERT/UPDATE/DELETE не используется SqlDataAdapter
$SqlConnection.Close()
</code></pre>
<h3 id="ssms-insert"><a class="header" href="#ssms-insert">SSMS INSERT</a></h3>
<pre><code>USE [db_test]
GO
INSERT INTO [dbo].[table_test]
           ([column_user])
     VALUES
           ('lifailon')
GO
SELECT TOP (1000) [column_user]
FROM [db_test].[dbo].[table_test]
</code></pre>
<h3 id="t-sql"><a class="header" href="#t-sql">T-SQL</a></h3>
<ul>
<li>
<p>DDL (Data Definition Language / Язык определения данных). К этому типу относятся команды, которые создают базу данных, таблицы, индексы, хранимые процедуры. <br />
<code>CREATE</code> создает объекты базы данных (саму базу даных, таблицы, индексы и т.д.) <br />
<code>ALTER</code> изменяет объекты базы данных <br />
<code>DROP</code> удаляет объекты базы данных <br />
<code>TRUNCATE</code> удаляет все данные из таблиц</p>
</li>
<li>
<p>DML (Data Manipulation Language / Язык манипуляции данными). К этому типу относят команды по выбору, обновлению, добавлению и удалению данных. <br />
<code>SELECT</code> извлекает данные из БД <br />
<code>UPDATE</code> обновляет данные <br />
<code>INSERT</code> добавляет новые данные <br />
<code>DELETE</code> удаляет данные</p>
</li>
<li>
<p>DCL (Data Control Language / Язык управления доступа к данным). К этому типу относят команды, которые управляют правами по доступу к данным. <br />
<code>GRANT</code> предоставляет права для доступа к данным <br />
<code>REVOKE</code> отзывает права на доступ к данным</p>
</li>
</ul>
<pre><code>-- Переменные
DECLARE @text NVARCHAR(20), @int INT;
SET @text='Test';
SET @int = 21;
select @text,@int

-- Имена сервера и экземпляра 
Select @@SERVERNAME as [Server\Instance]; 

-- версия SQL Server 
Select @@VERSION as SQLServerVersion; 

-- Текущая БД (БД, в контексте которой выполняется запрос)
Select DB_NAME() AS CurrentDB_Name;

-- Время работы с момента запуска сервера
SELECT  @@Servername AS ServerName ,
        create_date AS  ServerStarted ,
        DATEDIFF(s, create_date, GETDATE()) / 86400.0 AS DaysRunning ,
        DATEDIFF(s, create_date, GETDATE()) AS SecondsRunnig
FROM    sys.databases
WHERE   name = 'tempdb';

-- Количество активных соединений
SELECT  @@Servername AS Server ,
        DB_NAME(database_id) AS DatabaseName ,
        COUNT(database_id) AS Connections ,
        Login_name AS  LoginName ,
        MIN(Login_Time) AS Login_Time ,
        MIN(COALESCE(last_request_end_time, last_request_start_time))
                                                         AS  Last_Batch
FROM    sys.dm_exec_sessions
WHERE   database_id &gt; 0
        AND DB_NAME(database_id) NOT IN ( 'master', 'msdb' )
GROUP BY database_id ,
         login_name
ORDER BY DatabaseName;

-- Статус Backup
SELECT  @@Servername AS ServerName ,
        d.Name AS DBName ,
        MAX(b.backup_finish_date) AS LastBackupCompleted
FROM    sys.databases d
        LEFT OUTER JOIN msdb..backupset b
                    ON b.database_name = d.name
                       AND b.[type] = 'D'
GROUP BY d.Name
ORDER BY d.Name;

-- Путь к Backup
SELECT  @@Servername AS ServerName ,
        d.Name AS DBName ,
        b.Backup_finish_date ,
        bmf.Physical_Device_name
FROM    sys.databases d
        INNER JOIN msdb..backupset b ON b.database_name = d.name
                                        AND b.[type] = 'D'
        INNER JOIN msdb.dbo.backupmediafamily bmf ON b.media_set_id = bmf.media_set_id
ORDER BY d.NAME ,
        b.Backup_finish_date DESC; 

-- Вывести список всех БД, модели восстановления и путь к mdf/ldf
EXEC sp_helpdb; 
SELECT  @@SERVERNAME AS Server ,
        d.name AS DBName ,
        create_date ,
        recovery_model_Desc AS RecoveryModel ,
        m.physical_name AS FileName
FROM    sys.databases d
        JOIN sys.master_files m ON d.database_id = m.database_id
ORDER BY d.name;

-- Размер БД
with fs
as
(
    select database_id, type, size * 8.0 / 1024 size
    from sys.master_files
)
select 
    name,
    (select sum(size) from fs where type = 0 and fs.database_id = db.database_id) DataFileSizeMB,
    (select sum(size) from fs where type = 1 and fs.database_id = db.database_id) LogFileSizeMB
from sys.databases 

-- Поиск таблицы по маске имени (вывод: названия схемы где распологается объект, тип объекта, дата создания и последней модификации):
select [object_id], [schema_id],
	   schema_name([schema_id]) as [schema_name], 
	   [name], 
	   [type], 
	   [type_desc], 
	   [create_date], 
	   [modify_date]
from sys.all_objects
-- where [name]='INVENT';
where [name] like '%INVENT%';

-- Кол-во строк в таблицах
SELECT  @@ServerName AS Server ,
        DB_NAME() AS DBName ,
        OBJECT_SCHEMA_NAME(p.object_id) AS SchemaName ,
        OBJECT_NAME(p.object_id) AS TableName ,
        i.Type_Desc ,
        i.Name AS IndexUsedForCounts ,
        SUM(p.Rows) AS Rows
FROM    sys.partitions p
        JOIN sys.indexes i ON i.object_id = p.object_id
                              AND i.index_id = p.index_id
WHERE   i.type_desc IN ( 'CLUSTERED', 'HEAP' )
                             -- This is key (1 index per table) 
        AND OBJECT_SCHEMA_NAME(p.object_id) &lt;&gt; 'sys'
GROUP BY p.object_id ,
        i.type_desc ,
        i.Name
ORDER BY SchemaName ,
        TableName; 

-- Найти строковое (nvarchar) значение 2023 по всем таблицам базы данных
-- Отображается в какой таблице и столбце хранится значение, а также количество найденных пары таблица-колонка
set nocount on
declare @name varchar(128), @substr nvarchar(4000), @column varchar(128)
set @substr = '%2023%'
declare @sql nvarchar(max);
create table`rslt 
(table_name varchar(128), field_name varchar(128), [value] nvarchar(max))
declare s cursor for select table_name as table_name from information_schema.tables where table_type = 'BASE TABLE' order by table_name
open s
fetch next from s into @name
while @@fetch_status = 0
begin
declare c cursor for 
select quotename(column_name) as column_name from information_schema.columns 
where data_type in ('text', 'ntext', 'varchar', 'char', 'nvarchar', 'char', 'sysname', 'int', 'tinyint') and table_name  = @name
set @name = quotename(@name)
open c
fetch next from c into @column
while @@fetch_status = 0
begin
--print 'Processing table - ' + @name + ', column - ' + @column
set @sql='insert into`rslt select ''' + @name + ''' as Table_name, ''' + @column + ''', cast(' + @column + 
' as nvarchar(max)) from' + @name + ' where cast(' + @column + ' as nvarchar(max)) like ''' + @substr + '''';
print @sql;
exec(@sql);
fetch next from c into @column;
end
close c
deallocate c
fetch next from s into @name
end
select table_name as [Table Name], field_name as [Field Name], count(*) as [Found Mathes] from`rslt
group by table_name, field_name
order by table_name, field_name
drop table`rslt
close s
deallocate s

-- Поиск в таблице [CI_HISTORY] и столбцу [HIST_ID]:
SELECT * FROM ITINVENT.dbo.CI_HISTORY where [HIST_ID] like '%2023%';

-- Узнать фрагментацию индексов
DECLARE @db_id SMALLINT;
SET @db_id = DB_ID(N'itinvent');
IF @db_id IS NULL
BEGIN;
    PRINT N'Неправильное имя базы';
END;
ELSE
BEGIN;
	SELECT
		object_id AS [ID объекта],
		index_id AS [ID индекса],
		index_type_desc AS [Тип индекса],
		avg_fragmentation_in_percent AS [Фрагментация в %]
		
	FROM sys.dm_db_index_physical_stats(@db_id, NULL, NULL, NULL , 'LIMITED')
	 
	ORDER BY [avg_fragmentation_in_percent] DESC;
END;
GO

-- TempDB
-- Initial size - начальный/минимальный размер БД (1024 MB)
-- Autogrowh - прирост (512MB)
-- По умолчанию tempdb настроена на авто-расширение (Autogrow) и при каждой перезагрузке SQL Server пересоздаёт файлы этой БД с минимальным размером инициализации.
-- Увеличив размер инициализации файлов tempdb, можно свести к минимуму затраты системных ресурсов на операции авто-расширения.

-- Изменить путь к БД:
USE master;
GO
ALTER DATABASE tempdb
MODIFY FILE (NAME = tempdev, FILENAME = 'F:\tempdb.mdf');
GO
ALTER DATABASE tempdb
MODIFY FILE (NAME = temp2, FILENAME = 'F:\tempdb_mssql_2.ndf');
GO
ALTER DATABASE tempdb
MODIFY FILE (NAME = temp3, FILENAME = 'F:\tempdb_mssql_3.ndf');
GO
ALTER DATABASE tempdb
MODIFY FILE (NAME = temp4, FILENAME = 'F:\tempdb_mssql_4.ndf');
GO
ALTER DATABASE tempdb
MODIFY FILE (NAME = temp5, FILENAME = 'F:\tempdb_mssql_5.ndf');
GO
ALTER DATABASE tempdb
MODIFY FILE (NAME = temp6, FILENAME = 'F:\tempdb_mssql_6.ndf');
GO
ALTER DATABASE tempdb
MODIFY FILE (NAME = temp7, FILENAME = 'F:\tempdb_mssql_7.ndf');
GO
ALTER DATABASE tempdb
MODIFY FILE (NAME = temp8, FILENAME = 'F:\tempdb_mssql_8.ndf');
GO
ALTER DATABASE tempdb
MODIFY FILE (NAME = templog, FILENAME = 'F:\templog.ldf');
GO

-- Указать размер файла:
MODIFY FILE (NAME = temp2, FILENAME = 'F:\tempdb_mssql_2.ndf' , SIZE = 1048576KB , FILEGROWTH = 524288KB);
</code></pre>
<h3 id="backup-type"><a class="header" href="#backup-type">Backup type</a></h3>
<ul>
<li>Full (Полная копия). Когда стартует полное резервирование, записывается Log Sequence Number (LSN - последовательный номер журнала), а так же LSN записывается и при завершении полного резервирования. Этот LSN является механизмом, используемым SQL Server, чтобы знать, в каком порядке выполнялись операторы INSERT, UPDATE или DELETE. При этом наличие записанных LSN начала и окончания, как части полного бэкапа, обеспечивает согласованное с точки зрения транзакций резервное копирование, поскольку при полном резервном копировании учитываются изменения, произошедшие во время резервного копирования. Это обеспечивает обработку таких транзакций в процессе восстановления бэкапа.</li>
<li>Differential (дифференциальная/разностная копия). Хранит данных, изменившиеся с момента последней Полной резервной копии. При восстановлении нужно сначала восстановить Полную резервную копию в режиме NORECOVERY, потом можно применить любую из последующих Разностных копий, без предыдущей Полной резервной копии Разностная копия бесполезна. Каждая последующая Разностная копия будет хранить все данные, входящие в предыдущую Разностную резервную копию, сделанную после предыдущей Полной копии.</li>
<li>Incremental (инкрементальная/копия журналов транзакций). Резервное копирования журнала транзакций копирует все транзакции, которые произошли с момента последнего резервного копирования, а затем урезает журнал транзакций для освобождения дискового пространства. Транзакции происходят в определенном порядке (LSN), бэкап журнала поддерживает этот порядок транзакций. Бэкапы журналов транзакций должны восстанавливаться по порядку. Для восстановления базы данных потребуется вся цепочка резервных копий: полная и все последующие инкрементальные журнала транзакций.</li>
</ul>
<h3 id="recovery-models"><a class="header" href="#recovery-models">Recovery Models</a></h3>
<ul>
<li>Simple (Простая). Хранится только необходимый для жизни остаток журнала транзакций. Журнал транзакций (лог) автоматически очищается. Создание резервных копий журнала транзакций невозможна, поэтому остается самое ограниченное число опций по восстановлению. Недоступен функционал: Always On, Point-In-Time восстановление, Резервные копии журнала транзакций.</li>
<li>Full (Полная). Хранится журнал транзакций всех изменений в БД с момента последнего резервного копирования журнала транзакций. Журнал транзакций не будет очищаться до тех пор, пока не будет сделана резервная копия журнала транзакций.</li>
<li>Bulk logged (С неполным протоколированием). Идентична Full, за исключение: SELECT INTO, BULK INSERT и BCP, INSERT INTO SELECT, операции с индексами (CREATE INDEX, ALTER INDEX REBUILD, DROP INDEX)</li>
</ul>
<h3 id="system-databases"><a class="header" href="#system-databases">System databases</a></h3>
<ul>
<li>master. Хранятся все данные системного уровня (конфигурация системы, сведенья об учетных записях входа, информация обо всех других базах данных) для экземпляра SQL Server.</li>
<li>tempdb. Рабочее пространство для временных объектов, таких как глобальные или локальные временные таблицы, временные хранимые процедуры, табличные переменные и курсоры. Пересоздаётся при каждом запуске SQL Server.</li>
<li>model. Используется в качестве шаблона для всех баз данных, создаваемых в экземпляре SQL Server, все содержимое базы данных model, включая параметры базы данных, копируется в создаваемую базу данных. Так как база данных tempdb создается каждый раз при запуске SQL Server, база данных model всегда должна существовать в системе SQL Server.</li>
<li>msdb. Используется агентом SQL Server для создания расписания предупреждений (оператор) и выполнение заданий, а также другими компонентами. SQL Server хранит полный журнал резервного копирования и восстановления в базе данных msdb. Для отправки почты оператору используется: USE [msdb].</li>
<li>resource. Доступная только для чтения база данных, которая содержит все системные объекты, например sys.objects, физически хранятся в базе данных resource, но логически присутствуют в схеме sys каждой базы данных.</li>
</ul>
<h3 id="regulatory-operations"><a class="header" href="#regulatory-operations">Regulatory operations</a></h3>
<ul>
<li>Проверка целостности базы данных</li>
</ul>
<p><code>DBCC CHECKDB</code></p>
<ul>
<li>
<p>Индексы. Индексы используются для быстрого поиска данных без необходимости поиска/просмотра всех строк в таблице базы данных при каждом обращении к таблице базы данных. Индекс ускоряет процесс запроса, предоставляя быстрый доступ к строкам данных в таблице, аналогично тому, как указатель в книге помогает вам быстро найти необходимую информацию. Индексы предоставляют путь для быстрого поиска данных на основе значений в этих столбцах. Для каждого индекса обязательно хранится его статистика. MS SQL Server самостоятельно создает и изменяет индексы при работе с базой. С течением времени данные в индексе становятся фрагментированными, т.е. разбросанными по базе данных, что серьезно снижает производительность запросов. Если фрагментация составляет от 5 до 30% (стандартно в задании 15%), то рекомендуется ее устранить с помощью реорганизации, при фрагментации выше 30% (по умолчанию в задаче &gt; 30% фрагментации и число страниц &gt; 1000) необходимо полное перестроение индексов. После перестроения планово используется только реорганизация.</p>
</li>
<li>
<p>Реорганизация (Reorganize) или дефрагментация индекса — это серия небольших локальных перемещений страниц так, чтобы индекс не был фрагментирован. После реорганизации статистика не обновляется. Во время выполнения почти все данные доступны, пользователи смогут работать.</p>
</li>
</ul>
<p><code>sp_msforeachtable N'DBCC INDEXDEFRAG (&lt;имя базы данных&gt;, ''?'')'</code></p>
<ul>
<li>Перестроение (Rebuild) индексов (или задача в мастере планов обслуживания: Восстановить индекс) запускает процесс полного построения индексов. В версии MS SQL Server Standard происходит отключение всех клиентов от базы на время выполнения операции. После перестроения обязательно обновляется статистика.</li>
</ul>
<p><code>sp_msforeachtable N'DBCC DBREINDEX (''?'')'</code></p>
<ul>
<li>Обновление статистики. Статистика — небольшая таблица (обычно до 200 строк), в которой хранится обобщенная информация о том, какие значения и как часто встречаются в таблице. На основании статистики сервер принимает решение, как лучше построить запрос. Когда происходят запросы к БД (например, SELECT) вы получаете данные, но не описываете то, как эти данные должны быть извлечены. В получении и обработке данных помогает статистика. Во время выполнения процедуры обновления статистики данные не блокируются.</li>
</ul>
<p><code>exec sp_msforeachtable N'UPDATE STATISTICS ? WITH FULLSCAN'</code></p>
<ul>
<li>Очистка процедурного кэша, выполняется после обновления статистики. Оптимизатор MS SQL Server кэширует планы запросов для их повторного выполнения. Это делается для того, чтобы экономить время, затрачиваемое на компиляцию запроса в том случае, если такой же запрос уже выполнялся и его план известен. После обновия статистики, не будет очищен процедурный кэш, то SQL Server может выбрать старый (неоптимальный) план запроса из кэша вместо того, чтобы построить новый (более оптимальный) план.</li>
</ul>
<p><code>DBCC FREEPROCCACHE</code></p>
<h1 id="influxdb-1"><a class="header" href="#influxdb-1">InfluxDB</a></h1>
<p><a href="https://www.influxdata.com/downloads">Download InfluxDB 1.x Open Source</a>
<a href="https://github.com/CymaticLabs/InfluxDBStudio">InfluxDB-Studio</a></p>
<h3 id="install-windows"><a class="header" href="#install-windows">Install Windows</a></h3>
<pre><code class="language-PowerShell">Invoke-RestMethod "https://dl.influxdata.com/influxdb/releases/influxdb-1.8.10_windows_amd64.zip" -OutFile "$home\Downloads\influxdb-1.8.10_windows_amd64.zip"
Expand-Archive "$home\Downloads\influxdb-1.8.10_windows_amd64.zip" -DestinationPath "$home\Documents\"
Remove-Item "$home\Downloads\influxdb-1.8.10_windows_amd64.zip"
&amp; "$home\Downloads\influxdb-1.8.10-1\influxd.exe"
</code></pre>
<h3 id="install-ubuntu"><a class="header" href="#install-ubuntu">Install Ubuntu</a></h3>
<pre><code class="language-Bash">wget https://dl.influxdata.com/influxdb/releases/influxdb_1.8.10_amd64.deb
sudo dpkg -i influxdb_1.8.10_amd64.deb
systemctl start influxdb
systemctl status influxdb

ps aux | grep influxdb | grep -Ev "grep"
netstat -natpl | grep 80[8-9][3-9]
</code></pre>
<h3 id="api-1"><a class="header" href="#api-1">API</a></h3>
<pre><code class="language-Bash">nano /etc/influxdb/influxdb.conf

[http]
  enabled = true
  bind-address = ":8086"
  auth-enabled = false

systemctl restart influxdb
</code></pre>
<h3 id="chronograf"><a class="header" href="#chronograf">Chronograf</a></h3>
<pre><code>wget https://dl.influxdata.com/chronograf/releases/chronograf-1.10.2_windows_amd64.zip -UseBasicParsing -OutFile chronograf-1.10.2_windows_amd64.zip
Expand-Archive .\chronograf-1.10.2_windows_amd64.zip -DestinationPath 'C:\Program Files\InfluxData\chronograf\'

wget https://dl.influxdata.com/chronograf/releases/chronograf_1.10.2_amd64.deb
sudo dpkg -i chronograf_1.10.2_amd64.deb
systemctl status influxdb
http://192.168.3.102:8888
</code></pre>
<h3 id="grafana"><a class="header" href="#grafana">Grafana</a></h3>
<p><a href="https://grafana.com/grafana/download">Download</a></p>
<p><code>invoke-RestMethod https://dl.grafana.com/enterprise/release/grafana-enterprise-10.3.1.windows-amd64.msi -OutFile "$home\Download\grafana.msi"</code></p>
<pre><code class="language-Bash">apt-get install -y adduser libfontconfig1 musl
wget https://dl.grafana.com/enterprise/release/grafana-enterprise_10.3.1_amd64.deb
dpkg -i grafana-enterprise_10.3.1_amd64.deb
systemctl start grafana-server
systemctl status grafana-server
</code></pre>
<h3 id="cli-client"><a class="header" href="#cli-client">CLI Client</a></h3>
<p><code>apt install influxdb-client</code> <br />
<code>influx</code> <br />
<code>influx --host 192.168.3.102 --username admin --password password</code></p>
<pre><code class="language-PowerShell">$influx_client_exec = "$home\Documents\influxdb-1.8.10-1\influx.exe"
&amp; $influx_client_exec -host 192.168.3.102 -port 8086
help
show databases
use PowerShell
SELECT * FROM "HardwareMonitor" WHERE time &gt; now() - 5m
</code></pre>
<h3 id="users-1"><a class="header" href="#users-1">USERS</a></h3>
<p><code>SHOW USERS</code> отобразить пользователей и их права доступа <br />
<code>CREATE USER admin WITH PASSWORD 'password' WITH ALL PRIVILEGES</code> создать пользователя <br />
<code>GRANT ALL PRIVILEGES TO "admin"</code> предоставить права доступа <br />
<code>GRANT READ ON "database" TO "admin"</code> доступ на чтение для БД или запись (WRITE) <br />
<code>REVOKE ALL PRIVILEGES FROM "admin"</code> отозвать права доступа <br />
<code>SHOW GRANTS FOR "admin"</code> БД и привелегии доступа для указанного пользователя <br />
<code>SET PASSWORD FOR "admin" = 'new_password'</code> изменить пароль <br />
<code>DROP USER "admin"</code> удалить пользователя</p>
<h3 id="database-2"><a class="header" href="#database-2">DATABASE</a></h3>
<p><code>CREATE DATABASE powershell</code> создать БД <br />
<code>SHOW DATABASES</code> отобразить список БД <br />
<code>DROP DATABASE powershell</code> удалить БД <br />
<code>USE powershell</code> <br />
<code>SHOW measurements</code> отобразить все таблицы <br />
<code>INSERT performance,host=console,counter=CPU value=0.88</code> записать данные в таблицу performance</p>
<h3 id="measurement"><a class="header" href="#measurement">MEASUREMENT</a></h3>
<p><code>SHOW TAG KEYS FROM "HardwareMonitor"</code> отобразить все тэги в таблице <br />
<code>SHOW TAG VALUES FROM "HardwareMonitor" WITH KEY = "HardwareName"</code> отобразить все значения указанного тэга <br />
<code>SHOW FIELD KEYS FROM "HardwareMonitor"</code> отобразить все Field Tags и их тип данных <br />
<code>SHOW SERIES FROM "HardwareMonitor"</code> отобразить список всех уникальных серий в указанной таблице. Серия - это набор точек данных, которые имеют одинаковые значения для всех тегов, за исключением времени. <br />
<code>DROP SERIES FROM "HardwareMonitor"</code> очистить все данные в таблице <br />
<code>DROP MEASUREMENT "HardwareMonitor"</code> удалить таблицу</p>
<h3 id="select-and-where"><a class="header" href="#select-and-where">SELECT and WHERE</a></h3>
<p><code>SELECT * FROM performance</code> отобразить все данные в таблице <br />
<code>SELECT value FROM performance</code> отфильтровать по столбцу value (только Field Keys) <br />
<code>SELECT * FROM performance limit 10</code> отобразить 10 единиц данных <br />
<code>SELECT * FROM performance WHERE time &gt; now() -2d</code> отобразить данные за последние 2 дня <br />
<code>SELECT * FROM performance WHERE time &gt; now() +3h -5m</code> данные за последние 5 минут (+3 часа от текущего времени по UTC 0 -5 минут) <br />
<code>SELECT * FROM performance WHERE counter = 'CPU'</code> выборка по тэгу <br />
<code>SELECT upload/1000 FROM speedtest WHERE upload/1000 &lt;= 250</code> выборка по столбцу upload и разделить вывод на 1000, вывести upload меньше 250 <br />
<code>DELETE FROM performance WHERE time &gt; now() -1h</code> удалить данные за последние 1/4 часа <br />
<code>DELETE FROM performance WHERE time &lt; now() -24h</code> удалить данные старше 24 часов</p>
<h3 id="regex-1"><a class="header" href="#regex-1">REGEX</a></h3>
<p><code>SELECT * FROM "win_pdisk" WHERE instance =~/.*C:/ and time &gt; now() - 5m</code> и <br />
<code>SELECT * FROM "win_pdisk" WHERE instance =~/.*E:/ or instance =~ /.*F:/</code> или <br />
<code>SELECT * FROM "win_pdisk" WHERE instance !~ /.*Total/</code> не равно (исключить) <br />
<code>SELECT * FROM "HardwareMonitor" WHERE time &gt; now() - 5m and HardwareName =~ /Intel/</code> приблизительно равно <br />
<code>SELECT * FROM "HardwareMonitor" WHERE time &gt; now() - 5m and HardwareName =~ /Intel.+i7/</code> эквивалент 12th_Gen_Intel_Core_i7-1260P <br />
<code>SELECT * FROM "HardwareMonitor" WHERE time &gt; now() - 5m and HardwareName =~ /^Intel/</code> начинается на Intel <br />
<code>SELECT * FROM "HardwareMonitor" WHERE time &gt; now() - 5m and HardwareName =~ /00$/</code> заканчивается на 00</p>
<h3 id="group-by-tag-key"><a class="header" href="#group-by-tag-key">GROUP BY tag key</a></h3>
<p><code>SELECT * FROM "HardwareMonitor" WHERE time &gt; now() - 5m and SensorName = 'Temperature' GROUP BY HardwareName</code> создать уникальные группы по тэгу HardwareName <br />
<code>SELECT * FROM "HardwareMonitor" WHERE time &gt; now() - 5m and SensorName = 'Temperature' GROUP BY Host,HardwareName</code> больше групп по двум тэгаам</p>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p><a href="https://docs.influxdata.com/influxdb/v1.8/query_language/functions">Functions</a></p>
<p><code>SELECT instance,LAST(Avg._Disk_Read_Queue_Length) FROM "win_pdisk" GROUP BY instance</code> отфильтровать вывод по последнему/текущему значению <br />
<code>SELECT instance,FIRST(Avg._Disk_Read_Queue_Length) FROM "win_pdisk" GROUP BY instance</code> отфильтровать вывод по первому значению за весь или указанный отрезок времени <br />
<code>SELECT instance,MIN(Avg._Disk_Read_Queue_Length) FROM "win_pdisk" GROUP BY instance</code> отфильтровать вывод с отображением минимального значения <br />
<code>SELECT instance,MAX(Avg._Disk_Read_Queue_Length) FROM "win_pdisk" GROUP BY instance</code> отфильтровать вывод с отображением максимального значения <br />
<code>SELECT SUM(Bytes_Received_persec) FROM "win_net" GROUP BY instance</code> суммах всех значений <br />
<code>SELECT COUNT(Bytes_Received_persec) FROM "win_net" WHERE Bytes_Received_persec &gt;= 0 GROUP BY instance</code> кол-во данных, где значение выше или равно 0 <br />
<code>SELECT MEAN(Bytes_Received_persec) FROM "win_net" WHERE Bytes_Received_persec &lt; 1000 GROUP BY instance</code> среднее значение данных с показателем от 0 до 1000 (509)</p>
<p><code>SELECT *,MAX(Value) FROM "HardwareMonitor" WHERE time &gt; now() -1h GROUP BY SensorName,Host</code> создать группы для выявления максимального значения значения стобца Value каждого тэга SensorName и хоста за последний час <br />
<code>SELECT *,MAX(Value) FROM "HardwareMonitor" WHERE time &gt; now() -1h and SensorName = 'CPU_Package' GROUP BY Host</code> масимальное значение CPU_Package за последний час для каждого хоста <br />
<code>SELECT MEAN(Value) FROM "HardwareMonitor" WHERE time &gt; now() -1h and SensorName = 'CPU_Package' GROUP BY Host</code> среднее значение CPU_Package за последний час</p>
<h3 id="policy"><a class="header" href="#policy">POLICY</a></h3>
<p><code>CREATE DATABASE powershell WITH DURATION 48h REPLICATION 1 NAME "del2d"</code> создать БД с политикой хранения 2 дня <br />
<code>CREATE RETENTION POLICY del2h ON powershell DURATION 2h REPLICATION 1</code> создать новую политику хранения для БД <br />
<code>CREATE RETENTION POLICY del6h ON powershell DURATION 6h REPLICATION 1 SHARD DURATION 2h</code> указать период хранения 6 часов + 2 часа до очистки (по умолчанию 1ч или больше) <br />
<code>ALTER RETENTION POLICY del6h ON powershell DEFAULT</code> изменить (ALTER) политику хранения для БД на del6h (DEFAULT) <br />
<code>DROP RETENTION POLICY del2d ON powershell</code> удаление политики хранения приводит к безвозвратному удалению всех измерений (таблиц) и данных, хранящихся в политике хранения <br />
<code>SHOW RETENTION POLICIES ON PowerShell</code> отобразить действующие политики базы данных PowerShell</p>
<h1 id="influxdb-api"><a class="header" href="#influxdb-api">InfluxDB-api</a></h1>
<pre><code class="language-PowerShell">$data = Invoke-RestMethod http://192.168.3.102:8086/query?q="SHOW RETENTION POLICIES ON PowerShell"
$col = $data.results.series.columns
$val = $data.results.series.values
$mass    = @()
$mass   += [string]$col
foreach ($v in $val) {
	$mass += [string]$v
}
$mass = $mass -replace '^','"'
$mass = $mass -replace '$','"'
$mass = $mass -replace '\s','","'
$mass | ConvertFrom-Csv
</code></pre>
<h3 id="api-post"><a class="header" href="#api-post">API POST</a></h3>
<p>Вместо таблиц в InfluxDB имеются измерения. Вместо столбцов в ней есть теги и поля.</p>
<pre><code>   Table                        Tag (string/int)                          Field (double/int)           TIMESTAMP
measurement,Tag_Keys1=Tag_Values1,Tag_Keys2=Tag_Values2 Field_Keys1="Values",Field_Keys2="Values" 0000000000000000000
           1                                           2                                         3

$ip        = "192.168.3.104"
$port      = "8086"
$db        = "powershell"
$table     = "speedtest"
$ipp       = $ip+":"+$port
$url       = "http://$ipp/write?db=$db"
$user      = "admin"
$pass      = "password" | ConvertTo-SecureString -AsPlainText -Force
$cred      = [System.Management.Automation.PSCredential]::new($user,$pass)
$unixtime  = (New-TimeSpan -Start (Get-Date "01/01/1970") -End (Get-Date)).TotalSeconds
$timestamp = ([string]$unixtime -replace "\..+") + "000000000"

Invoke-RestMethod -Method POST -Uri $url -Body "$table,host=$(hostname) download=200000,upload=300000,ping=3 $timestamp"
</code></pre>
<h3 id="api-get"><a class="header" href="#api-get">API GET</a></h3>
<p><code>curl http://192.168.3.104:8086/query --data-urlencode "q=SHOW DATABASES"</code> pwsh7 (ConvertFrom-Json) and bash</p>
<p><code>$dbs = irm "http://192.168.3.104:8086/query?q=SHOW DATABASES"</code> <br />
<code>$dbs = irm "http://192.168.3.104:8086/query?epoch=ms&amp;u=admin&amp;p=password&amp;q=SHOW DATABASES"</code> <br />
<code>$dbs.results.series.values</code></p>
<pre><code class="language-PowerShell">$ip    = "192.168.3.104"
$port  = "8086"
$db    = "powershell"
$table = "speedtest"
$query = "SELECT * FROM $table"
$ipp   = $ip+":"+$port
$url   = "http://$ipp/query?db=$db&amp;q=$query"
$data  = Invoke-RestMethod -Method GET -Uri $url` -Credential $cred 
$data.results.series.name   ` имя таблицы
$data.results.series.columns` столбцы/ключи
$data.results.series.values ` данные построчно
</code></pre>
<h3 id="endpoints"><a class="header" href="#endpoints">Endpoints</a></h3>
<p><a href="https://docs.influxdata.com/influxdb/v1.7/tools/api/">API doc</a></p>
<pre><code class="language-PowerShell">$stats = irm http://192.168.3.104:8086/debug/vars` статистика сервера
$stats."database:powershell".values` кол-во таблиц к БД
$stats.queryExecutor.values` количество query-запросов (обращений к endpoint /query)
$stats.write.values` количество write-запросов
$stats.system.uptime
</code></pre>
<p><code>http://192.168.3.104:8086/debug/requests</code> кол-во клиентских HTTP-запросов к конечным точкам /writeи /query <br />
<code>http://192.168.3.104:8086/debug/pprof</code> <br />
<code>http://192.168.3.104:8086/ping</code> <br />
<code>http://192.168.3.104:8086/query</code> <br />
<code>http://192.168.3.104:8086/write</code></p>
<p><code>http://192.168.3.99:8086/api/v2/setup</code> <br />
<code>http://192.168.3.99:8086/api/v2/config</code> <br />
<code>http://192.168.3.99:8086/api/v2/write</code></p>
<h3 id="pingto-influxdb"><a class="header" href="#pingto-influxdb">PingTo-InfluxDB</a></h3>
<pre><code class="language-PowerShell">while ($true) {
	$tz = (Get-TimeZone).BaseUtcOffset.TotalMinutes
	$unixtime  = (New-TimeSpan -Start (Get-Date "01/01/1970") -End ((Get-Date).AddMinutes(-$tz))).TotalSeconds` -3h UTC
	$timestamp = ([string]$unixtime -replace "\..+") + "000000000"
	$tnc = tnc 8.8.8.8
	$Status = $tnc.PingSucceeded
	$RTime = $tnc.PingReplyDetails.RoundtripTime
	Invoke-RestMethod -Method POST -Uri "http://192.168.3.104:8086/write?db=powershell" -Body "ping,host=$(hostname) status=$status,rtime=$RTime $timestamp"
	sleep 1
}
</code></pre>
<p><code>SELECT * FROM ping WHERE status = false</code></p>
<h3 id="performanceto-influxdb"><a class="header" href="#performanceto-influxdb">PerformanceTo-InfluxDB</a></h3>
<pre><code class="language-PowerShell">function ConvertTo-Encoding ([string]$From, [string]$To) {
    Begin {
        $encFrom = [System.Text.Encoding]::GetEncoding($from)
        $encTo = [System.Text.Encoding]::GetEncoding($to)
    }
    Process {
        $bytes = $encTo.GetBytes($_)
        $bytes = [System.Text.Encoding]::Convert($encFrom, $encTo, $bytes)
        $encTo.GetString($bytes)
    }
}

$localization = (Get-Culture).LCID` текущая локализация
if ($localization -eq 1049) {
	$performance = "\\$(hostname)\Процессор(_Total)\% загруженности процессора" | ConvertTo-Encoding UTF-8 windows-1251` декодировать кириллицу
} else {
	$performance = "\Processor(_Total)\% Processor Time"
}

$tz = (Get-TimeZone).BaseUtcOffset.TotalMinutes
while ($true) {
	$unixtime  = (New-TimeSpan -Start (Get-Date "01/01/1970") -End ((Get-Date).AddMinutes(-$tz))).TotalSeconds` -3h UTC
	$timestamp = ([string]$unixtime -replace "\..+") + "000000000"
	[double]$value = (Get-Counter $performance).CounterSamples.CookedValue.ToString("0.00").replace(",",".")` округлить в тип данных Double
	Invoke-RestMethod -Method POST -Uri "http://192.168.3.104:8086/write?db=powershell" -Body "performance,host=$(hostname),counter=CPU value=$value $timestamp"
	sleep 5
}
</code></pre>
<h3 id="service"><a class="header" href="#service">Service</a></h3>
<pre><code class="language-PowerShell">$powershell_Path = (Get-Command powershell).Source
$NSSM_Path = "C:\NSSM\NSSM-2.24.exe"
$Script_Path = "C:\NSSM\PerformanceTo-InfluxDB.ps1"
$Service_Name = "PerformanceTo-InfluxDB"
&amp; $NSSM_Path install $Service_Name $powershell_Path -ExecutionPolicy Bypass -NoProfile -f $Script_Path
Get-Service $Service_Name | Start-Service
Get-Service $Service_Name | Set-Service -StartupType Automatic
</code></pre>
<h3 id="psinfluxdb"><a class="header" href="#psinfluxdb">PSInfluxDB</a></h3>
<p><code>Install-Module psinfluxdb -Repository NuGet</code> <br />
<code>Get-InfluxUsers -server 192.168.3.102</code> список пользователей на сенвере InfluxDB и права доступа <br />
<code>Get-InfluxDatabases -server 192.168.3.102</code> список баз данных <br />
<code>Get-InfluxDatabases -server 192.168.3.102 -creat -database test</code> создать базу данных <br />
<code>Get-InfluxDatabases -server 192.168.3.102 -delete -database test</code> удалить базу данных <br />
<code>Get-InfluxPolicy -server 192.168.3.102 -database PowerShell</code> список политик хранения указанной базы данных <br />
<code>Get-InfluxPolicy -server 192.168.3.102 -database PowerShell -creat -policyName del2d -hours 48</code> создать политику хранения <br />
<code>Get-InfluxPolicy -server 192.168.3.102 -database PowerShell -policyName del2d -default</code> применить политику хранения к базе данных по умолчанию <br />
<code>Get-InfluxTables -server 192.168.3.102 -database PowerShell</code> список таблиц/измерений в базе данных <br />
<code>$Data = Get-InfluxData -server 192.168.3.102 -database PowerShell -table ping | Format-Table</code> отобразить данные в таблице <br />
<code>$Data | Where-Object {$_.SensorName -match "CPU_Package" -and $_.Value -gt 90} | Format-Table</code> отфильтровать данные по двум параметрам (сенсоры процессора с показателем выше 90) <br />
<code>$influx = Get-InfluxData -server 192.168.3.104 -database PowerShell -table speedtest</code> <br />
<code>Get-InfluxChart -time ($influx.time) -data ($influx.download) -title "SpeedTest Download" -path "C:\Users\Lifailon\Desktop"</code> создать график (WinForms Chart) измерений и сохранить в jpeg-файл</p>
<h1 id="telegraf"><a class="header" href="#telegraf">Telegraf</a></h1>
<p><a href="https://docs.influxdata.com/telegraf/v1.27/plugins/#input-plugins">Plugins</a></p>
<p><code>iwr https://dl.influxdata.com/telegraf/releases/telegraf-1.27.1_windows_amd64.zip -UseBasicParsing -OutFile telegraf-1.27.1_windows_amd64.zip</code> <br />
<code>Expand-Archive .\telegraf-1.27.1_windows_amd64.zip -DestinationPath "C:\Telegraf"</code> <br />
<code>rm telegraf-1.27.1_windows_amd64.zip</code> <br />
<code>cd C:\Telegraf</code> <br />
<code>.\telegraf.exe -sample-config --input-filter cpu:mem:dns_query --output-filter influxdb &gt; telegraf_nt.conf</code> создать конфигурацию с выбарнными плагинами для сбора метрик <br />
<code>Start-Process notepad++ C:\Telegraf\telegraf_nt.conf</code></p>
<pre><code>[[outputs.influxdb]]
  urls = ["http://192.168.3.104:8086"]
  database = "telegraf_nt"
  username = "user"
  password = "pass"
[[inputs.cpu]]
  percpu = false
  totalcpu = true
[[inputs.dns_query]]
  servers = ["8.8.8.8"]
  network = "udp"
  domains = ["."]
  record_type = "A"
  port = 53
  timeout = "2s"
</code></pre>
<p><code>.\telegraf.exe --test -config C:\Telegraf\telegraf_nt.conf</code> тест конфигурации (получения метрик с выводом в консоль) <br />
<code>C:\Telegraf\telegraf.exe -config C:\Telegraf\telegraf_nt.conf</code> запустить telegraf (тест отправки данных) <br />
<code>.\telegraf.exe --config "C:\Telegraf\telegraf_nt.conf" --service install</code> создать службу <br />
<code>Get-Service telegraf | Start-Service</code> <br />
<code>.\telegraf.exe --service uninstall</code></p>
<p><code>USE telegraf</code> <br />
<code>SELECT usage_idle,usage_system,usage_user FROM cpu</code></p>
<h1 id="elasticsearch"><a class="header" href="#elasticsearch">Elasticsearch</a></h1>
<p><code>Install-Module -Name Elastic.Console -AllowPrerelease</code> <a href="https://github.com/elastic/powershell/blob/master/Elastic.Console/README.md">github source</a> <br />
<code>Get-Command -Module Elastic.Console</code> <br />
<code>Get-ElasticsearchVersion</code> <br />
<code>Set-ElasticsearchVersion 7.3.0</code> <br />
<code>Invoke-Elasticsearch</code> REST API запросы</p>
<h1 id="cdata"><a class="header" href="#cdata">CData</a></h1>
<p><a href="https://www.powershellgallery.com/profiles/CData">PowerShell Gallery CData</a> <br />
<a href="https://www.cdata.com/kb/tech/elasticsearch-ado-powershell.rst">Automate Elasticsearch Integration Tasks from PowerShell</a></p>
<p><code>Install-Module ElasticsearchCmdlets</code> <a href="https://www.powershellgallery.com/packages/ElasticsearchCmdlets/23.0.8565.1">пакет драйвера в psgallery</a> <br />
<code>Import-Module ElasticsearchCmdlets</code> <br />
<code>Get-Command -Module ElasticsearchCmdlets</code></p>
<pre><code class="language-PowerShell">$elasticsearch = Connect-Elasticsearch  -Server "$Server" -Port "$Port" -User "$User" -Password "$Password"
$shipcity = "New York"
$orders = Select-Elasticsearch -Connection $elasticsearch -Table "Orders" -Where "ShipCity = `'$ShipCity`'"` поиск и получение данных
$orders = Invoke-Elasticsearch -Connection $elasticsearch -Query 'SELECT * FROM Orders WHERE ShipCity = @ShipCity' -Params @{'@ShipCity'='New York'}` SQL запросы
</code></pre>
<h3 id="ado-net-assembly"><a class="header" href="#ado-net-assembly">ADO NET Assembly</a></h3>
<p><code>Install-Package CData.Elasticsearch</code> <a href="https://www.nuget.org/packages/CData.Elasticsearch">пакет драйвера в nuget</a> <br />
<code>[Reflection.Assembly]::LoadFile("C:\Program Files\PackageManagement\NuGet\Packages\CData.Elasticsearch.23.0.8565\lib\net40\System.Data.CData.Elasticsearch.dll")</code></p>
<pre><code class="language-PowerShell">$connect = New-Object System.Data.CData.Elasticsearch.ElasticsearchConnection("Server=127.0.0.1;Port=9200;User=admin;Password=123456;")
$connect.Open()
$sql = "SELECT OrderName, Freight from Orders"
$da = New-Object System.Data.CData.Elasticsearch.ElasticsearchDataAdapter($sql, $conn)
$dt = New-Object System.Data.DataTable
$da.Fill($dt)
$dt.Rows | foreach {
Write-Host $_.ordername $_.freight
}
</code></pre>
<h3 id="update-2"><a class="header" href="#update-2">UPDATE</a></h3>
<pre><code class="language-PowerShell">Update-Elasticsearch -Connection $Elasticsearch -Columns @('OrderName','Freight') -Values @('MyOrderName', 'MyFreight') -Table Orders -Id "MyId"

$cmd =  New-Object System.Data.CData.Elasticsearch.ElasticsearchCommand("UPDATE Orders SET ShipCity='New York' WHERE Id = @myId", $conn)
$cmd.Parameters.Add(new System.Data.CData.Elasticsearch.ElasticsearchParameter("@myId","10456255-0015501366"))
$cmd.ExecuteNonQuery()
</code></pre>
<h3 id="insert-1"><a class="header" href="#insert-1">INSERT</a></h3>
<pre><code class="language-PowerShell">Add-Elasticsearch -Connection $Elasticsearch -Table Orders -Columns @("OrderName", "Freight") -Values @("MyOrderName", "MyFreight")

$cmd =  New-Object System.Data.CData.Elasticsearch.ElasticsearchCommand("INSERT INTO Orders (ShipCity) VALUES (@myShipCity)", $conn)
$cmd.Parameters.Add(new System.Data.CData.Elasticsearch.ElasticsearchParameter("@myShipCity","New York"))
$cmd.ExecuteNonQuery()
</code></pre>
<h3 id="delete-1"><a class="header" href="#delete-1">DELETE</a></h3>
<pre><code class="language-PowerShell">Remove-Elasticsearch -Connection $Elasticsearch -Table "Orders" -Id "MyId"

$cmd =  New-Object System.Data.CData.Elasticsearch.ElasticsearchCommand("DELETE FROM Orders WHERE Id=@myId", $conn)
$cmd.Parameters.Add(new System.Data.CData.Elasticsearch.ElasticsearchParameter("@myId","001d000000YBRseAAH"))
$cmd.ExecuteNonQuery()
</code></pre>
<h1 id="odbc"><a class="header" href="#odbc">ODBC</a></h1>
<p><code>Get-Command -Module Wdac</code> <br />
<code>Get-OdbcDriver | ft</code> список установленных драйверов</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-client-apps-ps1.html">Elasticsearch ODBC драйвер для доступа к данным Elasticsearch из Microsoft PowerShell</a></p>
<pre><code class="language-PowerShell">$connectstring = "DSN=Local Elasticsearch;"
$sql = "SELECT * FROM library"
$conn = New-Object System.Data.Odbc.OdbcConnection($connectstring)
$conn.open()
$cmd = New-Object system.Data.Odbc.OdbcCommand($sql,$conn)
$da = New-Object system.Data.Odbc.OdbcDataAdapter($cmd)
$dt = New-Object system.Data.datatable
$null = $da.fill($dt)
$conn.close()
$dt
</code></pre>
<h1 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h1>
<h3 id="odbc-driver"><a class="header" href="#odbc-driver">ODBC Driver</a></h3>
<p><a href="https://www.postgresql.org/ftp/odbc/versions/msi/">Скачать и установить драйвер</a></p>
<pre><code class="language-PowerShell">$dbServer = "192.168.3.101"
$port = "5432"
$dbName = "test"
$dbUser = "admin"
$dbPass = "admin"
$szConnect = "Driver={PostgreSQL Unicode(x64)};Server=$dbServer;Port=$port;Database=$dbName;Uid=$dbUser;Pwd=$dbPass;" 

$cnDB = New-Object System.Data.Odbc.OdbcConnection($szConnect)
$dsDB = New-Object System.Data.DataSet
try {
    $cnDB.Open()
    $adDB = New-Object System.Data.Odbc.OdbcDataAdapter
    $adDB.SelectCommand = New-Object System.Data.Odbc.OdbcCommand("SELECT id, name, age, login FROM public.users" , $cnDB)
    $adDB.Fill($dsDB)
    $cnDB.Close()
}
catch [System.Data.Odbc.OdbcException] {
    $_.Exception
    $_.Exception.Message
    $_.Exception.ItemName
}
foreach ($row in $dsDB[0].Tables[0].Rows) {
    $row.login
    $row.age
}
</code></pre>
<h3 id="npgsql"><a class="header" href="#npgsql">npgsql</a></h3>
<p><a href="https://github.com/npgsql/npgsql">Source</a> <br />
<a href="https://www.nuget.org/packages/Npgsql.EntityFrameworkCore.PostgreSQL">Package</a></p>
<pre><code class="language-PowerShell"># Подключаем сборку Npgsql
Add-Type -Path "$home\Documents\Npgsql.PostgreSQL\8.0.4\net8.0\Npgsql.EntityFrameworkCore.PostgreSQL.dll"
# Определяем строку подключения к базе данных PostgreSQL
$connString = "Host=myserver;Username=mylogin;Password=mypass;Database=mydatabase"
# Создаем объект подключения
$conn = New-Object Npgsql.NpgsqlConnection($connString)
# Открываем соединение с базой данных
$conn.Open()
try {
    # Создаем SQL команду
    $cmd = $conn.CreateCommand()
    $cmd.CommandText = "INSERT INTO data (some_field) VALUES (@p)"
    # Добавляем параметр и его значение
    $param = $cmd.Parameters.Add("p", [NpgsqlTypes.NpgsqlDbType]::Text)
    $param.Value = "Hello world"
    # Выполняем команду
    $cmd.ExecuteNonQuery() | Out-Null
} finally {
    $cmd.Dispose()
}
# Извлекаем все строки из таблицы
try {
    # Создаем команду SQL для извлечения данных
    $cmd = $conn.CreateCommand()
    $cmd.CommandText = "SELECT some_field FROM data"
    # Выполняем команду и получаем объект чтения данных
    $reader = $cmd.ExecuteReader()
    # Читаем и выводим данные построчно
    while ($reader.Read()) {
        Write-Host $reader.GetString(0)
    }
} finally {
    # Освобождаем ресурсы чтения данных и команды
    $reader.Dispose()
    $cmd.Dispose()
}
# Закрываем соединение с базой данных
$conn.Close()
$conn.Dispose()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>+++
title = "API"
[extra]
toc = true
toc_sidebar = true
go_to_top = true
+++</p>
<p>Заметки по работе с <code>REST API</code> через <strong>PowerShell</strong> и <strong>curl</strong>.</p>
<hr />
<h1 id="rest-api"><a class="header" href="#rest-api">REST API</a></h1>
<p><code>$url = "https://habr.com/ru/rss/users/Lifailon/publications/articles/?fl=ru"</code> RSS лента публикаций на Habr <br />
<code>Invoke-RestMethod $url</code> <br />
<code>$iwr = Invoke-WebRequest -Uri $url</code> <br />
<code>$iwr | Get-Member</code> <br />
<code>$iwr.Content</code> <br />
<code>$iwr.StatusCode -eq 200</code> <br />
<code>$iwr.Headers</code> <br />
<code>$iwr.ParsedHtml | Select lastModified</code> <br />
<code>$iwr.Links | fl title,innerText,href</code> <br />
<code>$iwr.Images.src</code></p>
<h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<p><strong>GET</strong> - Read <br />
<strong>POST</strong> - Create <br />
<strong>PATCH</strong> - Partial update/modify <br />
<strong>PUT</strong> - Update/replace <br />
<strong>DELETE</strong> - Remove</p>
<h3 id="download-image"><a class="header" href="#download-image">Download Image</a></h3>
<pre><code class="language-PowerShell">function Download-Image {
param (
    [Parameter(Mandatory = $True)]$url
)
    $folder = $url -replace "http.+://" -replace "/","-" -replace "-$"
    $path = "$home\Pictures\$folder"
    if (Test-Path $path) {
        Remove-Item $path -Recurse -Force
        New-Item -ItemType Directory $path &gt; $null
    } else {
        New-Item -ItemType Directory $path &gt; $null
    }
    $irm = Invoke-WebRequest -Uri $url
    foreach ($img in $irm.Images.src) {
        $name = $img -replace ".+/"
        Start-Job {
            Invoke-WebRequest $using:img -OutFile "$using:path\$using:name"
        } &gt; $null
    }
    while ($True){
        $status_job = (Get-Job).State[-1]
        if ($status_job -like "Completed"){
        Get-Job | Remove-Job -Force
        break
    }}
    $count_all = $irm.Images.src.Count
    $count_down = (Get-Item $path\*).count
    "Downloaded $count_down of $count_all files to $path"
}
</code></pre>
<p><code>Download-Image -url https://losst.pro/</code></p>
<h3 id="token"><a class="header" href="#token">Token</a></h3>
<pre><code class="language-PowerShell">https://veeam-11:9419/swagger/ui/index.html
$Header = @{
    "x-api-version" = "1.0-rev2"
}
$Body = @{
    "grant_type" = "password"
    "username" = "$login"
    "password" = "$password"
}
$vpost = iwr "https://veeam-11:9419/api/oauth2/token" -Method POST -Headers $Header -Body $Body -SkipCertificateCheck
$vtoken = (($vpost.Content) -split '"')[3]
</code></pre>
<h3 id="get"><a class="header" href="#get">GET</a></h3>
<pre><code class="language-PowerShell">$token = $vtoken | ConvertTo-SecureString -AsPlainText –Force
$vjob = iwr "https://veeam-11:9419/api/v1/jobs" -Method GET -Headers $Header -Authentication Bearer -Token $token -SkipCertificateCheck

$Header = @{
    "x-api-version" = "1.0-rev1"
    "Authorization" = "Bearer $vtoken"
}
$vjob = iwr "https://veeam-11:9419/api/v1/jobs" -Method GET -Headers $Header -SkipCertificateCheck
$vjob = $vjob.Content | ConvertFrom-Json

$vjob = Invoke-RestMethod "https://veeam-11:9419/api/v1/jobs" -Method GET -Headers $Header -SkipCertificateCheck
$vjob.data.virtualMachines.includes.inventoryObject
</code></pre>
<h3 id="cookie"><a class="header" href="#cookie">Cookie</a></h3>
<p>Получить hash торрент файла на сайте Кинозал</p>
<pre><code class="language-PowerShell">function Get-KinozalTorrentHash {
    param (
        [Parameter(Mandatory = $True)][string]$id,
        [Parameter(Mandatory = $True)][string]$cookies
    )
    $url = "https://kinozal.tv/get_srv_details.php?id=$($id)&amp;action=2"
    $cookies = "uid=...+"
    $headers = @{
        "User-Agent" = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
        "Cookie" = $cookies
    }
    $result = Invoke-RestMethod -Uri $url -Headers $headers -Method Get
    $result -match "Инфо хеш: (.+)&lt;/li&gt;&lt;li&gt;Размер" | Out-Null
    return $Matches[1]
}
</code></pre>
<p><code>$id = 1656552</code> <br />
<code>$cookies = "uid=..."</code> получить cookie в браузере на вкладке сеть из загловка запросов после авторизации на сайте <br />
<code>Get-KinozalTorrentHash $id $cookies</code></p>
<h1 id="pode"><a class="header" href="#pode">Pode</a></h1>
<p><a href="https://github.com/Badgerati/Pode">PowerShell Web framework</a> для создания <code>REST API</code>, Веб-сайтов, <code>TCP</code> и <code>SMTP</code> серверов.</p>
<pre><code class="language-PowerShell">Start-PodeServer {
    Add-PodeEndpoint -Address localhost -Port "8080" -Protocol "HTTP"
    ### Get info endpoints
    Add-PodeRoute -Path "/" -Method "GET" -ScriptBlock {
        Write-PodeJsonResponse -Value @{
        "service"="/api/service";
        "process"="/api/process"
        }
    }
    ### GET
    Add-PodeRoute -Path "/api/service" -Method "GET" -ScriptBlock {
        Write-PodeJsonResponse -Value $(
            Get-Service | Select-Object Name,@{
                Name="Status"; Expression={[string]$_.Status}
            },@{
                Name="StartType"; Expression={[string]$_.StartType}
            } | ConvertTo-Json
        )
    }
    Add-PodeRoute -Path "/api/process" -Method "GET" -ScriptBlock {
        Write-PodeJsonResponse -Value $(
            Get-Process | Sort-Object -Descending CPU | Select-Object -First 15 ProcessName,
            @{Name="ProcessorTime"; Expression={$_.TotalProcessorTime -replace "\.\d+$"}},
            @{Name="Memory"; Expression={[string]([int]($_.WS / 1024kb))+"MB"}},
            @{Label="RunTime"; Expression={((Get-Date) - $_.StartTime) -replace "\.\d+$"}}
        )
    }
    Add-PodeRoute -Path "/api/process-html" -Method "GET" -ScriptBlock {
        Write-PodeHtmlResponse -Value (
            Get-Process | Sort-Object -Descending CPU | Select-Object -First 15 ProcessName,
            @{Name="ProcessorTime"; Expression={$_.TotalProcessorTime -replace "\.\d+$"}},
            @{Name="Memory"; Expression={[string]([int]($_.WS / 1024kb))+"MB"}},
            @{Label="RunTime"; Expression={((Get-Date) - $_.StartTime) -replace "\.\d+$"}} # Auto ConvertTo-Html
        )
    }
    ### POST
    Add-PodeRoute -Path "/api/service" -Method "POST" -ScriptBlock {
        # https://pode.readthedocs.io/en/latest/Tutorials/WebEvent/
        # $WebEvent | Out-Default
        $Value = $WebEvent.Data["ServiceName"]
        $Status = (Get-Service -Name $Value).Status
        Write-PodeJsonResponse -Value @{
            "Name"="$Value";
            "Status"="$Status";
        }
    }
}
</code></pre>
<p><code>irm http://localhost:8080/api/service -Method Get</code> <br />
<code>irm http://localhost:8080/api/process -Method Get</code> <br />
<code>http://localhost:8080/api/process-html</code> использовать браузер <br />
<code>irm http://localhost:8080/api/service -Method Post -Body @{"ServiceName" = "AnyDesk"}</code></p>
<h1 id="selenium"><a class="header" href="#selenium">Selenium</a></h1>
<p><code>Invoke-Expression(New-Object Net.WebClient).DownloadString("https://raw.githubusercontent.com/Lifailon/Deploy-Selenium/rsa/Deploy-Selenium-Drivers.ps1")</code> установка всех драйверов и Chromium соответствующий версии для драйвера</p>
<pre><code class="language-powershell">$path = "$home\Documents\Selenium\"
$log = "$path\ChromeDriver.log"
$ChromeDriver = "$path\ChromeDriver.exe"
$WebDriver = "$path\WebDriver.dll"
$SupportDriver = "$path\WebDriver.Support.dll"
$Chromium = (Get-ChildItem $path -Recurse | Where-Object Name -like chrome.exe).FullName
Add-Type -Path $WebDriver
Add-Type -Path $SupportDriver
try {
    $ChromeOptions = New-Object OpenQA.Selenium.Chrome.ChromeOptions # создаем объект с настройками запуска браузера
    $ChromeOptions.BinaryLocation = $Chromium # передаем путь до исполняемого файла, который отвечает за запуск браузера
    $ChromeOptions.AddArgument("start-maximized") # добавляем аргумент, который позволяет запустить браузер на весь экран
    #$ChromeOptions.AddArgument("start-minimized") # запускаем браузер в окне
    #$ChromeOptions.AddArgument("window-size=400,800") # запускаем браузер с заданными размерам окна в пикселях
    $ChromeOptions.AcceptInsecureCertificates = $True # игнорировать предупреждение на сайтах с не валидным сертификатом
    #$ChromeOptions.AddArgument("headless") # скрывать окно браузера при запуске
    $ChromeDriverService = [OpenQA.Selenium.Chrome.ChromeDriverService]::CreateDefaultService($ChromeDriver) # создаем объект настроек службы драйвера
    $ChromeDriverService.HideCommandPromptWindow = $True # отключаем весь вывод логирования драйвера в консоль (этот вывод нельзя перенаправить)
    $ChromeDriverService.LogPath = $log # указать путь до файла с журналом
    $ChromeDriverService.EnableAppendLog = $True # не перезаписывать журнал при каждом новом запуске
    #$ChromeDriverService.EnableVerboseLogging = $True # кроме INFO и ошибок, записывать DEBUG сообщения
    $Selenium = New-Object OpenQA.Selenium.Chrome.ChromeDriver($ChromeDriverService, $ChromeOptions) # инициализируем запуск с указанными настройками

    $Selenium.Navigate().GoToUrl("https://google.com") # переходим по указанной ссылке в браузере
    #$Selenium.Manage().Window.Minimize() # свернуть окно браузера после запуска и перехода по нужному url (что бы считать страницу корректно)
    # Ищем поле для ввода текста:
    $Search = $Selenium.FindElements([OpenQA.Selenium.By]::Id('APjFqb'))
    $Search = $Selenium.FindElements([OpenQA.Selenium.By]::XPath('//*[@id="APjFqb"]'))
    $Search = $Selenium.FindElements([OpenQA.Selenium.By]::Name('q'))
    $Search = $Selenium.FindElements([OpenQA.Selenium.By]::XPath('//*[@name="q"]'))
    $Search = $Selenium.FindElements([OpenQA.Selenium.By]::ClassName('gLFyf'))
    $Search = $Selenium.FindElements([OpenQA.Selenium.By]::CssSelector('[jsname="yZiJbe"]'))
    $Search = $Selenium.FindElements([OpenQA.Selenium.By]::TagName('textarea')) | Where-Object ComputedAccessibleRole -eq combobox
    $Search.SendKeys("calculator online") # передаем текст выбранному элементу
    $Search.SendKeys([OpenQA.Selenium.Keys]::Enter) # нажимаем Enter для вызова функции поиска

    Start-Sleep 1
    $div = $Selenium.FindElements([OpenQA.Selenium.By]::TagName("div"))
    $2 = $div | Where-Object {($_.ComputedAccessibleRole -eq "button") -and ($_.ComputedAccessibleLabel -eq "2")}
    $2.Click()
    $2.Click()
    $plus = $div | Where-Object {($_.ComputedAccessibleRole -eq "button") -and ($_.Text -eq "+")}
    $plus.Click()
    $3 = $Selenium.FindElement([OpenQA.Selenium.By]::CssSelector('[jsname="KN1kY"]'))
    $3.Click()
    $3.Click()
    $sum = $Selenium.FindElement([OpenQA.Selenium.By]::CssSelector('[jsname="Pt8tGc"]'))
    $sum.Click()
    $result = $Selenium.FindElement([OpenQA.Selenium.By]::CssSelector('[jsname="VssY5c"]')).Text
    Write-Host "Result: $result" -ForegroundColor Green
}
finally {
    $Selenium.Close()
    $Selenium.Quit()
}
</code></pre>
<h3 id="selenium-modules"><a class="header" href="#selenium-modules">Selenium modules</a></h3>
<pre><code class="language-PowerShell">Invoke-RestMethod https://raw.githubusercontent.com/Lifailon/Selenium-Modules/rsa/Modules/Get-GPT/Get-GPT.psm1 | Out-File -FilePath "$(New-Item -Path "$($($Env:PSModulePath -split ";")[0])\Get-GPT" -ItemType Directory -Force)\Get-GPT.psm1" -Force
</code></pre>
<p><code>Get-GPT "Исполняй роль калькулятора. Посчитай сумму чисел: 22+33"</code></p>
<pre><code class="language-PowerShell">Invoke-RestMethod https://raw.githubusercontent.com/Lifailon/Selenium-Modules/rsa/Modules/Get-Translation/Get-Translation.psm1 | Out-File -FilePath "$(New-Item -Path "$($($Env:PSModulePath -split ";")[0])\Get-Translation" -ItemType Directory -Force)\Get-Translation.psm1" -Force
</code></pre>
<p><code>Get-Translation -Provider DeepL -Text "I translating the text"</code> <br />
<code>Get-Translation -Provider DeepL -Text "Я перевожу текст"</code> <br />
<code>Get-Translation -Provider Google -Text "I translating the text"</code> <br />
<code>Get-Translation -Provider Google -Text "Я перевожу текст" -Language en</code></p>
<pre><code class="language-PowerShell">Invoke-RestMethod https://raw.githubusercontent.com/Lifailon/Selenium-Modules/rsa/Modules/Get-SpeedTest/Get-SpeedTest.psm1 | Out-File -FilePath "$(New-Item -Path "$($($Env:PSModulePath -split ";")[0])\Get-SpeedTest" -ItemType Directory -Force)\Get-SpeedTest.psm1" -Force
</code></pre>
<p><code>Get-SpeedTest -Provider Libre</code> <br />
<code>Get-SpeedTest -Provider Open</code> <br />
<code>Get-SpeedTest -Provider Ookla</code></p>
<h1 id="ie"><a class="header" href="#ie">IE</a></h1>
<p><code>$ie.document.IHTMLDocument3_getElementsByTagName("input")  | select name</code> получить имена всех Input Box <br />
<code>$ie.document.IHTMLDocument3_getElementsByTagName("button") | select innerText</code> получить имена всех Button <br />
<code>$ie.Document.documentElement.innerHTML</code> прочитать сырой Web Content (&lt;input name="login" tabindex="100" class="input__control input__input" id="uniq32005644019429136" spellcheck="false" placeholder="Логин") <br />
<code>$All_Elements = $ie.document.IHTMLDocument3_getElementsByTagName("*")</code> забрать все элементы <br />
<code>$Go_Button = $All_Elements | ? innerText -like "go"</code> поиск элемента по имени <br />
<code>$Go_Button | select ie9_tagName</code> получить TagName (SPAN) для быстрого дальнейшего поиска <br />
<code>$SPAN_Elements = $ie.document.IHTMLDocument3_getElementsByTagName("SPAN")</code></p>
<pre><code class="language-PowerShell">$ie = New-Object -ComObject InternetExplorer.Application
$ie.navigate("https://yandex.ru")
$ie.visible = $true
$ie.document.IHTMLDocument3_getElementByID("login").value = "Login"
$ie.document.IHTMLDocument3_getElementByID("passwd").value = "Password"
$Button_Auth = ($ie.document.IHTMLDocument3_getElementsByTagName("button")) | ? innerText -match "Войти"
$Button_Auth.Click()
$Result = $ie.Document.documentElement.innerHTML
$ie.Quit()
</code></pre>
<h1 id="llm"><a class="header" href="#llm">LLM</a></h1>
<h2 id="openai"><a class="header" href="#openai">OpenAI</a></h2>
<p>Пример запроса для перевода текста</p>
<pre><code class="language-PowerShell">$text = "The OpenAI API uses API keys for authentication. You can create API keys at a user or service account level." # https://platform.openai.com/docs/api-reference/authentication
$toLang = "Russian"
$presetPrompt = "Translate the following text into $toLang :
$text
Respond ONLY with the translated text. Do not include any other explanations, context, or comments.
"
$apiKey = "sk-proj-XXXXXXXXXX"
$apiUrl = "https://api.openai.com/v1/chat/completions"

$body = @{
    model = "gpt-4o-mini"
    messages = @(@{
        role = "user";
        content = $presetPrompt
    })
    temperature = 0.7
} | ConvertTo-Json -Depth 10 -Compress

$response = Invoke-RestMethod -Uri $apiUrl -Method Post -Headers @{
    "Content-Type" = "application/json"
    "Authorization" = "Bearer $apiKey"
} -Body $body

$response.choices.message.content
</code></pre>
<h2 id="mock"><a class="header" href="#mock">Mock</a></h2>
<p>Создаем серверную заглушку для <code>API</code> OpenAI через <a href="https://github.com/typicode/json-server">JSON Server</a></p>
<p><code>npm install -g json-server@0.17.4</code></p>
<p>Конфигурация ответов в файле <code>openai.json</code></p>
<pre><code class="language-json">{
  "completions": {
    "model": "gpt-4o-mini-2024-07-18",
    "choices": [
      {
        "message": {
          "role": "assistant",
          "content": "Response from JSON Server",
        },
        "finish_reason": "stop"
      }
    ]
  }
}
</code></pre>
<p>Настройка маршрутизации в файле <code>routes.json</code></p>
<pre><code class="language-json">{
    "/v1/chat/completions": "/completions"
}
</code></pre>
<p>Конфигурация сервера в файле <code>json-server.json</code></p>
<pre><code class="language-json">{
    "port": 3001
}
</code></pre>
<p>Запускаем сервер:</p>
<p><code>json-server --watch openai.json --routes routes.json</code></p>
<p>Делаем запрос:</p>
<p><code>$(Invoke-RestMethod -Uri "http://localhost:3001/v1/chat/completions").choices.message.content</code></p>
<h2 id="openrouter"><a class="header" href="#openrouter">OpenRouter</a></h2>
<p>Регестрируем аккаунт на <a href="https://openrouter.ai">OpenRouter</a> через Google, выпускаем <a href="https://openrouter.ai/settings/keys">api ключ</a> и выбираем <a href="https://openrouter.ai/models?max_price=0">бесплатную модель</a>.</p>
<pre><code class="language-PowerShell">$OPENROUTER_API_KEY = "sk-or-v1-KEY"
$OPENROUTER_MODEL = "deepseek/deepseek-r1:free"
$headers = @{
    "Content-Type"  = "application/json"
    "Authorization" = "Bearer $OPENROUTER_API_KEY"
}
$body = @{
    "model" = $OPENROUTER_MODEL
    "messages" = @(
        @{
            "role"    = "system"
            "content" = "Your role is a translator. You only translate the text into Russian and do not analyze the answer."
        },
        @{
            "role"    = "user"
            "content" = "Hello! I translate the text into English!"
        }
    )
} | ConvertTo-Json -Depth 10 -Compress
$response = Invoke-RestMethod -Uri "https://openrouter.ai/api/v1/chat/completions" -Method Post -Headers $headers -Body $body
$response.choices.message.content
</code></pre>
<h2 id="lm-studio"><a class="header" href="#lm-studio">LM Studio</a></h2>
<p><code>API</code> в <a href="https://lmstudio.ai">LM Studio</a> совместим с OpenAI</p>
<p>Получить список моделей:</p>
<pre><code class="language-PowerShell">$(Invoke-RestMethod -Uri "http://127.0.0.1:1234/v1/models/").data.id
deepseek-r1-distill-llama-8b
llama-3.2-3b-instruct
text-embedding-nomic-embed-text-v1.5
</code></pre>
<p>Режим чата (когда <code>stream</code> установлен в <code>True</code>, ответ приходит по частям):</p>
<pre><code class="language-bash">curl http://127.0.0.1:1234/v1/chat/completions `
    -H "Content-Type: application/json" `
    -d '{
    "model": "deepseek-r1-distill-llama-8b",
    "messages": [ 
        { "role": "system", "content": "Только переводишь текст на англйский язык, не анализируешь ответ и не пишешь ничего дополнительного." },
        { "role": "user", "content": "Привет! Я перевожу текст на англйский язык!" }
    ], 
    "temperature": 0.7, 
    "max_tokens": -1,
    "stream": false
}'
</code></pre>
<h2 id="ollama"><a class="header" href="#ollama">Ollama</a></h2>
<pre><code class="language-PowerShell">cd $home\Downloads
$versionLatest = $(Invoke-RestMethod "https://api.github.com/repos/ollama/ollama/releases/latest").tag_name
irm https://github.com/ollama/ollama/releases/download/${versionLatest}/ollama-windows-amd64.zip -OutFile ollama.zip
Expand-Archive -Path ollama.zip -OutputPath ".\ollama" # -DestinationPath for Windows PowerShell 5.1
Remove-Item ollama.zip; cd ollama
</code></pre>
<p><code>.\ollama serve</code> запускаем сервер <br />
<code>.\ollama pull mistral:7b-instruct</code> загружаем модель (https://ollama.com/library/mistral) <br />
<code>.\ollama run mistral</code> запустить консоль для общения с LLM в режиме чата</p>
<pre><code class="language-PowerShell"># Отправляем API запрос
$data = curl -sS -X POST http://localhost:11434/api/generate -d '{
  "model": "mistral",
  "prompt":"Return only the word test in the answer"
}'
# Собираем ответ из частей response
[string]$($data | ConvertFrom-Json).response.trim()
</code></pre>
<h2 id="gigachat"><a class="header" href="#gigachat">GigaChat</a></h2>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p><a href="https://developers.sber.ru/gigachat/login">Developers chat</a></p>
<ul>
<li>Установка сертификатов:</li>
</ul>
<p><code>Invoke-WebRequest "https://gu-st.ru/content/lending/russian_trusted_root_ca_pem.crt" -OutFile "$home\Downloads\russian_trusted_root_ca.cer"</code> скачать сертификат минцифры <br />
<code>Invoke-WebRequest "https://gu-st.ru/content/lending/russian_trusted_sub_ca_pem.crt" -OutFile "$home\Downloads\russian_trusted_sub_ca.cer"</code> <br />
<code>Import-Certificate -FilePath "$home\Downloads\russian_trusted_root_ca.cer" -CertStoreLocation "Cert:\CurrentUser\Root"</code> установить сертификат минцифры <br />
<code>Import-Certificate -FilePath "$home\Downloads\russian_trusted_sub_ca.cer" -CertStoreLocation "Cert:\CurrentUser\CA"</code></p>
<ul>
<li>
<ol start="2">
<li>Авторизация по Sber ID и генерация новых авторизационных данных для получения токена: <a href="https://developers.sber.ru/studio">Developers</a> (время жизни 30 минут)</li>
</ol>
</li>
<li>
<ol start="3">
<li>Формирование авторизационных данных в формате Base64 из Client ID и Client Secret:</li>
</ol>
</li>
</ul>
<pre><code class="language-PowerShell">$Client_ID     = "7e6d2f9f-825e-49b7-98f4-62fbb7506427" # [System.Guid]::Parse("7e6d2f9f-825e-49b7-98f4-62fbb7506427")
$Client_Secret = "c35113ee-6757-47ba-9853-ea1d0d9db1ef" # [System.Guid]::Parse("c35113ee-6757-47ba-9853-ea1d0d9db1ef")
$Client_Join   = $Client_ID+":"+$Client_Secret # объединяем два UUID в одну строку, разделяя их символом ':'
$Bytes         = [System.Text.Encoding]::UTF8.GetBytes($Client_Join) # преобразуем строку в массив байт
$Cred_Base64   = [Convert]::ToBase64String($Bytes) # кодируем байты в строку Base64
</code></pre>
<ul>
<li>
<ol start="4">
<li>Получение токена:</li>
</ol>
</li>
</ul>
<p><code>$Cred_Base64   = "N2U2ZDJmOWYtODI1ZS00OWI3LTk4ZjQtNjJmYmI3NTA2NDI3OmIyYzgwZmZmLTEzOGUtNDg1Mi05MjgwLWE2MGI4NTc0YTM2MQ=="</code> <br />
<code>$UUID = [System.Guid]::NewGuid()</code> генерируем UUID для журналирования входящих вызовов и разбора инцидентов</p>
<pre><code class="language-PowerShell">$url = "https://ngw.devices.sberbank.ru:9443/api/v2/oauth"
$headers = @{
    "Authorization" = "Basic $Cred_Base64"
    "RqUID" = "$UUID"
    "Content-Type" = "application/x-www-form-urlencoded"
}
$body = @{
    scope = "GIGACHAT_API_PERS"
}
$GIGA_TOKEN = $(Invoke-RestMethod -Uri $url -Method POST -Headers $headers -Body $body).access_token
</code></pre>
<ul>
<li>
<ol start="5">
<li>Параметры:</li>
</ol>
</li>
</ul>
<pre><code class="language-PowerShell">[string]$content = "Посчитай сумму чисел: 22+33"
[string]$role = "user" # роль автора сообщения (user/assistant/system)
[float]$temperature = 0.7 # температура выборки в диапазоне от 0 до 2. Чем выше значение, тем более случайным будет ответ модели.
[float]$top_p = 0.1 # используется как альтернатива temperature и изменяется в диапазоне от 0 до 1. Задает вероятностную массу токенов, которые должна учитывать модель. Так, если передать значение 0.1, модель будет учитывать только токены, чья вероятностная масса входит в верхние 10%.
[int64]$n = 1 # количество вариантов ответов (1..4), которые нужно сгенерировать для каждого входного сообщения
[int64]$max_tokens = 512 # максимальное количество токенов, которые будут использованы для создания ответов
[boolean]$stream = $false # передавать сообщения по частям в потоке
</code></pre>
<ul>
<li>
<ol start="6">
<li>Составление запросов:</li>
</ol>
</li>
</ul>
<pre><code class="language-PowerShell">$url = "https://gigachat.devices.sberbank.ru/api/v1/chat/completions"
$headers = @{
    "Authorization" = "Bearer $GIGA_TOKEN"
    "Content-Type" = "application/json"
}

$(Invoke-RestMethod -Uri "https://gigachat.devices.sberbank.ru/api/v1/models" -Headers $headers).data # список доступных моделей

$body = @{
    model = "GigaChat:latest"
    messages = @(
        @{
            role = $role
            content = $content
        }
    )
    temperature = $temperature
	n = $n
	max_tokens = $max_tokens
	stream = $stream
} | ConvertTo-Json
$Request = Invoke-RestMethod -Method POST -Uri $url -Headers $headers -Body $body
$Request.choices.message.content
</code></pre>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<ul>
<li>Установка сертификатов в Ubuntu:</li>
</ul>
<p><code>wget https://gu-st.ru/content/lending/russian_trusted_root_ca_pem.crt</code> <br />
<code>wget https://gu-st.ru/content/lending/russian_trusted_sub_ca_pem.crt</code> <br />
<code>mkdir /usr/local/share/ca-certificates/russian_trusted</code> <br />
<code>cp russian_trusted_root_ca_pem.crt russian_trusted_sub_ca_pem.crt /usr/local/share/ca-certificates/russian_trusted</code> <br />
<code>update-ca-certificates -v</code> <br />
<code>wget -qS --spider --max-redirect=0 https://www.sberbank.ru</code></p>
<ul>
<li>Получение токена:</li>
</ul>
<pre><code class="language-Bash">Cred_Base64="N2U2ZDJmOWYtODI1ZS00OWI3LTk4ZjQtNjJmYmI3NTA2NDI3OmIyYzgwZmZmLTEzOGUtNDg1Mi05MjgwLWE2MGI4NTc0YTM2MQ=="
UUID=$(uuidgen)
GIGA_TOKEN=$(curl -s --location --request POST "https://ngw.devices.sberbank.ru:9443/api/v2/oauth" \
--header "Authorization: Basic $Cred_Base64" \
--header "RqUID: $UUID" \
--header "Content-Type: application/x-www-form-urlencoded" \
--data-urlencode 'scope=GIGACHAT_API_PERS' | jq -r .access_token)
</code></pre>
<p><code>curl -s --location "https://gigachat.devices.sberbank.ru/api/v1/models" --header "Authorization: Bearer $GIGA_TOKEN" | jq .</code> для проверки</p>
<ul>
<li>Составление запроса:</li>
</ul>
<pre><code class="language-Bash">request=$(curl -s https://gigachat.devices.sberbank.ru/api/v1/chat/completions \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $GIGA_TOKEN" \
  -d '{
  "model": "GigaChat:latest",
  "messages": [
        {
            "role": "user",
            "content": "Когда уже ИИ захватит этот мир?"
        }
    ],
  "temperature": 0.7
}')
echo $request | jq -r .choices[].message.content
</code></pre>
<h2 id="yandexgpt"><a class="header" href="#yandexgpt">YandexGPT</a></h2>
<ul>
<li>Получить OAuth-Token:</li>
</ul>
<p><a href="https://cloud.yandex.ru/ru/docs/iam/operations/iam-token/create">Create AIM Token</a> время жизни IAM-токена не больше 12 часов <br />
<code>yandexPassportOauthToken="y0_AgAAAAAGaLFLAATuwQAAAAD3xtRLQE4hvlazQ5euKO43XXXXXXXXXXX"</code> для bash <br />
<code>$yandexPassportOauthToken = "y0_AgAAAAAGaLFLAATuwQAAAAD3xtRLQE4hvlazQ5euKO43XXXXXXXXXXX"</code> для PowerShell</p>
<ul>
<li>Обменять OAuth-Token на IAM-Token:</li>
</ul>
<p><code>IAM_TOKEN=$(curl -s -d "{\"yandexPassportOauthToken\":\"$yandexPassportOauthToken\"}" "https://iam.api.cloud.yandex.net/iam/v1/tokens" | jq -r .iamToken)</code> <br />
<code>$IAM_TOKEN = $(Invoke-RestMethod -Method POST -Uri "https://iam.api.cloud.yandex.net/iam/v1/tokens" -Body $(@{yandexPassportOauthToken = "$yandexPassportOauthToken"} | ConvertTo-Json -Compress)).iamToken</code></p>
<ul>
<li>Получить FOLDER_ID:</li>
</ul>
<pre><code class="language-Bash">CLOUD_ID=$(curl -s -H "Authorization: Bearer $IAM_TOKEN" https://resource-manager.api.cloud.yandex.net/resource-manager/v1/clouds | jq -r .clouds[].id) # получить cloud id
curl -s --request GET -H "Authorization: Bearer $IAM_TOKEN" https://resource-manager.api.cloud.yandex.net/resource-manager/v1/folders -d "{\"cloudId\": \"$CLOUD_ID\"}" # получить список директорий в облаке
curl -s --request POST -H "Authorization: Bearer $IAM_TOKEN" https://resource-manager.api.cloud.yandex.net/resource-manager/v1/folders -d "{\"cloudId\": \"$CLOUD_ID\", \"name\": \"test\"}" # создать директорию в облаке
FOLDER_ID=$(curl -s --request GET -H "Authorization: Bearer $IAM_TOKEN" https://resource-manager.api.cloud.yandex.net/resource-manager/v1/folders -d '{"cloudId": "b1gf9n6heihqj0pt5piu"}' | jq -r '.folders[] | select(.name == "test") | .id') # забрать id директории
</code></pre>
<pre><code class="language-PowerShell">$CLOUD_ID = $(Invoke-RestMethod -Method Get -Uri "https://resource-manager.api.cloud.yandex.net/resource-manager/v1/clouds" -Headers @{"Authorization"="Bearer $IAM_TOKEN"; "Content-Type"="application/json"}).clouds.id
$FOLDER_ID = $(Invoke-RestMethod -Method Get -Uri "https://resource-manager.api.cloud.yandex.net/resource-manager/v1/folders" -Headers @{"Authorization"="Bearer $IAM_TOKEN"; "Content-Type"="application/json"} -Body (@{"cloudId"= $CLOUD_ID} | ConvertTo-Json)).folders | Where-Object name -eq test | Select-Object -ExpandProperty id
</code></pre>
<ul>
<li>Составление запроса:</li>
</ul>
<pre><code class="language-Bash">model="gpt://$FOLDER_ID/yandexgpt/latest" # https://cloud.yandex.ru/ru/docs/yandexgpt/concepts/models
body=$(cat &lt;&lt;EOF
{
  "modelUri": "$model",
  "completionOptions": {
    "stream": false,
    "temperature": 0.6,
    "maxTokens": 2000
  },
  "messages": [
    {
      "role": "user",
      "text": "Посчитай сумму 22+33"
    }
  ]
}
EOF)
curl --request POST \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $IAM_TOKEN" \
  -H "x-folder-id: $FOLDER_ID" \
  -d "$body" \
  "https://llm.api.cloud.yandex.net/foundationModels/v1/completion"
</code></pre>
<pre><code class="language-PowerShell">$model = "gpt://$FOLDER_ID/yandexgpt/latest"
$body = @"
{
  "modelUri": "$model",
  "completionOptions": {
    "stream": false,
    "temperature": 0.6,
    "maxTokens": 2000
  },
  "messages": [
    {
      "role": "user",
      "text": "Посчитай сумму 22+33"
    }
  ]
}
"@
Invoke-RestMethod -Method POST -Uri "https://llm.api.cloud.yandex.net/foundationModels/v1/completion" -Headers @{"Content-Type"="application/json"; "Authorization"="Bearer $IAM_TOKEN"; "x-folder-id"="$FOLDER_ID"} -Body $body
</code></pre>
<h2 id="superagi"><a class="header" href="#superagi">SuperAGI</a></h2>
<p><a href="https://github.com/TransformerOptimus/SuperAGI">Source</a> <br />
<a href="https://models.superagi.com/playground/generate">Playground generate</a> <br />
<a href="https://documenter.getpostman.com/view/30119783/2s9YR3cFJG">API Doc (exaples)</a></p>
<pre><code class="language-Bash">SUPERAGI_API_KEY="31f72164129XXXXX"
prompt="посчитай сумму 22+33, дай только ответ без лишнего текста"
request=$(curl -s -X POST 'https://api.superagi.com/v1/generate/65437cbf227a4018516ad1ce' \
-H 'Content-Type: application/json' \
-H "Authorization: Bearer $SUPERAGI_API_KEY" \
-d '{
  "prompt": ["$prompt"],
  "max_tokens": 500,
  "temperature": 0.9,
  "top_p": 0.15,
  "repetition_penalty": 0,
  "best_of": 1.05,
  "top_k": 50,
  "stream": false
}')
echo $request | sed "s/data: //" | jq -r .choices[].text
</code></pre>
<pre><code class="language-PowerShell">$SUPERAGI_API_KEY = "31f72164129XXXXX"
$prompt = "посчитай сумму 22+33, дай только ответ без лишнего текста"
$request = Invoke-RestMethod -Method Post -Uri 'https://api.superagi.com/v1/generate/65437cbf227a4018516ad1ce' -Headers @{
    'Content-Type' = 'application/json'
    'Authorization' = "Bearer $SUPERAGI_API_KEY"
} -Body (@{
    prompt = @($prompt)
    max_tokens = 500
    temperature = 0.9
    top_p = 0.15
    repetition_penalty = 0
    best_of = 1.05
    top_k = 50
    stream = $false
} | ConvertTo-Json)
$($request -replace "^data: " | ConvertFrom-Json).choices.text
</code></pre>
<h2 id="replicate"><a class="header" href="#replicate">Replicate</a></h2>
<p><a href="https://replicate.com/stability-ai/stable-diffusion/examples?input=http">API curl examples</a></p>
<pre><code class="language-Bash">REPLICATE_API_TOKEN="r8_STyeUNXiGonkLfxE1FSKaqll26lXXXXXXXXXX"
prompt="Жираф в полоску зебры"
request=$(curl -s -X POST \
  -H "Authorization: Token $REPLICATE_API_TOKEN" \
  -H "Content-Type: application/json" \
  -d $'{
    "version": "ac732df83cea7fff18b8472768c88ad041fa750ff7682a21affe81863cbe77e4",
    "input": {
      "prompt": "$prompt"
    }
  }' \
  https://api.replicate.com/v1/predictions)
request_url=$(echo $request | jq -r .urls.get)
response_status=$(curl -s -H "Authorization: Token $REPLICATE_API_TOKEN" $request_url | jq -r .status)
while [[ $response_status != succeeded ]]; do
    response_status=$(curl -s -H "Authorization: Token $REPLICATE_API_TOKEN" $request_url | jq -r .status)
done
curl -s -H "Authorization: Token $REPLICATE_API_TOKEN" $request_url | jq -r .output[]
</code></pre>
<pre><code class="language-PowerShell">$REPLICATE_API_TOKEN = "r8_STyeUNXiGonkLfxE1FSKaqll26lXXXXXXXXXX"
$prompt = "Жираф в полоску зебры"
$body = @{
   version = "ac732df83cea7fff18b8472768c88ad041fa750ff7682a21affe81863cbe77e4"
   input = @{
       prompt = $prompt
   }
} | ConvertTo-Json
$headers = @{
   "Authorization" = "Token $REPLICATE_API_TOKEN"
   "Content-Type" = "application/json"
}
$request = Invoke-RestMethod -Uri "https://api.replicate.com/v1/predictions" -Method POST -Body $body -Headers $headers
$response = Invoke-RestMethod $($request.urls.get) -Headers @{"Authorization" = "Token $REPLICATE_API_TOKEN"}
while ($response.status -ne "succeeded") {
    $response = Invoke-RestMethod $($request.urls.get) -Headers @{"Authorization" = "Token $REPLICATE_API_TOKEN"}
}
$response.output
</code></pre>
<h1 id="google-api"><a class="header" href="#google-api">Google API</a></h1>
<h2 id="google-translate"><a class="header" href="#google-translate">Google Translate</a></h2>
<pre><code class="language-PowerShell">$Key = "&lt;TOKEN_API&gt;" # получить токен: https://console.cloud.google.com/apis/credentials
$Text = "You can see in the right corner how long each translation request takes (this does not depend on the amount of text being transferred)."
$LanguageTarget = "RU"
$LanguageSource = "EN"
$url = "https://translation.googleapis.com/language/translate/v2?key=$key"
$Header = @{
    "Content-Type" = "application/json"
}
$Body = @{
    "q" = "$Text"
    "target" = "$LanguageTarget"
    "source" = "$LanguageSource"
} | ConvertTo-Json
$WebClient = New-Object System.Net.WebClient
foreach ($key in $Header.Keys) {
    $WebClient.Headers.Add($key, $Header[$key])
}
$Response = $WebClient.UploadString($url, "POST", $Body) | ConvertFrom-Json
$Response.data.translations.translatedText
</code></pre>
<h2 id="google-search"><a class="header" href="#google-search">Google Search</a></h2>
<pre><code class="language-PowerShell">$Key = "&lt;TOKEN_API&gt;" # получить токен: https://developers.google.com/custom-search/v1/overview?hl=ru (пользовательский поиск JSON API предоставляет 100 поисковых запросов в день бесплатно)
$cx = "35c78340f49eb474a" # создать поисковую систему https://programmablesearchengine.google.com/controlpanel/all
$Query = "как создать бота discord"
$Lang = "ru"
$Num = 10
$Start = 0
$response = Invoke-RestMethod "https://www.googleapis.com/customsearch/v1?q=$Query&amp;key=$Key&amp;cx=$cx&amp;lr=lang_$Lang&amp;num=$Num&amp;$start=$Start"
$response.items | Select-Object title,snippet,displayLink,link | Format-List
</code></pre>
<h2 id="google-search-via-rapidapi"><a class="header" href="#google-search-via-rapidapi">Google Search via RapidAPI</a></h2>
<p><a href="https://rapidapi.com/ru/neoscrap-net/api/google-search72">Google-Search72</a></p>
<pre><code class="language-PowerShell">$Key = "&lt;TOKEN_API&gt;"
$headers=@{}
$headers.Add("X-RapidAPI-Key", "$Key")
$headers.Add("X-RapidAPI-Host", "google-search72.p.rapidapi.com")
$query = "как создать бота discord"
$response = Invoke-RestMethod "https://google-search72.p.rapidapi.com/search?q=$query%20gitgub&amp;gl=us&amp;lr=lang_ru&amp;num=20&amp;start=0" -Method GET -Headers $headers
$response.items | Select-Object title,snippet,displayLink,link | Format-List
</code></pre>
<h2 id="google-filter"><a class="header" href="#google-filter">Google Filter</a></h2>
<p><code>https://www.google.com/search?q=the+rookie+2018+imdb</code> формат url-запроса поиска с пробелами <br />
<code>https://www.google.com/search?q=the+rookie+2018+site:imdb.com</code> поиск по сайту <br />
<code>https://www.google.com/search?q=the+rookie+intitle:index.of+"last modified"+(mkv|avi)</code> искать страницы, на которых указано "last modified" (последние изменения), заголовок страницы через расширенный оператор поиска (все перечисленные слова должны встречаться в заголовке) содержит слово "index.of" (указывает на директорию на веб-сервере, которая содержит список файлов) и искать файлы с расширениями .mkv или (|) .avi <br />
<code>https://www.google.com/search?q=the+rookie+2018+filetype:torrent</code> <br />
<code>инструкция gopro hero 11 filetype:pdf</code> искать сразу документ (на странице .pdf или загрузка) <br />
<code>"действия/глаголы, утвержденные для использования в командлетах"</code> искать по фразе целиком, без разбиения на отдельные слова <br />
<code>"ягуар скорость -животное -xe -xj"</code> узнаем скорость Ягуара, исключаем животное и модели автомобиля <br />
<code>"intitle:лучшие фильмы 2023"</code> запрос ищет страницы, заголовки (title HTML документа) которых содержат слова "лучшие", "фильмы" и "2023" (все слова должны быть в заголовке) <br />
<code>"allintitle:лучшие фильмы 2023"</code> запрос ищет страницы, заголовки (title HTML документа) которых содержат слова "лучшие", "фильмы" или "2023" (одно из) <br />
<code>"intext:telegram бот powershell"</code> поиск страниц, содержащих указанное ключевое слово в тексте страницы (а не только в заголовке) <br />
<code>"inurl:lifailon"</code> поиск страниц, в URL которых содержится указанное ключевое слово <br />
<code>intitle:index.of "game of thrones" mkv daterange:2010..2015</code> фильтрация по дате изменения, оператор позволяет задать диапазон дат в формате YYYYMMDD..YYYYMMDD <br />
<code>intitle:index.of "game of thrones" mkv after:2015</code> ограничить результаты поиска файлов, измененных до (before) или после (after) указанной даты <br />
<code>intitle:index.of "game of thrones" mkv from:2010 to:2015</code> фильтрация по диапазону дат <br />
<code>https://www.google.com/search?q=the-rookie-2018+site:imdb.com&amp;btnI</code> редирект на первый url</p>
<h1 id="media-api"><a class="header" href="#media-api">Media API</a></h1>
<h2 id="imdb"><a class="header" href="#imdb">IMDb</a></h2>
<p><a href="https://rapidapi.com/apidojo/api/imdb8">IMDb8</a></p>
<pre><code class="language-PowerShell">$key = "&lt;TOKEN_API&gt;" # 500 запросов в месяц
$query="Break"
$headers=@{}
$headers.Add("X-RapidAPI-Key", "$key")
$headers.Add("X-RapidAPI-Host", "imdb8.p.rapidapi.com")
$response = Invoke-RestMethod "https://imdb8.p.rapidapi.com/title/find?q=$query" -Method GET -Headers $headers
$response.results | select title,titletype,year,runningTimeInMinutes,id | Format-Table
"https://www.imdb.com$($response.results.id[0])"
$response.results.principals # актеры
$response.results.image
</code></pre>
<h2 id="moviesdatabase"><a class="header" href="#moviesdatabase">MoviesDatabase</a></h2>
<p><a href="https://rapidapi.com/SAdrian/api/moviesdatabase">MoviesDatabase</a></p>
<pre><code class="language-PowerShell">$key = "&lt;TOKEN_API&gt;"
$imdb_id = "tt0455275"
$headers=@{}
$headers.Add("X-RapidAPI-Key", "$key")
$headers.Add("X-RapidAPI-Host", "moviesdatabase.p.rapidapi.com")
$response = Invoke-RestMethod "https://moviesdatabase.p.rapidapi.com/titles/$imdb_id" -Method GET -Headers $headers
$response.results
</code></pre>
<h2 id="tmdb"><a class="header" href="#tmdb">TMDB</a></h2>
<p><a href="https://developer.themoviedb.org/reference/intro/getting-started">Developer TMDB</a></p>
<pre><code class="language-PowerShell">$TOKEN = "548e444e7812575caa0a7eXXXXXXXXXX"
$Endpoint = "search/tv" # поиск сериала (tv) и фильма (movie) по названию
$Query = "зимородок"
$url = $("https://api.themoviedb.org/3/$Endpoint"+"?api_key=$TOKEN&amp;query=$Query")
$(Invoke-RestMethod -Uri $url -Method Get).results
$id = $(Invoke-RestMethod -Uri $url -Method Get).results.id # забрать id сериала (210865) https://www.themoviedb.org/tv/210865

$Endpoint = "tv/$id" # получение информации о сериале по его ID
$url = $("https://api.themoviedb.org/3/$Endpoint"+"?api_key=$TOKEN")
$(Invoke-RestMethod -Uri $url -Method Get) # список сезонов (.seasons), количество эпизодов (.seasons.episode_count)

(Invoke-RestMethod -Uri "https://api.themoviedb.org/3/tv/$id/season/2?api_key=$Token" -Method Get).episodes # вывести 2 сезон
Invoke-RestMethod -Uri "https://api.themoviedb.org/3/tv/$id/season/2/episode/8?api_key=$Token" -Method Get # вывести 8 эпизод
</code></pre>
<h2 id="omdb"><a class="header" href="#omdb">OMDb</a></h2>
<p>Получение API ключа по <a href="https://www.omdbapi.com">email</a></p>
<p><code>$API_KEY = "XXXXXXXX"</code> <br />
<code>$IMDb_ID = "tt7587890"</code> <br />
<code>curl -s "https://omdbapi.com/?apikey=$($API_KEY)&amp;i=$($IMDb_ID)" | jq .</code> <br />
<code>curl -s "https://omdbapi.com/?apikey=$($API_KEY)&amp;i=$($IMDb_ID)" | ConvertFrom-Json</code> <br />
<code>Invoke-RestMethod "https://omdbapi.com/?apikey=$($API_KEY)&amp;s=The Rookie"</code> <br />
<code>Invoke-RestMethod "https://omdbapi.com/?apikey=$($API_KEY)&amp;t=The Rookie"</code> поиск по Title <br />
<code>Invoke-RestMethod "https://omdbapi.com/?apikey=$($API_KEY)&amp;t=The Rookie&amp;y=1990"</code> поиск по Title и году выхода <br />
<code>Invoke-RestMethod "https://omdbapi.com/?apikey=$($API_KEY)&amp;t=The Rookie&amp;type=movie"</code> поиск только фильма (movie) или сериала (series) <br />
<code>$(Invoke-RestMethod "https://omdbapi.com/?apikey=$($API_KEY)&amp;s=The Rookie").Search</code> поиск всех совпадений (фильмы и сериалы)</p>
<h2 id="ivi"><a class="header" href="#ivi">ivi</a></h2>
<p><a href="https://ask.ivi.ru/knowledge-bases/10/articles/51697-dokumentatsiya-dlya-api-ivi">ivi api doc</a></p>
<p><code>Invoke-RestMethod https://api.ivi.ru/mobileapi/categories</code> список категорий и жанров (genres/meta_genres) <br />
<code>Invoke-RestMethod https://api.ivi.ru/mobileapi/collections</code> подборки</p>
<p><code>(Invoke-RestMethod "https://api.ivi.ru/mobileapi/search/v7/?query=zimorodok").result.seasons.number</code> кол-во сезонов <br />
<code>(Invoke-RestMethod "https://api.ivi.ru/mobileapi/search/v7/?query=zimorodok").result.seasons[1].episode_count</code> кол-во серий во втором сезоне <br />
<code>(Invoke-RestMethod "https://api.ivi.ru/mobileapi/search/v7/?query=zimorodok").result.seasons[1].ivi_release_info.date_interval_min</code> дата выхода следующей серии <br />
<code>(Invoke-RestMethod "https://api.ivi.ru/mobileapi/search/v7/?query=zimorodok").result.kp_rating</code> рейтинг в Кинопоиск (8.04)</p>
<p><code>$id = (Invoke-RestMethod "https://api.ivi.ru/mobileapi/search/v7/?query=zimorodok").result.kp_id</code> получить id в Кинопоиск (5106881) <br />
<code>id=$(curl -s https://api.ivi.ru/mobileapi/search/v7/?query=zimorodok | jq .result[].kp_id)</code> получить id в Кинопоиск</p>
<h2 id="kinopoisk"><a class="header" href="#kinopoisk">Kinopoisk</a></h2>
<pre><code class="language-Bash">id=5106881
get=$(curl -s https://www.kinopoisk.ru/film/$id/episodes/)
printf "%s\n" "${get[@]}" | grep -A 1 "Сезон 2" | grep "эпизодов" | sed -r "s/^.+\: //" # количество эпиздовод во втором сезоне
</code></pre>
<h3 id="kinopoiskdev"><a class="header" href="#kinopoiskdev">kinopoisk.dev</a></h3>
<p><a href="https://t.me/kinopoiskdev_bot">Получить токен</a> <br />
<a href="https://kinopoisk.dev/documentation">Документация по API в формате OpenAPI</a></p>
<p><code>GET /v1.4/movie/{id}</code> поиск по id</p>
<pre><code class="language-PowerShell">$id = 5106881
$API_KEY = "ZYMNJJA-0J8MNPN-PB4N7R7-XXXXXXX"

$Header = @{
    "accept" = "application/json"
    "X-API-KEY" = "$API_KEY"
}
$irm = Invoke-RestMethod "https://api.kinopoisk.dev/v1.4/movie/$id" -Method GET -Headers $Header
$irm.rating.kp # рейтинг в Кинопоиск (8,079)
$irm.seasonsInfo # количество сезонов и эпизодов в них
</code></pre>
<pre><code class="language-Bash">id=5106881
API_KEY="ZYMNJJA-0J8MNPN-PB4N7R7-XXXXXXX"
get=$(curl -s -X GET \
  "https://api.kinopoisk.dev/v1.4/movie/$id" \
  -H "accept: application/json" \
  -H "X-API-KEY: $API_KEY")
echo $get | jq .rating.kp # рейтинг в Кинопоиск (8,079)
echo $get | jq .seasonsInfo[1].episodesCount # количество эпизодов во втором [1] сезоне (6)
</code></pre>
<p><code>GET /v1.4/movie/search</code></p>
<pre><code class="language-Bash">query="zimorodok"
page=1 # кол-во страниц для выборки
limit=1 # кол-во элементов на странице
curl -s -X GET \
  "https://api.kinopoisk.dev/v1.4/movie/search?page=$page&amp;limit=$limit&amp;query=$query" \
  -H "accept: application/json" \
  -H "X-API-KEY: $API_KEY" | jq .

limit=5
request=$(curl -s -X GET \
  "https://api.kinopoisk.dev/v1.4/movie/search?page=$page&amp;limit=$limit&amp;query=%D0%B7%D0%B8%D0%BC%D0%BE%D1%80%D0%BE%D0%B4%D0%BE%D0%BA" \
  -H "accept: application/json" \
  -H "X-API-KEY: $API_KEY" | jq .)
echo $request | jq '.docs[] | select(.year == 2022)' # отфильтровать вывод по году выхода
</code></pre>
<pre><code class="language-PowerShell">$API_KEY = "ZYMNJJA-0J8MNPN-PB4N7R7-XXXXXXX"
$page = 1
$limit = 5
$query = "%D0%B7%D0%B8%D0%BC%D0%BE%D1%80%D0%BE%D0%B4%D0%BE%D0%BA"
$request = Invoke-RestMethod -Uri "https://api.kinopoisk.dev/v1.4/movie/search?page=$page&amp;limit=$limit&amp;query=$query" -Headers @{"accept"="application/json"; "X-API-KEY"="$API_KEY"}
$request.docs | Where-Object year -eq 2022
</code></pre>
<h3 id="urlcode"><a class="header" href="#urlcode">UrlCode</a></h3>
<pre><code class="language-PowerShell">function Get-PercentEncode ($str) {
   $bytes = [System.Text.Encoding]::UTF8.GetBytes($str)
   ($bytes | ForEach-Object { "{0:X2}" -f $_ }) -join '%' -replace "^","%"
}
Get-PercentEncode "зимородок"
</code></pre>
<pre><code class="language-PowerShell">function Get-UrlEncode($str) {
   [System.Web.HttpUtility]::UrlEncode($str)
}
UrlEncode "зимородок"
</code></pre>
<pre><code class="language-Bash">percent-encode() {
  str=$1
    echo -n "$1" | iconv -t utf8 | od -An -tx1 | tr ' ' % | tr -d '\n'
}
percent-encode "зимородок"
</code></pre>
<pre><code class="language-PowerShell">function Get-UrlDecode($encoded) {
    [System.Uri]::UnescapeDataString($encoded)
}
Get-UrlDecode "%D0%B7%D0%B8%D0%BC%D0%BE%D1%80%D0%BE%D0%B4%D0%BE%D0%BA"
</code></pre>
<pre><code class="language-Bash">percent-decode() {
    encoded=$1
    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}
percent-decode "%D0%B7%D0%B8%D0%BC%D0%BE%D1%80%D0%BE%D0%B4%D0%BE%D0%BA"
</code></pre>
<h3 id="kinopoiskapiunofficial"><a class="header" href="#kinopoiskapiunofficial">KinopoiskApiUnofficial</a></h3>
<p>Бесплатно 500 запросов в сутки. <a href="https://kinopoiskapiunofficial.tech/documentation/api">Swagger documentation</a></p>
<pre><code class="language-PowerShell">API_KEY="828ec96a-f45d-4e3d-84b1-XXXXXXXXXXXX"
$headers = @{
    "accept" = "application/json"
    "X-API-KEY" = "$API_KEY"
}
Invoke-RestMethod -Uri 'https://kinopoiskapiunofficial.tech/api/v2.2/films/1142153' -Headers $headers
</code></pre>
<p><code>curl -s "https://kinopoiskapiunofficial.tech/api/v2.2/films/1142153" -H "accept: application/json" -H "X-API-KEY: $API_KEY" | jq .</code></p>
<h2 id="kinobox"><a class="header" href="#kinobox">Kinobox</a></h2>
<p><code>$url = "https://www.kinopoisk.ru/film/694051"</code> <br />
<code>$kp_id = $url -replace ".+/"</code> <br />
<code>https://kinomix.web.app/#694051</code> <br />
<code>curl -s -X GET "https://kinobox.tv/api/players/main?kinopoisk=$kp_id" -H "accept: application/json"</code> поиск по id Кинопоиск <br />
<code>curl -s -X GET "https://kinobox.tv/api/players/main?imdb=tt2293640" -H "accept: application/json"</code> поиск по id IMDb <br />
<code>curl -s -X GET "https://kinobox.tv/api/players/main?title=minions" -H "accept: application/json"</code> поиск основных плееров по названию <br />
<code>curl -s -X GET "https://kinobox.tv/api/players/all?title=minions" -H "accept: application/json"</code> поиск всех плееров <br />
<code>curl -s -X GET "https://kinobox.tv/api/popular/films" -H "accept: application/json"</code> популярные фильмы <br />
<code>curl -s -X GET "https://kinobox.tv/api/popular/series" -H "accept: application/json"</code> популярные сериалы</p>
<h2 id="videocdn"><a class="header" href="#videocdn">VideoCDN</a></h2>
<p><a href="https://github.com/notssh/videocdn-api">API</a> <br />
<a href="https://github.com/API-Movies/videocdn">Source</a> <br />
<a href="https://api-movies.github.io/videocdn/index.json">API JSON</a></p>
<pre><code class="language-PowerShell">$kp_id = 5106881
$token = "YfTWH2p3Mai7ziqDoGjS3yXXXXXXXXXX"
$ep = "tv-series"
$(Invoke-RestMethod $("https://videocdn.tv/api/$ep"+"?api_token=$token&amp;field=kinopoisk_id&amp;query=$kp_id")).data.episodes | Where-Object season_num -eq 2 | Select-Object @{Name="Episode"; Expression={$_.num}}, @{Name="Voice"; Expression={$_.media.translation.title}} # отфильтровать серии по второму сезону и отобразить все озвучки к сериям
</code></pre>
<pre><code class="language-Bash">kp_id=5106881
token="YfTWH2p3Mai7ziqDoGjS3yXXXXXXXXXX"
ep="tv-series"
curl -s "https://videocdn.tv/api/$ep?api_token=$token&amp;field=kinopoisk_id&amp;query=$kp_id" | jq ".data[].episodes | length" # количество серий
curl -s "https://videocdn.tv/api/$ep?api_token=$token&amp;field=kinopoisk_id&amp;query=$kp_id" | jq ".data[].episodes[] | select(.season_num == 2) | {episode: .ru_title, voice: .media[].translation.title}" # отфильтровать параметры вывода
</code></pre>
<h1 id="torrent"><a class="header" href="#torrent">Torrent</a></h1>
<h3 id="jackett"><a class="header" href="#jackett">Jackett</a></h3>
<p><a href="https://github.com/Jackett/Jackett">Source</a></p>
<p><code>mkdir /jackett</code> <br />
<code>docker-compose.yml</code></p>
<pre><code class="language-yaml">---
services:
  jackett:
    image: lscr.io/linuxserver/jackett:latest
    container_name: jackett
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Etc/UTC
    volumes:
      - /jackett/data:/config
      - /jackett/blackhole:/downloads
    ports:
      - 9117:9117
    restart: unless-stopped
</code></pre>
<p><code>docker-compose up -d jackett</code> <br />
<code>docker exec -it jackett /bin/bash</code> доступ к оболочке во время работы контейнера <br />
<code>docker logs -f jackett</code> мониторинг журналов контейнера</p>
<p><code>/jackett/data/Jackett/ServerConfig.json</code> место хранения конфигурации сервера <br />
<code>/jackett/data/Jackett/Indexers/*.json</code> место хранения конфигурации индексаторов</p>
<p><code>$API_KEY = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</code> <br />
<code>Invoke-RestMethod "http://127.0.0.1:9117/api/v2.0/indexers/rutor/results/torznab/api?apikey=$API_KEY"</code> Прочитать RSS ленту RuTor <br />
<code>$query = "the+rookie"</code> <br />
<code>Invoke-RestMethod "http://127.0.0.1:9117/api/v2.0/indexers/rutor/results/torznab/api?apikey=$API_KEY&amp;t=search&amp;cat=&amp;q=$query"</code> поиск в RuTor <br />
<code>Invoke-RestMethod "http://127.0.0.1:9117/api/v2.0/indexers/kinozal/results/torznab/api?apikey=$API_KEY&amp;t=search&amp;q=$query"</code> поиск в кинозал <br />
<code>Invoke-RestMethod "http://127.0.0.1:9117/api/v2.0/indexers/kinozal/results/torznab/api?apikey=$API_KEY&amp;t=search&amp;q=$query&amp;cat=5000"</code> отфильтровать вывод по сериалам (Capabilities: 5000) <br />
<code>Invoke-RestMethod "http://127.0.0.1:9117/api/v2.0/indexers/all/results/torznab/api?apikey=$API_KEY&amp;t=search&amp;q=riverdale"</code> поиск во всех индексаторах <br />
<code>$(Invoke-RestMethod "http://127.0.0.1:9117/api/v2.0/indexers/all/results/torznab/api?apikey=$API_KEY&amp;t=indexers&amp;configured=true").indexers.indexer</code> cписок всех настроенных индексаторов (трекеров)</p>
<h3 id="torrent-api-py"><a class="header" href="#torrent-api-py">Torrent-API-py</a></h3>
<p><a href="https://github.com/Ryuk-me/Torrent-Api-py">Source</a> <br />
<a href="https://torrent-api-py-nx0x.onrender.com/docs#/default/health_route_health_get">Documentation</a></p>
<pre><code>git clone https://github.com/Ryuk-me/Torrent-Api-py
cd Torrent-Api-py
pip install virtualenv
py -3 -m venv api-py
# Активировать виртуальную среду для Windows
.\api-py\Scripts\activate
# Активировать виртуальную среду для Linux
# $ source api-py/bin/activate
# Установить зависимости и запустить
pip install -r requirements.txt
python main.py
# Proxy: https://github.com/dperson/torproxy
# export HTTP_PROXY="http://proxy-host:proxy-port"
</code></pre>
<p><code>$srv = "http://localhost:8009"</code> local <br />
<code>$srv = "https://torrent-api-py-nx0x.onrender.com"</code> public <br />
<code>Invoke-RestMethod $srv/api/v1/sites</code> список доступных трекеров <br />
<code>Invoke-RestMethod "$srv/api/v1/search/?site=torlock&amp;query=the+rookie&amp;limit=0&amp;page=1"</code> поиск в выбранном трекере <br />
<code>Invoke-RestMethod "$srv/api/v1/all/search?query=the+rookie&amp;limit=0"</code> поиск по названию во всех трекерах</p>
<h3 id="plex"><a class="header" href="#plex">Plex</a></h3>
<p><code>$API_TOKEN = "XXXXXXXXXXXXXXXXXXXX"</code></p>
<pre><code>$headers = @{
    "X-Plex-Token" = $API_TOKEN
    "accept" = "application/json"
}
</code></pre>
<p><code>$(Invoke-RestMethod -Headers $headers -Uri http://localhost:32400/servers).MediaContainer.Server</code> версия сервера <br />
<code>Invoke-RestMethod -Headers $headers -Uri http://localhost:32400/diagnostics/logs -OutFile log.zip</code> выгруить лог с сервера <br />
<code>$(Invoke-RestMethod -Headers $headers -Uri http://localhost:32400/library/sections).MediaContainer.Directory</code> список секций добавленных на сервер <br />
<code>$section_key = $(Invoke-RestMethod -Headers $headers -Uri http://localhost:32400/library/sections).MediaContainer.Directory.key[0]</code> <br />
<code>Invoke-RestMethod -Headers $headers -Uri http://localhost:32400/library/sections/$section_key/refresh</code> синхронизация указанной секции в Plex по ключу <br />
<code>$(Invoke-RestMethod -Headers $headers -Uri http://localhost:32400/library/sections/2/folder).MediaContainer.Metadata</code> получить список директорий и файлов в корне выбранной секции <br />
<code>$(Invoke-RestMethod -Headers $headers -Uri http://localhost:32400/library/sections/2/folder?parent=204).MediaContainer.Metadata</code> получить список всех файлов в указанной директории через ключ (MediaContainer.Metadata.key) конечной точки</p>
<h3 id="jellyfin"><a class="header" href="#jellyfin">Jellyfin</a></h3>
<p><a href="https://github.com/jellyfin/jellyfin">Source</a> <br />
<a href="https://api.jellyfin.org">API Docs</a></p>
<p><code>$API_TOKEN "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"</code> <br />
<code>Invoke-RestMethod -Headers @{"X-Emby-Token" = $API_TOKEN} http://localhost:8096/Users</code> список пользователей и их id <br />
<code>$Users = Invoke-RestMethod -Headers @{"X-Emby-Token" = $API_TOKEN} http://localhost:8096/Users</code> <br />
<code>$UserId = $($Users | Where-Object Name -match "Lifailon").Id</code> забрать id пользователя <br />
<code>Invoke-RestMethod -Headers @{"X-Emby-Token" = $API_TOKEN} http://localhost:8096/System/Info</code> информация о системе <br />
<code>$(Invoke-RestMethod -Headers @{"X-Emby-Token" = $API_TOKEN} http://localhost:8096/Items).Items</code> список добавленных объектов директорий <br />
<code>$ItemId = $(Invoke-RestMethod -Headers @{"X-Emby-Token" = $API_TOKEN} http://localhost:8096/Items).Items[-1].Id</code> забрать id директории <br />
<code>$Data = $(Invoke-RestMethod -Headers @{"X-Emby-Token" = $API_TOKEN} "http://localhost:8096/Users/$UserId/Items?ParentId=$ItemId").Items</code> получить содержимое корневой директории по Id из Items <br />
<code>$TvId = $($data | Where-Object Name -match "Rookie").Id</code> найти сериал или фильм по имени и забрать его Id <br />
<code>$(Invoke-RestMethod -Headers @{"X-Emby-Token" = $API_TOKEN} "http://localhost:8096/Users/$UserId/Items?ParentId=$TvId").Items</code> получить содержимое дочерней директории по Id ее родительской директории</p>
<h1 id="telegram"><a class="header" href="#telegram">Telegram</a></h1>
<p>@BotFather (https://t.me/BotFather) /newbot</p>
<p>Format: <code>https://api.telegram.org/bot&lt;token&gt;/&lt;endpoint&gt;</code></p>
<p><a href="https://core.telegram.org/bots/api#getupdates">getupdates</a></p>
<pre><code class="language-PowerShell">function Get-FromTelegram {
    param (
        $Token = "687...:AAF...",
        [switch]$Date,
        [switch]$Last,
        [switch]$ChatID
    )
    $endpoint = "getUpdates"
    $url      = "https://api.telegram.org/bot$Token/$endpoint"
    $result   = Invoke-RestMethod -Uri $url
    if ($Date) {
        $Collections = New-Object System.Collections.Generic.List[System.Object]
        foreach ($r in $($result.result)) {
            $EpochTime = [DateTime]"1/1/1970"
            $TimeZone = Get-TimeZone
            $UTCTime = $EpochTime.AddSeconds($r.message.date)
            $d = $UTCTime.AddMinutes($TimeZone.BaseUtcOffset.TotalMinutes)
            $Collections.Add([PSCustomObject]@{
                Message = $r.message.text;
                Date    = $d
            })
        }
        $Collections
    }
    else {
        if ($Last) {
            $result.result.message.text[-1]
        }
        elseif ($ChatID) {
            $Collections = New-Object System.Collections.Generic.List[System.Object]
            foreach ($r in $($result.result)) {
                $Collections.Add([PSCustomObject]@{
                    Message = $r.message.text;
                    UserName = $r.message.chat.username;
                    ChatID = $r.message.chat.id;
                    ChatType = $r.message.chat.type
                })
            }
            $Collections
        }
        else {
            $result.result.message.text
        }
    }
}
</code></pre>
<p><code>Get-FromTelegram</code> <br />
<code>Get-FromTelegram -Last</code> <br />
<code>Get-FromTelegram -Date</code> <br />
<code>Get-FromTelegram -ChatID</code></p>
<p><a href="https://core.telegram.org/bots/api#sendmessage">sendmessage</a></p>
<pre><code class="language-PowerShell">function Send-ToTelegram {
param (
    [Parameter(Mandatory = $True)]$Text,
    $Token    = "687...:AAF...",
    $Chat     = "125468108",
    $Keyboard
)
    $endpoint = "sendMessage"
    $url      = "https://api.telegram.org/bot$Token/$endpoint"
    $Body = @{
        chat_id = $Chat
        text    = $Text
    }
    if ($keyboard -ne $null) {
        $Body += @{reply_markup = $keyboard}
    }
    Invoke-RestMethod -Uri $url -Body $Body
}
</code></pre>
<p><code>Send-ToTelegram -Text "Send test from powershell"</code></p>
<pre><code class="language-PowerShell">$LastDate = (Get-FromTelegram -date)[-1].Date
while ($true) {
    $LastMessage  = (Get-FromTelegram -date)[-1]
    Start-Sleep 1
    $LastDateTest = $LastMessage.Date
    if (($LastMessage.Message -match "/Service") -and ($LastDate -ne $LastDateTest)) {
        $ServiceName = $($LastMessage.Message -split " ")[-1]
        $Result = $(Get-Service $ServiceName -ErrorAction Ignore).Status
        if ($Result) {
            Send-ToTelegram -Text $Result
        } else {
            Send-ToTelegram -Text "Service not found"
        }
        $LastDate = $LastDateTest
    }
}
</code></pre>
<p><code>/Service vpnagent</code> <br />
<code>/Service WinRM</code> <br />
<code>/Service test</code></p>
<h3 id="button"><a class="header" href="#button">Button</a></h3>
<pre><code class="language-PowerShell">$keyboard = '{
    "inline_keyboard":[[
        {"text":"Uptime","callback_data":"/Uptime"},
        {"text":"Test","callback_data":"/Test"}
    ]]
}'
Send-ToTelegram -Text "Test buttons" -Keyboard $keyboard
$request = (Invoke-RestMethod -Uri "https://api.telegram.org/bot$Token/getUpdates").result.callback_query
$request.data # прочитать callback_data нажатой кнопки
$request.message.date
</code></pre>
<h3 id="send-totelegramfile"><a class="header" href="#send-totelegramfile">Send-ToTelegramFile</a></h3>
<p>https://core.telegram.org/bots/api#senddocument</p>
<pre><code class="language-PowerShell">function Send-ToTelegramFile {
    param (
        [Parameter(Mandatory = $true)][string]$Path,
        [Parameter(Mandatory = $true)][string]$Token,
        [Parameter(Mandatory = $true)][string]$Chat,
        $Keyboard
    )
    $endpoint = "senddocument"
    $url      = "https://api.telegram.org/bot$Token/$endpoint"
    $multipartContent = [System.Net.Http.MultipartFormDataContent]::new()
    $fileStream = [System.IO.FileStream]::new($Path, [System.IO.FileMode]::Open)
    $fileContent = [System.Net.Http.StreamContent]::new($fileStream)
    $fileHeader = [System.Net.Http.Headers.ContentDispositionHeaderValue]::new("form-data")
    $fileHeader.Name = "document"
    $fileHeader.FileName = [System.IO.Path]::GetFileName($Path)
    $fileContent.Headers.ContentDisposition = $fileHeader
    $multipartContent.Add($fileContent, "document")
    if ($Keyboard) {
        $keyboardContent = [System.Net.Http.StringContent]::new($Keyboard)
        $keyboardContent.Headers.ContentType.MediaType = "application/json"
        $multipartContent.Add($keyboardContent, "reply_markup")
    }
    $chatContent = [System.Net.Http.StringContent]::new($Chat)
    $multipartContent.Add($chatContent, "chat_id")
    $response = Invoke-RestMethod -Uri $url -Method Post -Body $multipartContent -ContentType "multipart/form-data"
    $fileStream.Dispose()
    return $response
}
</code></pre>
<p><code>Send-ToTelegramFile -Path "C:\Users\Lifailon\Documents\lake.jpg" -Token "7777777777:AAF..." -Chat "7777777777"</code></p>
<h1 id="discord"><a class="header" href="#discord">Discord</a></h1>
<p><a href="https://discord.com/developers/applications">Developers</a></p>
<p>Создаем Applications (General Information). В Bot привязываем к Application и копируем токен авторизации. В OAuth2 - URL Generator выбираем bot и права Administrator и копируем созданный URL для добавления на канал. Переходим по url и добавляем бота на сервер. Получаем ID канала на сервере (текстовые каналы, правой кнопкой мыши копируем ссылку и забираем последний id в url).</p>
<h3 id="send-to-discord"><a class="header" href="#send-to-discord">Send to Discord</a></h3>
<pre><code class="language-Bash">DISCORD_TOKEN="MTE5NzE1NjM0NTM3NjQxMTcyOQ.XXXXXX.EzBF6RA9Kx_MSuhLW5elH1U-XXXXXXXXXXXXXX"
DISCORD_CHANNEL_ID="119403124XXXXXXXXXX"
TEXT="test from bash"
URL="https://discordapp.com/api/channels/$DISCORD_CHANNEL_ID/messages"
curl -s -X POST $URL \
  -H "Authorization: Bot $DISCORD_TOKEN" \
  -H "Content-Type: application/json" \
  -d "{\"content\": \"$TEXT\"}"
</code></pre>
<pre><code class="language-PowerShell">$DISCORD_TOKEN = "MTE5NzE1NjM0NTM3NjQxMTcyOQ.XXXXXX.EzBF6RA9Kx_MSuhLW5elH1U-XXXXXXXXXXXXXX"
$DISCORD_CHANNEL_ID = "119403124XXXXXXXXXX"
$TEXT = "test from PowerShell"
$URL = "https://discordapp.com/api/channels/$DISCORD_CHANNEL_ID/messages"
$Body = @{
    content = $TEXT
} | ConvertTo-Json
curl -s $URL -X POST -H "Authorization: Bot $DISCORD_TOKEN" -H "Content-Type: application/json" -d $Body
</code></pre>
<h3 id="read-from-discord"><a class="header" href="#read-from-discord">Read from Discord</a></h3>
<pre><code class="language-Bash">curl -s -X GET $URL \
  -H "Authorization: Bot $DISCORD_TOKEN" \
  -H "Content-Type: application/json" | jq -r .[0].content
</code></pre>
<pre><code class="language-PowerShell">$messages = (curl -s -X GET $URL -H "Authorization: Bot $DISCORD_TOKEN" -H "Content-Type: application/json" | ConvertFrom-Json)
$messages | Select-Object content,timestamp,{$_.author.username}
</code></pre>
<h3 id="httpclient-1"><a class="header" href="#httpclient-1">HttpClient</a></h3>
<pre><code class="language-PowerShell">$DISCORD_TOKEN = "MTE5NzE1NjM0NTM3NjQxMTcyOQ.XXXXXX.EzBF6RA9Kx_MSuhLW5elH1U-XXXXXXXXXXXXXX"
$DISCORD_CHANNEL_ID = "119403124XXXXXXXXXX"
$URL = "https://discordapp.com/api/channels/$DISCORD_CHANNEL_ID/messages"
$HttpClient = New-Object System.Net.Http.HttpClient
$HttpClient.DefaultRequestHeaders.Authorization = "Bot $DISCORD_TOKEN"
$response = $HttpClient.GetAsync($URL).Result
$messages = $response.Content.ReadAsStringAsync().Result
($messages | ConvertFrom-Json).content
</code></pre>
<h3 id="button-1"><a class="header" href="#button-1">Button</a></h3>
<pre><code class="language-Bash">curl -X POST $URL \
  -H "Content-Type: application/json" \
  -H "Authorization: Bot $DISCORD_TOKEN" \
  -d '
  {
    "content": "Test text for button",
    "components": [
      {
        "type": 1,
        "components": [
          {
            "type": 2,
            "label": "Button",
            "style": 1,
            "custom_id": "button_click"
          }
        ]
      }
    ]
  }'
</code></pre>
<h3 id="discord-net-webhook"><a class="header" href="#discord-net-webhook">Discord Net Webhook</a></h3>
<pre><code class="language-PowerShell">Add-Type -Path $(ls "$home\Documents\Discord.NET\*.dll").FullName
# https://discordapp.com/api/webhooks/&lt;webhook_id&gt;/&lt;webhook_token&gt; (Настроить канал - Интеграция)
$webhookId = 1197577280000000000
$webhookToken = "rs8AA-XXXXXXXXXXX_Vk5RUI4A6HuSGhpCCTepq25duwCwLXasfv6u23a7XXXXXXXXXX"
$messageContent = "Test dotNET"
$client = New-Object Discord.Webhook.DiscordWebhookClient($webhookId, $webhookToken)
$client.SendMessageAsync($messageContent).Wait()
</code></pre>
<h3 id="discord-net-websocket"><a class="header" href="#discord-net-websocket">Discord Net WebSocket</a></h3>
<pre><code class="language-PowerShell">$DiscordAssemblies = $(ls "$home\Documents\Discord.NET\*.dll").FullName
foreach ($assembly in $DiscordAssemblies) {
    Add-Type -Path $assembly
}
$DISCORD_TOKEN = "MTE5NzE1NjM0NTM3NjQxMTcyOQ.XXXXXX.EzBF6RA9Kx_MSuhLW5elH1U-XXXXXXXXXXXXXX"
$Client = New-Object Discord.WebSocket.DiscordSocketClient
$Client.Add_MessageReceived({
    param($message)
    if ($message.Author.Id -ne $Client.CurrentUser.Id) {
        Write-Host ("Received message from " + $message.Author.Username + ": " + $message.Content)
        if ($message.Content.Contains("ping")) {
            $message.Channel.SendMessageAsync("pong").GetAwaiter().GetResult()
        }
    }
})
$Client.LoginAsync([Discord.TokenType]::Bot, $DISCORD_TOKEN).GetAwaiter().GetResult()
#$Client.StartAsync().Wait()
$Client.StartAsync().GetAwaiter().GetResult()
$Client.ConnectionState

[console]::ReadKey($true)
$Client.LogoutAsync().GetAwaiter().GetResult()
$Client.Dispose()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>+++
title = "DevOps"
[extra]
toc = true
toc_sidebar = true
go_to_top = true
+++</p>
<p>Заметки по инструментам и системам направления <code>DevOps</code>.</p>
<hr />
<h1 id="git"><a class="header" href="#git">Git</a></h1>
<p><code>git --version</code> <br />
<code>git config --global user.name "Lifailon"</code> добавить имя для коммитов <br />
<code>git config --global user.email "lifailon@yandex.ru"</code> <br />
<code>git config --global --edit</code> <br />
<code>git config --global core.editor "code --wait"</code> изменить редактор коммитов по умолчанию <br />
<code>ssh-keygen -t rsa -b 4096</code> <br />
<code>Get-Service | where name -match "ssh-agent" | Set-Service -StartupType Automatic</code> <br />
<code>Get-Service | where name -match "ssh-agent" | Start-Service</code> <br />
<code>Get-Service | where name -match "ssh-agent" | select Name,Status,StartType</code> <br />
<code>ssh-agent</code> <br />
<code>ssh-add C:\Users\Lifailon\.ssh\id_rsa</code> <br />
<code>cat ~\.ssh\id_rsa.pub | Set-Clipboard</code> copy to <a href="https://github.com/settings/keys">settings keys</a> <br />
<code>cd $home\Documents\Git</code> <br />
<code>git clone git@github.com:Lifailon/lifailon.github.io</code> <br />
<code>cd lifailon.github.io</code> <br />
<code>git grep "ping ya.ru"</code> поиск текста в файлах <br />
<code>git fetch</code> загрузить изменения из удаленного хранилища для обновления всех веток локального репозитория, не затрагивая текущую рабочую ветку (загружает все коммиты, ветки и т.д. которые не присутствуют в локальном репозитории) <br />
<code>git fetch --all</code> загрузить все ветки с удаленного репозитория (обновляет информацию о состоянии удаленного репозитория и загружает все изменения ваших веток без автоматического объединения) <br />
<code>git pull</code> загрузить изменения из удаленного хранилища для обновления локального репозитория (выполняет <code>git fetch</code>, чтобы получить последние изменения из удаленного репозитория, а затеим объеденяем изменения с локальной копией с помощью <code>git merge</code> для обновления текущей рабочей ветки) <br />
<code>git stash</code> сохраняет текущие незакоммиченные изменения в временное хранилище (например, на время выполнения <code>git pull</code>), в т.ч. неотслеживаемые файлы и очищает рабочую директорию (вернет в состояние, соответствующее последнему коммиту) <br />
<code>git stash pop</code> применяет последние изменения из стэша к текущей ветке (вернутся только измененные строки в файлах, при этом будут сохранены новые добавленные строки в файле без конфликтов) и удаляет их из стэша <br />
<code>git stash apply</code> применяет изменения, но не удаляет их из стэша <br />
<code>git status</code> отобразить статус изменений по файлам <br />
<code>git diff</code> отобразить историю изменений построчно <br />
<code>git diff pandoc</code> сравнивает изменения в текущей рабочей директории с последним коммитом в указанной ветке <code>pandoc</code> <br />
<code>git add .</code> добавить (проиндексировать) изменения во всех файлах текущего каталога <br />
<code>git commit -m "update powershell commands"</code> сохранить изменения с комментарием <br />
<code>git push</code> синхронизировать локальные изменения с репозиторием на сервере <br />
<code>git push origin mkdocs-material</code> отправить в конкретную ветку <br />
<code>git push origin --delete mkdocs</code> удалить ветку на удаленном сервере <br />
<code>git commit --amend</code> изменить комментарий в последнем коммите (до <code>push</code>) <br />
<code>git commit --amend --no-edit --date="Sun Oct 27 23:20:00 2024 +0300"</code> изменить дату последнего коммита <br />
<code>git branch -a</code> отобразить все ветки (в том числе удаленные remotes/origin) <br />
<code>git branch hugo</code> создать новую ветку <br />
<code>git branch -m hugo-public</code> переименовать текущую ветку <br />
<code>git branch -d hugo-public</code> удалить ветку <br />
<code>git switch hugo</code> переключиться на другую ветку <br />
<code>git push origin hugo</code> отправить изменения в указанную ветку <br />
<code>git branch --set-upstream-to=origin/hugo hugo</code> локальная ветка <code>hugo</code> будет отслеживать удаленную ветку <code>hugo</code> на удаленном сервере-репозитории <code>origin</code> (позволяет не указывать название удаленной ветки при каждом использовании команд <code>git push</code> или <code>git pull</code>) <br />
<code>git switch pandoc</code> переключиться на другую ветку <br />
<code>git merge hugo</code> слияние указанной ветки (<code>hugo</code>) в текущую ветку (<code>pandoc</code>)  <br />
<code>git log --oneline --all</code> отобразить список всех коммитов и их сообщений <br />
<code>git log --graph</code> коммиты и следование веток <br />
<code>git log --author="Lifailon"</code> показывает историю коммитов указанного пользователя <br />
<code>git blame .\posh.md</code> показывает, кто и когда внес изменения в каждую строку указанного файла (<code>НОМЕР_КОММИТА (ИМЯ_ПОЛЬЗОВАТЕЛЯ ДАТА НОМЕР_СТРОКИ) ТЕКСТ.</code>) <br />
<code>git show d01f09dead3a6a8d75dda848162831c58ca0ee13</code> отобразить подробный лог по номеру коммита <br />
<code>git checkout filename</code> устаревшая команда, откатить не проиндексированные изменения для коммита, возвращая его к состоянию, каким оно было на момент последнего коммита (если не было индексации через <code>add</code>) <br />
<code>git restore filename</code> отменить все локальные изменения в рабочей копии независимо от того, были они проиндексированы или нет (через <code>add</code>), возвращая его к состоянию на момент последнего коммита <br />
<code>git restore --source d01f09dead3a6a8d75dda848162831c58ca0ee13 filename</code> восстановить файл на указанную версию по хэшу индентификатора коммита <br />
<code>git reset HEAD filename</code> удалить указанный файл из индекса без удаления самих изменений в файле для последующей повторной индексации (если был <code>add</code> но не было <code>commit</code>, потом выполнить <code>checkout</code>) <br />
<code>git reset --soft HEAD^</code> отменяет последний (^) коммит, сохраняя изменения из этого коммита в рабочем каталоге и индексе (подготовленной области), можно внести изменения в файлы и повторно их зафиксировать через <code>commit</code> <br />
<code>git reset --hard HEAD^</code> полностью отменяет последний коммит, удаляя все его изменения из рабочего каталога и индекса до состояния предыдущего перед последним коммитом (аналогично <code>HEAD~1</code>) <br />
<code>git push origin main --force</code> удалить последний коммит на удаленном сервере репозитория после <code>reset --hard HEAD^</code>  <br />
<code>git reset --hard d01f09dead3a6a8d75dda848162831c58ca0ee13</code> откатывает изменения к указанному коммиту и удаляет все коммиты, которые были сделаны после него (будут потеряны все незакоммиченные изменения и историю коммитов после указанного) <br />
<code>git revert HEAD --no-edit</code> создает новый коммит, который отменяет последний коммит (<code>HEAD^</code>) и новый коммит будет добавлен поверх него (события записываются в <code>git log</code>) <br />
<code>git revert d01f09dead3a6a8d75dda848162831c58ca0ee13</code> создает новый коммит, который отменяет изменения, внесенные в указанный коммит с хешем (не изменяет историю коммитов, а создает новый коммит с изменениями отмены)</p>
<h1 id="github-api"><a class="header" href="#github-api">GitHub api</a></h1>
<p><code>$user = "Lifailon"</code> <br />
<code>$repository = "ReverseProxyNET"</code> <br />
<code>Invoke-RestMethod https://api.github.com/users/$($user)</code> получаем информацию о пользователе <br />
<code>Invoke-RestMethod https://api.github.com/users/$($user)/repos</code> получаем список последних (актуальные коммиты) 30 репозиториев указанного пользователя <br />
<code>Invoke-RestMethod https://api.github.com/users/$($user)/repos?per_page=100</code> получаем список последних (актуальные коммиты) 100 репозиториев указанного пользователя <br />
<code>Invoke-RestMethod https://api.github.com/repos/$($user)/$($repository)/contents</code> получаем содержимое корневой директории репозитория <br />
<code>Invoke-RestMethod https://api.github.com/repos/$($user)/$($repository)/contents/source/rpnet.cs</code> получаем содержимое файла в формате Base64 <br />
<code>$commits = Invoke-RestMethod https://api.github.com/repos/$($user)/$($repository)/commits</code> получаем список коммитов <br />
<code>$commits[0].commit.message</code> читаем комментарий последнего коммита <br />
<code>$commits[0].commit.committer.date</code> получаем дату последнего коммита <br />
<code>Invoke-RestMethod https://api.github.com/repos/$($user)/$($repository)/commits/$($commits[0].sha)</code> получаем подробную информацию изменений о последнем коммите в репозитории <br />
<code>$releases_latest = Invoke-RestMethod "https://api.github.com/repos/$($user)/$($repository)/releases/latest"</code> получаем информацию о последнем релизе в репозитории <br />
<code>$releases_latest.assets.name</code> список приложенных файлов последнего релиза <br />
<code>$releases_latest.assets.browser_download_url</code> получаем список url для загрузки файлов <br />
<code>$($releases_latest.assets | Where-Object name -like "*win*x64*exe*").browser_download_url</code> фильтруем по ОС и разрядности <br />
<code>$(Invoke-RestMethod -Uri "https://api.github.com/repos/Lifailon/epic-games-radar/commits?path=api/giveaway/index.json")[0].commit.author.date</code> узнать дату последнего обновления файла в репозитории <br />
<code>$issues = Invoke-RestMethod https://api.github.com/repos/LibreHardwareMonitor/LibreHardwareMonitor/issues?per_page=500</code> получаем список открытых проблем в репозитории (получаем максимум 100 последних, по умолчанию забираем последние 30 issues) <br />
<code>$issue_number = $($issues | Where-Object title -match "PowerShell").number</code> получаем номер issue, в заголовке которого есть слово "PowerShell" <br />
<code>Invoke-RestMethod https://api.github.com/repos/LibreHardwareMonitor/LibreHardwareMonitor/issues/$($issue_number)/comments</code> отобразить список комментарием указанного issues <br />
<code>Invoke-RestMethod https://api.github.com/repos/LibreHardwareMonitor/LibreHardwareMonitor/languages</code> получаем список языков программирования, используемых в репозитории <br />
<code>Invoke-RestMethod https://api.github.com/repos/LibreHardwareMonitor/LibreHardwareMonitor/pulls</code> получаем список всех pull requests в репозитории <br />
<code>Invoke-RestMethod https://api.github.com/repos/LibreHardwareMonitor/LibreHardwareMonitor/forks</code> получаем список форков (forks) <br />
<code>Invoke-RestMethod https://api.github.com/repos/LibreHardwareMonitor/LibreHardwareMonitor/stargazers?per_page=4000</code> получаем список пользователей, которые поставили звезды репозиторию <br />
<code>Invoke-RestMethod https://api.github.com/repos/LibreHardwareMonitor/LibreHardwareMonitor/subscribers</code> получаем список подписчиков (watchers) репозитория</p>
<h1 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h1>
<h2 id="runner-agent"><a class="header" href="#runner-agent">Runner (Agent)</a></h2>
<p><code>mkdir actions-runner; cd actions-runner</code> <br />
<code>Invoke-WebRequest -Uri https://github.com/actions/runner/releases/download/v2.316.1/actions-runner-win-x64-2.316.1.zip -OutFile actions-runner-win-x64-2.316.1.zip</code> загрузить пакет с Runner последней версии <br />
<code>if((Get-FileHash -Path actions-runner-win-x64-2.316.1.zip -Algorithm SHA256).Hash.ToUpper() -ne 'e41debe4f0a83f66b28993eaf84dad944c8c82e2c9da81f56a850bc27fedd76b'.ToUpper()){ throw 'Computed checksum did not match' }</code> проверить валидность пакета с помощью hash-суммы <br />
<code>Add-Type -AssemblyName System.IO.Compression.FileSystem ; [System.IO.Compression.ZipFile]::ExtractToDirectory("$PWD/actions-runner-win-x64-2.316.1.zip", "$PWD")</code> разархивировать <br />
<code>Remove-Item *.zip</code> удалить архив <br />
<code>./config.cmd --url https://github.com/Lifailon/egapi --token XXXXXXXXXXXXXXXXXXXXXXXXXXXXX</code> авторизовать и сконфигурировать сборщика с помощью скрипта (что бы на последнем пункте создать службу для управления сборщиком, нужно запустить консоль с правами администратора) <br />
<code>./run.cmd</code> запустить процесс (если не используется служба) <br />
<code>Get-Service *actions* | Start-Service</code> запустить службу <br />
<code>Get-Process *Runner.Listener*</code> <br />
<code>./config.cmd remove --token XXXXXXXXXXXXXXXXXXXXXXXXXXXXX</code> удалить конфигурацию</p>
<h2 id="build-pipeline"><a class="header" href="#build-pipeline">Build (Pipeline)</a></h2>
<pre><code class="language-yaml">name: build-game-list

on:
  # Разрешить ручной запуск workflow через интерфейс GitHub
  workflow_dispatch:
  
  # Запускать workflow по расписанию каждый час в 00 минут
  schedule:
  - cron: '00 * * * *'

jobs:
  Job_01:
    # Указываем, что job будет выполняться на последней версии Ubuntu
    runs-on: ubuntu-latest
    
    steps:
    # Шаги, которые будут выполнены в рамках этого job
    - name: Checkout repository
      # Клонирования репозиторий
      uses: actions/checkout@v2
    
    - name: Get content and write to file
      # Выполняем скрипт PowerShell, расположенный в ./scripts/Get-GameList.ps1
      run: pwsh -File ./scripts/Get-GameList.ps1
      # Указываем, что команда должна выполняться в оболочке bash
      shell: bash 

    - name: Commit and push changes
      run: |
        # Задаем имя пользователя и email для коммитов
        git config --global user.name 'GitHub Actions'
        git config --global user.email 'actions@github.com'
        # Добавляем все изменения в индекс
        git add .
        # Делаем коммит с комментарием
        git commit -m "update game list"
        # Отправляем коммит в удаленный репозиторий
        git push
</code></pre>
<h2 id="ci"><a class="header" href="#ci">CI</a></h2>
<pre><code class="language-yaml">name: Docker Build and Push Image

on:
  # Запусать при git push в ветку main
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Клонируем репозиторий
      uses: actions/checkout@v2

    - name: Авторизация в Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Сборка образа и отправка в Docker Hub
      run: |
        docker build -t lifailon/torapi:latest .
        docker push lifailon/torapi:latest
</code></pre>
<h2 id="logs-1"><a class="header" href="#logs-1">Logs</a></h2>
<p><code>$(Invoke-RestMethod https://api.github.com/repos/Lifailon/TorAPI/actions/workflows).total_count</code> получить количество запусков всех рабочих процессов <br />
<code>$(Invoke-RestMethod https://api.github.com/repos/Lifailon/TorAPI/actions/workflows).workflows</code> подробная информации о запускаемых рабочих процессах <br />
<code>$actions_last_id = $(Invoke-RestMethod https://api.github.com/repos/Lifailon/TorAPI/actions/workflows).workflows[-1].id</code> получить идентификатор последнего события <br />
<code>$(Invoke-RestMethod https://api.github.com/repos/Lifailon/TorAPI/actions/workflows/$actions_last_id/runs).workflow_runs</code> подробная информация о последней сборке <br />
<code>$run_id = $(Invoke-RestMethod https://api.github.com/repos/Lifailon/TorAPI/actions/workflows/$actions_last_id/runs).workflow_runs.id</code> получить идентификатор запуска рабочего процесса <br />
<code>$(Invoke-RestMethod "https://api.github.com/repos/Lifailon/TorAPI/actions/runs/$run_id/jobs").jobs.steps</code> подробная информация для всех шагов выполнения (время работы и статус выполнения) <br />
<code>$jobs_id = $(Invoke-RestMethod "https://api.github.com/repos/Lifailon/TorAPI/actions/runs/$run_id/jobs").jobs[0].id</code> получить идентификатор последнего задания указанного рабочего процесса</p>
<pre><code class="language-PowerShell">$url = "https://api.github.com/repos/Lifailon/TorAPI/actions/jobs/$jobs_id/logs"
$headers = @{
    Authorization = "token ghp_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
}
Invoke-RestMethod -Uri $url -Headers $headers # получить логи задания
</code></pre>
<h2 id="act"><a class="header" href="#act">act</a></h2>
<p><a href="https://github.com/nektos/act">act</a> - пользволяет запускать действия GitHub Actions локально.</p>
<pre><code class="language-bash">version=$(curl -s https://api.github.com/repos/nektos/act/releases/latest | jq -r .tag_name)
curl -L "https://github.com/nektos/act/releases/download/$version/act_$(uname -s)_$(uname -m).tar.gz" -o $HOME/.local/bin/act.tar.gz
tar -xzf $HOME/.local/bin/act.tar.gz -C $HOME/.local/bin
chmod +x $HOME/.local/bin/act
rm $HOME/.local/bin/act.tar.gz
act --version
</code></pre>
<p><code>act --list</code> список доступных действий, указаных в файлах .github/workflows <br />
<code>act -j build</code> запуск указанного действия по Job ID (имя файла, не путать с названием Workflow) <br />
<code>act -n -j build</code> пробный запуск (--dry-run), без выполнения команд, для отображения всех выполняемых jobs и steps</p>
<pre><code class="language-json">{
  "inputs": {
    "Distro": "ubuntu-24.04",
    "Update": "false",
    "Linter": "true",
    "Test": "false",
    "Release": "false",
    "Binary": "true"
  }
}
</code></pre>
<p><code>act -e event.json -W .github/workflows/build.yml -P ubuntu-24.04=catthehacker/ubuntu:act-latest</code> запустить указанный файл workflow с переданным файлом переменных (предварительно определенных параметров) и указанным сборщиком <br />
<code>act -e event.json -W .github/workflows/build.yml -P ubuntu-24.04=catthehacker/ubuntu:act-latest --artifact-server-path $PWD/artifacts</code> примонтировать рабочий каталог в контейнер для сохранения артефактов</p>
<pre><code class="language-bash">echo "DOCKER_HUB_USERNAME=username" &gt;&gt; .secrets
echo "DOCKER_HUB_PASSWORD=password" &gt;&gt; .secrets
</code></pre>
<p><code>act --secret-file .secrets</code> <br />
<code>act -s DOCKER_HUB_USERNAME=username -s DOCKER_HUB_PASSWORD=password</code> передать содержимое секретов <br />
<code>act push</code> симуляция push-ивента (имитация коммита и запуск workflow, который реагирует на push) <br />
<code>act --reuse</code> не удалять контейнер из успешно завершенных рабочих процессов для сохранения состояния между запусками (кэширование) <br />
<code>act --parallel</code> запуск всех jobs одновременно или последовательно (--no-parallel, по умолчанию)</p>
<h1 id="vercel"><a class="header" href="#vercel">Vercel</a></h1>
<p><code>npm i -g vercel</code> установить глобально в систему Vercel CLI <br />
<code>vercel --version</code> выводит текущую версию установленного Vercel CLI <br />
<code>vercel login</code> выполняет вход в аккаунт Vercel (<code>&gt; Continue with GitHub</code>) <br />
<code>vercel logout</code> выполняет выход из аккаунта Vercel <br />
<code>vercel init</code> инициализирует новый проект в текущей директории (создает файл конфигурации vercel.json и другие файлы, необходимые для проекта) <br />
<code>vercel dev</code> запускает локальный сервер для проверки работоспособности (http://localhost:3000) <br />
<code>vercel deploy</code> загружает проект на серверы Vercel и развертывает его <br />
<code>vercel link</code> привязывает текущую директорию к существующему проекту на сервере Vercel (выбрать из списка) <br />
<code>vercel unlink</code> отменяет привязку текущей директории от проекта Vercel <br />
<code>vercel env</code> управляет переменными окружения для проекта <br />
<code>vercel env pull</code> подтягивает переменные окружения с Vercel в локальный .env файл <br />
<code>vercel env ls</code> показывает список всех переменных окружения для проекта <br />
<code>vercel env add &lt;key&gt; &lt;environment&gt;</code> добавляет новую переменную окружения для указанного окружения (production, preview, development) <br />
<code>vercel env rm &lt;key&gt; &lt;environment&gt;</code> удаляет переменную окружения из указанного окружения <br />
<code>vercel projects</code> управляет проектами Vercel <br />
<code>vercel projects ls</code> показывает список всех проектов <br />
<code>vercel projects add</code> добавляет новый проект <br />
<code>vercel projects rm &lt;project&gt;</code> удаляет указанный проект <br />
<code>vercel pull</code> подтягивает последние настройки окружения с Vercel <br />
<code>vercel alias</code> управляет алиасами доменов для проектов <br />
<code>vercel alias ls</code> показывает список всех алиасов для текущего проекта <br />
<code>vercel alias set &lt;alias&gt;</code> устанавливает алиас для указанного проекта <br />
<code>vercel alias rm &lt;alias&gt;</code> удаляет указанный алиас <br />
<code>vercel domains</code> управляет доменами, привязанными к проекту <br />
<code>vercel domains ls</code> показывает список всех доменов <br />
<code>vercel domains add &lt;domain&gt;</code> добавляет новый домен к проекту <br />
<code>vercel domains rm &lt;domain&gt;</code> удаляет указанный домен <br />
<code>vercel teams</code> управляет командами и членами команд на Vercel <br />
<code>vercel teams ls</code> показывает список всех команд <br />
<code>vercel teams add &lt;team&gt;</code> добавляет новую команду <br />
<code>vercel teams rm &lt;team&gt;</code> удаляет указанную команду <br />
<code>vercel logs &lt;deployment&gt;</code> выводит логи для указанного деплоя <br />
<code>vercel secrets</code> управляет секретами, используемыми в проектах <br />
<code>vercel secrets add &lt;name&gt; &lt;value&gt;</code> добавляет новый секрет <br />
<code>vercel secrets rm &lt;name&gt;</code> удаляет указанный секрет <br />
<code>vercel secrets ls</code> показывает список всех секретов <br />
<code>vercel switch &lt;team&gt;</code> переключается между командами и аккаунтами Vercel</p>
<h2 id="cd"><a class="header" href="#cd">CD</a></h2>
<pre><code class="language-yaml">name: Deploy to Vercel

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Clone repository
      uses: actions/checkout@v4

    - name: Install Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Install dependencies
      run: npm install

    - name: Deploy to Vercel
      uses: amondnet/vercel-action@v25
      with:
        vercel-token: ${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
        vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
        vercel-args: '--prod'
</code></pre>
<h1 id="gitlab"><a class="header" href="#gitlab">GitLab</a></h1>
<pre><code class="language-bash">docker run --detach \
    --hostname 192.168.3.101 \
    --publish 443:443 --publish 80:80 --publish 2222:22 \
    --name gitlab \
    --restart always \
    --volume /srv/gitlab/config:/etc/gitlab \
    --volume /srv/gitlab/logs:/var/log/gitlab \
    --volume /srv/gitlab/data:/var/opt/gitlab \
    gitlab/gitlab-ee:latest
</code></pre>
<p><code>docker logs -f gitlab</code> логи контейнера <br />
<code>docker exec -it gitlab cat /etc/gitlab/initial_root_password</code> получить пароль для root <br />
<code>docker exec -it gitlab cat /etc/gitlab/gitlab.rb</code> конфигурация сервера</p>
<p>Получить токен регистрации Runner: http://192.168.3.101/root/torapi/-/settings/ci_cd#js-runners-settings</p>
<p><code>curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64</code> загрузить исполняемый файл Runner
<code>chmod +x /usr/local/bin/gitlab-runner</code></p>
<pre><code class="language-bash">docker run -d --name gitlab-runner --restart always \
    -v /srv/gitlab-runner/config:/etc/gitlab-runner \
    gitlab/gitlab-runner:latest
</code></pre>
<p><code>docker exec -it gitlab-runner bash</code> <br />
<code>gitlab-runner list</code> список сборщиков <br />
<code>gitlab-runner verify</code> проверка <br />
<code>gitlab-runner restart</code> применить настройки <br />
<code>gitlab-runner status</code> статус <br />
<code>gitlab-runner unregister --all-runners</code> удалить все регистрации <br />
<code>gitlab-runner install</code> установить службу <br />
<code>gitlab-runner run</code> запустить с выводом в консоль</p>
<p><code>gitlab-runner register</code></p>
<pre><code>Enter the GitLab instance URL (for example, https://gitlab.com/): http://192.168.3.101/
Enter the registration token: GR1348941enqAxqQgm8AZJD_g7vme
Enter an executor: shell
</code></pre>
<p><code>cat /etc/gitlab-runner/config.toml</code> конфигурация</p>
<p>Включить импорт проектов из GitHub: http://192.168.3.101/admin/application_settings/general#js-import-export-settings</p>
<pre><code class="language-yaml">variables:
  PORT: 2024
  TITLE: "The+Rookie"

stages:
  - test

test:
  stage: test
  script:
    - |
        pwsh -Command "
            Write-Host PORT - $env:PORT
            Write-Host TITLE - $env:TITLE
            npm install
            Start-Process -NoNewWindow -FilePath 'npm' -ArgumentList 'start -- --port $env:PORT' -RedirectStandardOutput 'torapi.log'
            Start-Sleep -Seconds 5
            Invoke-RestMethod -Uri http://localhost:$env:PORT/api/search/title/all?query=$env:TITLE | Format-List
            Get-Content torapi.log
            Stop-Process -Name 'node' -Force -ErrorAction SilentlyContinue
        "
</code></pre>
<h1 id="jenkins"><a class="header" href="#jenkins">Jenkins</a></h1>
<p>Примеры <code>Pipeline</code> и базовый синтаксис <code>Groovy</code>.</p>
<p><code>docker run -d --name=jenkins -p 8080:8080 -p 50000:50000 --restart=unless-stopped -v jenkins_home:/var/jenkins_home jenkins/jenkins:latest</code> <br />
<code>ls /var/lib/docker/volumes/jenkins_home/_data/jobs</code> директория хранящая историю сборок в хостовой системе <br />
<code>docker exec -it jenkins /bin/bash</code> подключиться к контейнеру <br />
<code>cat /var/jenkins_home/secrets/initialAdminPassword</code> получить токен инициализации</p>
<pre><code>docker run -d \
  --name jenkins-remote-agent-01 \
  --restart unless-stopped \
  -e JENKINS_URL=http://192.168.3.101:8080 \
  -e JENKINS_AGENT_NAME=remote-agent-01 \
  -e JENKINS_SECRET=3ad54fc9f914957da8205f8b4e88ff8df20d54751545f34f22f0e28c64b1fb29 \
  -v jenkins_agent:/home/jenkins \
  jenkins/inbound-agent:latest

# Или ссылаться на локальный контейнер сервера по имени
# --link jenkins:jenkins
# -e JENKINS_URL=http://jenkins:8080
</code></pre>
<p><code>docker exec -u root -it jenkins-remote-agent-01 /bin/bash</code> подключиться к slave агенту под root <br />
<code>apt-get update &amp;&amp; apt-get install -y iputils-ping netcat-openbsd</code> установить ping и nc на машину сборщика (slave)</p>
<p><code>jenkinsVolumePath=$(docker inspect jenkins | jq -r .[].Mounts.[].Source)</code> получить путь к директории Jenkins в хостовой системе <br />
<code>sudo tar -czf $HOME/jenkins-backup.tar.gz -C $jenkinsVolumePath .</code> резервная копия всех файлов <br />
<code>(crontab -l ; echo "0 23 * * * sudo tar -czf /home/lifailon/jenkins-backup.tar.gz -C /var/lib/docker/volumes/jenkins_home/_data .") | crontab -</code> <br />
<code>sudo tar -xzf $HOME/jenkins-backup.tar.gz -C /var/lib/docker/volumes/jenkins_home/_data</code> восстановление</p>
<p><code>wget http://127.0.0.1:8080/jnlpJars/jenkins-cli.jar -P $HOME/</code> скачать jenkins-cli (http://127.0.0.1:8080/manage/cli) <br />
<code>apt install openjdk-17-jre-headless</code> установить java runtime <br />
<code>java -jar jenkins-cli.jar -auth lifailon:password -s http://127.0.0.1:8080 -webSocket help</code> получить список команд <br />
<code>java -jar jenkins-cli.jar -auth lifailon:password -s http://127.0.0.1:8080 groovysh</code> запустить консоль Groovy <br />
<code>java -jar jenkins-cli.jar -auth lifailon:password -s http://127.0.0.1:8080 install-plugin ssh-steps -deploy</code> устанавливаем плагин SSH Pipeline Steps</p>
<h2 id="api-2"><a class="header" href="#api-2">API</a></h2>
<pre><code class="language-PowerShell">$username = "Lifailon"
$password = "password"
$base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(("{0}:{1}" -f $username,$password)))
$headers = @{Authorization=("Basic {0}" -f $base64AuthInfo)}
Invoke-RestMethod "http://192.168.3.101:8080/rssAll" -Headers $headers # RSS лента всех сборок и их статус в title
Invoke-RestMethod "http://192.168.3.101:8080/rssFailed" -Headers $headers # RSS лента всех неудачных сборок
$(Invoke-RestMethod "http://192.168.3.101:8080/computer/local-agent/api/json" -Headers $headers).offline # проверить статус работы slave агента

$jobs = Invoke-RestMethod "http://192.168.3.101:8080/api/json/job" -Headers $headers
$jobs.jobs.name # список всех проектов
$jobName = "Update SSH authorized_keys"
$job = Invoke-RestMethod "http://192.168.3.101:8080/job/${jobName}/api/json" -Headers $headers
$job.builds # список всех сборок
$buildNumber = $job.lastUnsuccessfulBuild.number # последняя неуспешная сборка
Invoke-RestMethod "http://192.168.3.101:8080/job/${jobName}/${buildNumber}/consoleText" -Headers $headers # вывести лог указанной сборки

$lastCompletedBuild = $job.lastCompletedBuild.number # последняя успешная сборка
$crumb = $(Invoke-RestMethod "http://192.168.3.101:8080/crumbIssuer/api/json" -Headers $headers).crumb # получаем временный токен доступа (crumb)
$headers["Jenkins-Crumb"] = $crumb # добавляем crumb в заголовки
$body = @{".crumb" = $crumb} # добавляем crumb в тело запроса
Invoke-RestMethod "http://192.168.3.101:8080/job/${jobName}/${lastCompletedBuild}/rebuild" -Headers $headers -Method POST -Body $body # перезапустить сборку
</code></pre>
<h2 id="plugins"><a class="header" href="#plugins">Plugins</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Плагин</th><th>Описание</th></tr></thead><tbody>
<tr><td><a href="https://plugins.jenkins.io/monitoring">Web Monitoring</a></td><td>Конечная точка <code>/monitoring</code> для отображения графиков мониторинга в веб-интерфейсе.</td></tr>
<tr><td><a href="https://plugins.jenkins.io/prometheus">Prometheus Metrics</a></td><td>Предоставляет конечную точку <code>/prometheus</code> с метриками, которые используются для сбора данных.</td></tr>
<tr><td><a href="https://plugins.jenkins.io/embeddable-build-status">Embeddable Build Status</a></td><td>Предоставляет настраиваемые значки (like <code>shields.io</code>), который возвращает статус сборки.</td></tr>
<tr><td><a href="https://plugins.jenkins.io/jobConfigHistory">Job Configuration History</a></td><td>Сохраняет копию файла сборки в формате <code>xml</code> (который хранится на сервере) и позволяет производить сверку.</td></tr>
<tr><td><a href="https://plugins.jenkins.io/ssh-steps">SSH Pipeline Steps</a></td><td>Плагин для подключения к удаленным машинам через протокол ssh по ключу или паролю.</td></tr>
<tr><td><a href="https://plugins.jenkins.io/uno-choice">Active Choices</a></td><td>Активные параметры, которые позволяют динамически обновлять содержимое параметров.</td></tr>
<tr><td><a href="https://plugins.jenkins.io/file-parameters">File parameters</a></td><td>Поддержка параметров для загрузки файлов (перезагрузить Jenkins для использования нового параметра).</td></tr>
<tr><td><a href="https://plugins.jenkins.io/email-ext">Email Extension</a></td><td>Плагин для отправки на почту из pipeline.</td></tr>
<tr><td><a href="https://plugins.jenkins.io/schedule-build">Schedule Build</a></td><td>Позволяет запланировать сборку на указанный момент времени.</td></tr>
<tr><td><a href="https://plugins.jenkins.io/test-results-analyzer">Test Results Analyzer</a></td><td>Показывает историю результатов сборки junit тестов в табличном древовидном виде.</td></tr>
</tbody></table>
</div>
<h2 id="ssh-steps-and-artifacts"><a class="header" href="#ssh-steps-and-artifacts">SSH Steps and Artifacts</a></h2>
<p>Добавляем логин и <code>Private Key</code> для авторизации по ssh: <code>Manage (Settings)</code> =&gt; <code>Credentials</code> =&gt; <code>Global</code> =&gt; <code>Add credentials</code> =&gt; Kind: <code>SSH Username with private key</code></p>
<p>Сценарий проверяет доступность удаленной машины, подключается к ней по ssh, выполняет скрипт <a href="https://github.com/Lifailon/hwstat">hwstat</a> для сбора метрик и выгружает json отчет в артефакты:</p>
<pre><code class="language-Groovy">// Глобальный массив для хранения данных подключения по ssh 
def remote = [:]

pipeline {
    agent any // { label 'remote-agent-01' }
    parameters {
        string(name: 'address', defaultValue: '192.168.3.101', description: 'Адрес удаленного сервера')
        // choice(name: "addresses", choices: ["192.168.3.101","192.168.3.102"], description: "Выберите сервер из выпадающего списка")
        string(name: 'port', defaultValue: '22', description: 'Порт ssh')
        string(name: 'credentials', defaultValue: 'd5da50fc-5a98-44c4-8c55-d009081a861a', description: 'Идентификатор учетных данных из Jenkins')
        booleanParam(name: "root", defaultValue: false, description: 'Запуск с повышенными привилегиями')
        booleanParam(name: "report", defaultValue: true, description: 'Выгружать отчет в формате json')
    }
    triggers {
        cron('H */6 * * 1-5') // выполнять запуск каждын 6 часов с понедельника по пятницу
    }
    options {
        timeout(time: 5, unit: 'MINUTES') // период ожидания, после которого нужно прервать Pipeline
        retry(2) // в случае неудачи повторить весь Pipeline указанное количество раз
    }
    environment {
        // Переменная окружения для хранения пути временного файла с содержимым приватного ключа
        SSH_KEY_FILE = "/tmp/ssh_key_${UUID.randomUUID().toString()}"
    }
    stages {
        stage('Проверка доступности хоста (icmp и tcp)') {
            steps {
                script {
                    def check = sh(
                        script: """
                            ping -c 1 ${params.address} &gt; /dev/null || exit 1
                            nc -z ${params.address} ${params.port} || exit 2
                        """,
                        returnStatus: true // исключить завершение Pipeline с ошибкой
                    )
                    if (check == 1) {
                        error("Сервер ${params.address} недоступен (icmp ping)")
                    } else if (check == 2) {
                        error("Порт ${params.address} закрыт (tcp check)")
                    } else {
                        echo "Сервер ${params.address} доступен и порт ${params.port} открыт"
                    }
                }
            }
        }
        stage('Извлечение данных для авторизации по ключу') {
            steps {
                script {
                    withCredentials([sshUserPrivateKey(credentialsId: params.credentials, usernameVariable: 'SSH_USER', keyFileVariable: 'SSH_KEY', passphraseVariable: '')]) {
                        // Записываем содержимое приватного ключа во временный файл
                        writeFile(file: env.SSH_KEY_FILE, text: readFile(SSH_KEY))
                        sh "chmod 600 ${env.SSH_KEY_FILE}"
                        remote.name = params.address
                        remote.host = params.address
                        remote.port = params.port.toInteger()
                        remote.user = SSH_USER
                        remote.identityFile = env.SSH_KEY_FILE
                        remote.allowAnyHosts = true
                    }
                }
            }
        }
        stage('Запуск скрипта через через ssh') {
            steps {
                script {
                    def runCommand
                    if (params.root) {
                        runCommand = """
                            curl -sS https://raw.githubusercontent.com/Lifailon/hwstat/rsa/hwstat.sh | sudo bash -s -- "json" &gt; "hwstat-report.json"
                        """
                    } else {
                        runCommand = """
                            curl -sS https://raw.githubusercontent.com/Lifailon/hwstat/rsa/hwstat.sh | bash -s -- "json" &gt; "hwstat-report.json"
                        """
                    }
                    def jsonOutput = sshCommand remote: remote, command: runCommand
                    if (params.report) {
                        // Записать содержимое переменной в файл
                        // writeFile file: 'hwstat-report.json', text: jsonOutput
                        // Загрузить файл из удаленной машины
                        sshGet remote: remote, from: "hwstat-report.json", into: "${env.WORKSPACE}/hwstat-report.json", override: true
                    }
                    sshCommand remote: remote, command: "rm hwstat-report.json"
                }
            }
        }
        stage('Загрузка json отчета в Jenkins') {
            // Проверка условия перед выполнением шага (пропуск если false)
            when {
                expression { params.report }
            }
            steps {
                archiveArtifacts artifacts: 'hwstat-report.json', allowEmptyArchive: true
            }
        }
    }
    post {
        // Выполнять независимо от успеха или ошибки
        always {
            script {
                sh "rm -f ${env.SSH_KEY_FILE}"
            }
        }
        success   { echo "Сборка завершена успешно" }
        failure   { echo "Сборка завершилась с ошибкой" }
        unstable  { echo "Сборка завершилась с предупреждениями" }
        changed   { echo "Текущий статус завершения изменился по сравнению с предыдущим запуском" }
        fixed     { echo "Сборка завершена успешно по сравнению с предыдущим запуском" }
        aborted   { echo "Запуск был прерван" }
    }
}
</code></pre>
<h2 id="update-ssh-authorized_keys"><a class="header" href="#update-ssh-authorized_keys">Update SSH authorized_keys</a></h2>
<p>Добавляем логин и пароль для авторизации по ssh: <code>Manage (Settings)</code> =&gt; <code>Credentials</code> =&gt; <code>Global</code> =&gt; <code>Add credentials</code> =&gt; Kind: <code>Username with password</code></p>
<p>Сценарий обновляет параметр со списком текущих пользователей на машине и добавляет или заменяет ssh ключ для выбранного пользователя:</p>
<pre><code class="language-Groovy">def remote = [:]

pipeline {
    agent any
    parameters {
        string(name: 'address', defaultValue: '192.168.3.101', description: 'Адрес удаленного сервера')
        string(name: 'port', defaultValue: '22', description: 'Порт ssh')
        string(name: 'credentials', defaultValue: '15d05be6-682a-472b-9c1d-cf5080e98170', description: 'Идентификатор учетных данных из Jenkins')
        booleanParam(name: "getUsers", defaultValue: true, description: 'Получить список текущих пользователей системы')
        string(name: 'sshKey', defaultValue: '', description: 'Открытый ssh ключ для добавления в authorized_keys')
        booleanParam(name: "rewriteKey", defaultValue: false, description: 'Перезаписать текущие ключи в файле authorized_keys')
    }
    stages {
        stage('Извлекаем параметры для авторизации по ssh') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: params.credentials, usernameVariable: 'SSH_USER', passwordVariable: 'SSH_PASS')]) {
                        remote.name = params.address
                        remote.host = params.address
                        remote.port = params.port.toInteger()
                        remote.user = env.SSH_USER
                        remote.password = env.SSH_PASS
                        remote.allowAnyHosts = true
                    }
                }
            }
        }
        stage('Обновить список пользователей') {
            when {
                expression { params.getUsers }
            }
            steps {
                script {
                    def mainCommand = "echo \$(ls /home)"
                    def users = sshCommand remote: remote, command: mainCommand
                    def usersList = users.trim().split("\\s")
                    usersList += 'root'
                    def usersListChoice = usersList.toList()
                    writeFile file: 'user_list.txt', text: usersList.join("\\s")
                    properties([
                        parameters([
                            string(name: 'address', defaultValue: params.address, description: 'Адрес удаленного сервера'),
                            string(name: 'port', defaultValue: params.port, description: 'Порт ssh'),
                            string(name: 'credentials', defaultValue: params.credentials, description: 'Идентификатор учетных данных из Jenkins'),
                            booleanParam(name: "getUsers", defaultValue: params.getUsers, description: 'Получить список текущих пользователей системы'),
                            string(name: 'sshKey', defaultValue: '', description: 'Открытый ssh ключ для добавления в authorized_keys'),
                            booleanParam(name: "rewriteKey", defaultValue: false, description: 'Перезаписать текущие ключи в файле authorized_keys'),
                            choice(
                                name: 'userList',
                                choices: usersListChoice,
                                description: 'Выбрать пользователя'
                            )
                        ])
                    ])
                }
            }
        }
        stage('Добавить новый SSH ключ') {
            when {
                expression { !params.getUsers &amp;&amp; params.sshKey }
            }
            steps {
                script {
                    def selectedUser = params.userList
                    def sshKey = params.sshKey
                    if (selectedUser == "root") {
                        path = "/root/.ssh/authorized_keys"
                    } else {
                        path= "/home/${selectedUser}/.ssh/authorized_keys"
                    }
                    if (params.rewriteKey) {
                        echo "Обновляем все SSH ключи для пользователя: ${selectedUser}"
                        teeCommand = "tee"
                    } else {
                        echo "Добавляем новый SSH ключ для пользователя: ${selectedUser}"
                        teeCommand = "tee -a"
                    }
                    def mainCommand = """
                        checkFile=\$(ls $path 2&gt; /dev/null || echo false)
                        if [ \$checkFile == "false" ]; then
                            mkdir -p \$(dirname $path) &amp;&amp; touch $path
                        fi
                        echo $sshKey | $teeCommand $path &gt; /dev/null
                    """
                    sshCommand remote: remote, command: mainCommand
                }
            }
        }
    }
}
</code></pre>
<h2 id="upload-file-parameter"><a class="header" href="#upload-file-parameter">Upload File Parameter</a></h2>
<p>Передача файла через параметр и чтение его содержимого:</p>
<pre><code class="language-Groovy">pipeline {
    agent any
    parameters {
        base64File 'UPLOAD_FILE'
    }
    stages {
        stage('Читаем содержимое файла') {
            steps {
                // Переменная хранит содержимое файла в формате base64
                // echo UPLOAD_FILE
                // Декодируем base64
                withFileParameter('UPLOAD_FILE') {
                    sh """
                        echo "$UPLOAD_FILE" # выводим путь к временному файлу с содержимым переданного файла
                        cat "$UPLOAD_FILE"  # читаем содержимое файла
                    """
                }
            }
        }
    }
}
</code></pre>
<h2 id="input-text-and-file"><a class="header" href="#input-text-and-file">Input Text and File</a></h2>
<p>Останавливает выполнение <code>Pipeline</code> и заставляет пользователя передать текстовый параметр и файл:</p>
<pre><code class="language-Groovy">pipeline {
    agent any
    stages {
        stage('Input text') {
            input {
                message "Что бы продолжить, передайте текст в поле ввода"
                ok "Передать"
                parameters {
                    string(name: 'TEXT', defaultValue: 'test', description: 'Введите текст')
                }
            }
            steps {
                echo "Переданный текст в параметре input: ${TEXT}"
            }
        }
        stage('Input file') {
            steps {
                script {
                    def fileBase64 = input message: "Передайте файл", parameters: [base64File('file')]
                    sh "echo $fileBase64 | base64 -d"
                }
            }
        }
    }
}
</code></pre>
<h2 id="httpurlconnection"><a class="header" href="#httpurlconnection">HttpURLConnection</a></h2>
<p>Любой код Groovy возможно запустить и проверить через <code>Script Console</code> (http://127.0.0.1:8080/manage/script)</p>
<p>Пример <code>API</code> запроса к репозиторию PowerShell на GitHub для получения последней версии и всех доступных версий:</p>
<pre><code class="language-Groovy">import groovy.json.JsonSlurper
def url = new URL("https://api.github.com/repos/PowerShell/PowerShell/tags")
def connection = url.openConnection()
connection.setRequestMethod("GET")
connection.setRequestProperty("Accept", "application/json")
def responseCode = connection.getResponseCode()
if (responseCode == 200) {
    // Получаем данные ответа
    def response = connection.getInputStream().getText()
    // Парсим JSON ответ
    def jsonSlurper = new JsonSlurper()
    def tags = jsonSlurper.parseText(response)
    // Проверяем количество элементов в массиве
    if (tags.size() &gt; 0) {
        // Забираем последний тег из списка
        def latestTag = tags[0].name
        println("Latest version: " + latestTag)
        println()
        // Проходимся по всем тегам
        println("List of all versions:")
        for (tag in tags) {
            println(tag.name)
        }
    } else {
        error("No tags found in the response")
    }
} else {
    error("Failed to call API, response code: ${responseCode}")
}
connection.disconnect()
</code></pre>
<h2 id="active-choices-parameter"><a class="header" href="#active-choices-parameter">Active Choices Parameter</a></h2>
<p>Пример выбора репозитория, получения списка доступных версий и содержимого файлов выбранного релиза.</p>
<ul>
<li>
<ol>
<li>Active Choices Parameter</li>
</ol>
</li>
</ul>
<p>Name: <code>Repos</code></p>
<p>Groovy Script:</p>
<pre><code class="language-Groovy">return [
    'Lifailon/lazyjournal',
    'jesseduffield/lazydocker'
]
</code></pre>
<ul>
<li>
<ol start="2">
<li>Active Choices Reactive Parameter</li>
</ol>
</li>
</ul>
<p>Name: <code>Versions</code></p>
<p>Groovy Script:</p>
<pre><code class="language-Groovy">import groovy.json.JsonSlurper
def selectedRepo = Repos
def apiUrl = "https://api.github.com/repos/${selectedRepo}/tags"
def conn = new URL(apiUrl).openConnection()
conn.setRequestProperty("User-Agent", "Jenkins")
def response = conn.getInputStream().getText()
def json = new JsonSlurper().parseText(response)
def versionsCount = json.size()
def data = []
for (int i = 0; i &lt; versionsCount; i++) {
    data += json.name[i]
}
return data
</code></pre>
<p>Настройки параметров:
Choice Type: <code>Single Select</code>
Привязать параметр <code>Repos</code> из <code>Active Choices</code> в <code>Reactive Parameter</code> через <code>Referenced parameters</code>
Включить фильтрацию через <code>Enable filters</code></p>
<ul>
<li>
<ol start="3">
<li>Active Choices Reactive Parameter</li>
</ol>
</li>
</ul>
<p>Name: <code>Files</code></p>
<p>Groovy Script:</p>
<pre><code class="language-Groovy">import groovy.json.JsonSlurper
def selectedRepo = Repos
def selectedVer = Versions
def apiUrl = "https://api.github.com/repos/${selectedRepo}/releases/tags/${selectedVer}"
def conn = new URL(apiUrl).openConnection()
conn.setRequestProperty("User-Agent", "Jenkins")
def response = conn.getInputStream().getText()
def json = new JsonSlurper().parseText(response)
def data = []
for (file in json.assets) {
    data += file.name
}
return data
</code></pre>
<p>Referenced parameters: <code>Repos,Versions</code></p>
<p>Pipeline script:</p>
<pre><code class="language-Groovy">pipeline {
    agent any
    stages {
        stage('Selected parameters') {
            steps {
                script {
                    echo "Selected repository: https://github.com/${params.Repos}"
                    echo "Selected version: ${params.Versions}"
                    echo "Selected file: ${params.Files}"
                    echo "Url for download: https://github.com/${params.Repos}/releases/download/${params.Versions}/${params.Files}"
                }
            }
        }
    }
}
</code></pre>
<h2 id="vault"><a class="header" href="#vault">Vault</a></h2>
<p>Интеграция <a href="https://github.com/hashicorp/vault">HashiCorp Vault</a> в Jenkins Pipeline через <code>REST API</code> для получения содержимого секретов и использовая в последующих стадиях/этапах сборки:</p>
<pre><code class="language-Groovy">def getVaultSecrets(
    String address,
    String path,
    String token
) {
    def url = new URL("${address}/${path}")
    
    def connection = url.openConnection()
    connection.setRequestMethod("GET")
    connection.setRequestProperty("X-Vault-Token", token)
    connection.setRequestProperty("Accept", "application/json")
    
    def response = new groovy.json.JsonSlurper().parse(connection.inputStream)
    def user = response.data.data.user
    def password = response.data.data.password
    return [
        user: user,
        password: password
    ]
}

def USER_NAME
def USER_PASS

pipeline {
    agent any
    parameters {
        string(name: 'url', defaultValue: 'http://192.168.3.101:8200', description: 'Url адресс хранилища секретов')
        string(name: 'path', defaultValue: 'v1/kv/data/ssh-auth', description: 'Путь для извлечения секретов')
        password(name: 'token', defaultValue: 'hvs.bySybhyYOxSWEVk4FQDdcyyg', description: 'Токен доступа к API HashiCorp Vault')
    }
    stages {
        stage('Get vault secrets') {
            steps {
                script {
                    def secrets = getVaultSecrets(
                        "${params.url}",
                        "${params.path}",
                        "${params.token}"
                    )
                    USER_NAME = secrets.user
                    USER_PASS = secrets.password
                }
            }
        }
        stage('Use secrets') {
            steps {
                script {
                    echo "User: ${USER_NAME}"
                    echo "Password: ${USER_PASS}"
                }
            }
        }
    }
}
</code></pre>
<h2 id="email-extension"><a class="header" href="#email-extension">Email Extension</a></h2>
<p>Для отправки на почту и настроить SMTP сервер в настройках Jenkins (<code>System</code> =&gt; <code>Extended E-mail Notification</code>)</p>
<p>SMTP server: <code>smtp.yandex.ru</code>
SMTP port: <code>587</code>
Credentials: <code>Username with password</code> (<code>username@yandex.ru</code> и <code>app-password</code>)
<code>Use TLS</code>
Default Content Type: <code>HTML (text/html)</code></p>
<p>Настройка логирования в System Log: <code>emailDebug</code> + фильтр <code>hudson.plugins.emailext</code> и уровень <code>ALL</code></p>
<pre><code class="language-Groovy">pipeline {
    agent any
    parameters {
        string(name: 'emailTo', defaultValue: 'test@yandex.ru', description: 'Почтовый адрес назначения')
    }
    stages {
        stage('Вывод всех переменных окружения') {
            steps {
                script {
                    env.getEnvironment().each { key, value -&gt;
                        echo "${key} = ${value}"
                    }
                }
            }
        }
        stage('Отправка на почту') {
            options {
                timeout(time: 1, unit: 'MINUTES')
            }
            steps {
                script {
                    emailext (
                        to:	"${params.emailTo}",
                        subject: "${env.JOB_NAME} - ${BUILD_NUMBER}",
                        mimeType: "text/html",
                        body: """
                            &lt;html&gt;
                                &lt;body&gt;
                                    &lt;div style="padding-left: 30px; padding-bottom: 15px;" color="blue"&gt;
                                    &lt;font name="Arial" color="#906090" size="3" font-weight="normal"&gt;
                                        &lt;b&gt; ${env.JOB_NAME} - ${env.BUILD_NUMBER} &lt;/b&gt;
                                    &lt;/font&gt;
                                    &lt;br&gt;
                                    &lt;div style="padding-left: 30px; padding-bottom: 15px;" color="black"&gt;
                                    &lt;br&gt;
                                    &lt;font name="Arial" color="black" size="2" font-weight="normal"&gt; 
                                        &lt;pre&gt; Build url: ${env.BUILD_URL} &lt;/pre&gt;
                                    &lt;/font&gt;	
                                &lt;/body&gt;
                            &lt;/html&gt;
                        """
                    )
                }
            }
        }
    }
}
</code></pre>
<h2 id="parallel"><a class="header" href="#parallel">Parallel</a></h2>
<pre><code class="language-Groovy">pipeline {
    agent any
    stages {
        stage('Parallel sleeps') {
            parallel {
                stage('Task 1') {
                    steps {
                        script {
                            def currentTime = new Date().format('yyyy-MM-dd HH:mm:ss')
                            echo "[${currentTime}] Начало задачи 1"
                            sh 'sleep 10'
                            currentTime = new Date().format('yyyy-MM-dd HH:mm:ss')
                            echo "[${currentTime}] Завершение задачи 1"
                        }
                    }
                }
                stage('Task 2') {
                    steps {
                        script {
                            def currentTime = new Date().format('yyyy-MM-dd HH:mm:ss')
                            echo "[${currentTime}] Начало задачи 2"
                            sh 'sleep 5'
                            currentTime = new Date().format('yyyy-MM-dd HH:mm:ss')
                            echo "[${currentTime}] Завершение задачи 2"
                        }
                    }
                }
            }
        }
        stage('Parallel tasks via loop') {
            steps {
                script {
                    // Массив, где ключи содержит имя задачи, а значение содержит блоки кода для выполнения
                    def tasks = [:]
                    def taskNames = ['Task 1', 'Task 2', 'Task 3']
                    taskNames.each { taskName -&gt;
                        tasks[taskName] = {
                            def currentTime = new Date().format('yyyy-MM-dd HH:mm:ss')
                            echo "[${currentTime}] Начало задачи: $taskName"
                            sh "sleep ${taskName == 'Task 1' ? 10 : taskName == 'Task 2' ? 5 : 3}"
                            currentTime = new Date().format('yyyy-MM-dd HH:mm:ss')
                            echo "[${currentTime}] Завершение задачи: $taskName"
                        }
                    }
                    parallel tasks
                }
            }
        }
    }
}
</code></pre>
<h2 id="groovy"><a class="header" href="#groovy">Groovy</a></h2>
<p>Базовый синтаксис языка <code>Groovy</code></p>
<pre><code class="language-Groovy">// Переменные
javaString = 'java'
javaString
println javaString
javaString.class    // class java.lang.String
println 100.class   // class java.lang.Integer
j = '${javaString}' // не принимает переменные в одинарных кавычках
groovyString = "${javaString}"
bigGroovyString = """
    ${javaString}
    ${j}
    ${groovyString}
    ${2 + 2}
"""

// java
// ${javaString}
// java
// 4

a = "a"   // a
a + "123" // a123
a * 5     // aaaaa

// Массивы и списки
list =[1,2,3]
list[0]    // 1
list[0..1] // [1, 2]
range = "0123456789"
range[1..5] // 12345
map = [key1: true, key2: false]
map["key1"] // true
server = [:]
server.ip = "192.168.3.1"
server.port = 22
println(server) // [ip:192.168.3.1, port:22]

// Функции
def sum(a,b) {
    println a+b
}
sum(2,2) // 4

// Условия
def diff(x) {
    if (x &lt; 10) {
        println("${x} &lt; 10")
    } else if (x == 10) {
        println("${x} = 10")
    } else {
        println("${x} &gt; 10")
    }
}
diff(11) // 11 &gt; 10

// Циклы
list.each { l -&gt;
    print l
}
// 123

for (i in 0..5) { 
    print i
}
// 012345

for (int i = 0; i &lt; 10; i++) {
    print i
}
// 0123456789

i = 0
while (i &lt; 3) {
    println(i)
    i++
}
// 0
// 1
// 2
</code></pre>
<h1 id="secret-manager"><a class="header" href="#secret-manager">Secret Manager</a></h1>
<h2 id="bitwarden"><a class="header" href="#bitwarden">Bitwarden</a></h2>
<p><code>choco install bitwarden-cli || npm install -g @bitwarden/cli || sudo snap install bw</code> установить bitwarden cli <br />
<code>bw login &lt;email&gt; --apikey</code> авторизвация в хранилище, используя client_id и client_secret <br />
<code>$session = bw unlock --raw</code> получить токен сессии <br />
<code>$items = bw list items --session $session | ConvertFrom-Json</code> получение всех элементов в хранилище с использованием мастер-пароля <br />
<code>echo "master_password" | bw get item GitHub bw get password $items[0].name</code> получить пароль по названию секрета <br />
<code>bw lock</code> завершить сессию</p>
<pre><code class="language-PowerShell"># Авторизация в организации
$client_id = "organization.ClientId"
$client_secret = "client_secret"
$deviceIdentifier = [guid]::NewGuid().ToString()
$deviceName = "PowerShell-Client"
$response = Invoke-RestMethod -Uri "https://identity.bitwarden.com/connect/token" -Method POST `
    -Headers @{ "Content-Type" = "application/x-www-form-urlencoded" } `
    -Body @{
        grant_type = "client_credentials"
        scope = "api.organization"
        client_id = $client_id
        client_secret = $client_secret
        deviceIdentifier = $deviceIdentifier
        deviceName = $deviceName
    }
# Получение токена доступа
$accessToken = $response.access_token
# Название элемента в хранилище
$itemName = "GitHub"
# Поиск элемента в хранилище
$itemResponse = Invoke-RestMethod -Uri "https://api.bitwarden.com/v1/objects?search=$itemName" -Method GET `
    -Headers @{ "Authorization" = "Bearer $accessToken" }
$item = $itemResponse.data[0]
# Получение информации об элементе
$detailsResponse = Invoke-RestMethod -Uri "https://api.bitwarden.com/v1/objects/$($item.id)" -Method GET `
    -Headers @{ "Authorization" = "Bearer $accessToken" }
# Получение логина и пароля
$login = $detailsResponse.login.username
$password = $detailsResponse.login.password
</code></pre>
<h2 id="infisical"><a class="header" href="#infisical">Infisical</a></h2>
<p><code>npm install -g @infisical/cli</code> <br />
<code>infisical login</code> авторизоваться в хранилище (cloud или Self-Hosting) <br />
<code>infisical init</code> инициализировать - выбрать организацию и проект <br />
<code>infisical secrets</code> получить список секретов и их SECRET VALUE из добавленных групп Environments (Development, Staging, Production)</p>
<pre><code class="language-PowerShell">$clientId = "&lt;client_id&gt;" # создать организацию и клиент в Organization Access Control - Identities и предоставить права на Projects (Secret Management)
$clientSecret = "&lt;client_secret&gt;" # на той же вкладке вкладке в Authentication сгенерировать секрет (Create Client Secret)
$body = @{
    clientId     = $clientId
    clientSecret = $clientSecret
}
$response = Invoke-RestMethod -Uri "https://app.infisical.com/api/v1/auth/universal-auth/login" `
    -Method POST `
    -ContentType "application/x-www-form-urlencoded" `
    -Body $body
$TOKEN = $response.accessToken # получить токен доступа
# Получить содержимое секрета
$secretName = "FOO" # название секрета
$workspaceId = "82488c0a-6d3a-4220-9d69-19889f09c8c8" # можно взять из url проекта Secret Management
$environment = "dev" # группа
$headers = @{
    Authorization = "Bearer $TOKEN"
}
$secrets = Invoke-RestMethod -Uri "https://app.infisical.com/api/v3/secrets/raw/${secretName}?workspaceId=${workspaceId}&amp;environment=${environment}" -Method GET -Headers $headers
$secrets.secret.secretKey
$secrets.secret.secretValue
</code></pre>
<h2 id="hashicorpvault"><a class="header" href="#hashicorpvault">HashiCorp/Vault</a></h2>
<p><code>mkdir vault &amp;&amp; cd vault &amp;&amp; mkdir vault_config</code></p>
<p>Создать конфигурацию:</p>
<pre><code class="language-bash">echo '
# Использовать локальное файловое хранилище
storage "file" {
  path = "/vault/file"
}
# Отключение режим dev (не будет выгружать данные в память)
disable_mlock = false
# Настройка слушателя для REST API
listener "tcp" {
  address = "0.0.0.0:8200"
  tls_disable = 1  # Отключить TLS
}
# Включение интерфейс
ui = true
# Включение аутентификации в API по токену
api_addr = "http://localhost:8200"
auth "token" {}
' &gt; vault_config/vault.hcl
</code></pre>
<p>Запускаем в контейнере:</p>
<pre><code class="language-bash">docker run -d --name=vault \
  --restart=unless-stopped \
  -e VAULT_ADDR=http://0.0.0.0:8200 \
  -e VAULT_API_ADDR=http://localhost:8200 \
  -p 8200:8200 \
  -v ./vault_config:/vault/config \
  -v ./vault_data:/vault/file \
  --cap-add=IPC_LOCK \
  hashicorp/vault:latest \
  vault server -config=/vault/config/vault.hcl
</code></pre>
<p>Получить ключи разблокировки и root ключ для первичной инициализации:</p>
<pre><code class="language-bash">docker exec -it vault vault operator init
</code></pre>
<p>Ввести любые 3 из 5 ключей для разблокировки после перезапуска контейнера:</p>
<pre><code class="language-bash">docker exec -it vault vault operator unseal BPJSmuLvKAEr6wtE/8TOMRMM+x0fW3UhOxGFLn9Gmi5N
docker exec -it vault vault operator unseal 44ntLYvSMN5FNLyddLo2IylRsLk7lqYXZOShvhV/2gbG
docker exec -it vault vault operator unseal xP9+YTyW13W6xGz52mMut2MdOnzxtbhDW8dK9zdF4aLY
</code></pre>
<p>Проверить статус (должно быть <code>Sealed: false</code>) и авторизацию по root ключу в хранилище:</p>
<pre><code class="language-bash">docker exec -it vault vault status
docker exec -it vault vault login hvs.rxlYkJujkX6Fdxq2XAP3cd3a
</code></pre>
<p><code>Secrets Engines</code> -&gt; <code>Enable new engine</code> + <code>KV</code> <br />
API Swagger: http://192.168.3.100:8200/ui/vault/tools/api-explorer</p>
<pre><code class="language-PowerShell">$TOKEN = "hvs.rxlYkJujkX6Fdxq2XAP3cd3a"
$Headers = @{
    "X-Vault-Token" = $TOKEN
}
# Указать путь до секретов (создается в корне kv)
$path = "main-path"
$url = "http://192.168.3.101:8200/v1/kv/data/$path"
$data = Invoke-RestMethod -Uri $url -Method GET -Headers $Headers
# Получить содержимое ключа по его названию (key_name)
$data.data.data.key_name # secret_value

# Перезаписать все секреты
$Headers = @{
    "X-Vault-Token" = $TOKEN
}
$Body = @{
    data = @{
        key_name_1 = "key_value_1"
        key_name_2 = "key_value_2"
    }
    options = @{}
    version = 0
} | ConvertTo-Json
$urlUpdate = "http://192.168.3.100:8200/v1/kv/data/main-path"
Invoke-RestMethod -Uri $urlUpdate -Method POST -Headers $Headers -Body $Body

# Удалить все секреты
Invoke-RestMethod -Uri "http://192.168.3.100:8200/v1/kv/data/main-path" -Method DELETE -Headers $Headers
</code></pre>
<p>Vault client:</p>
<pre><code class="language-bash"># Установить клиент в Linux (debian):
wget -O - https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
sudo apt update &amp;&amp; sudo apt install vault
# Включить механизм секретов KV
vault secrets enable -version=1 kv 
# Создать секрет
vault kv put kv/main-path key_name=secret_value
# Список секретов
vault kv list kv/
# Получить содержимое секрета
vault kv get -mount="kv" "main-path"
# Удалить секреты
vault kv delete kv/my-secret
</code></pre>
<h2 id="hashicorpconsul"><a class="header" href="#hashicorpconsul">HashiCorp/Consul</a></h2>
<p><a href="https://github.com/hashicorp/consul">Consul</a> используется для кластеризации и централизованного хранения данных <code>Vault</code>, а также как самостоятельное <code>Key-Value</code> хранилище.</p>
<p>Создать конфигурацию:</p>
<pre><code class="language-bash">echo '
ui = true
log_level = "INFO"
acl {
  enabled = true
  default_policy = "deny"
  enable_token_persistence = true
}
' &gt; consul.hcl
</code></pre>
<p>Запускаем в контейнере:</p>
<pre><code class="language-bash">docker run -d \
  --name=consul \
  --restart=unless-stopped \
  -p 8500:8500 \
  -v ./consul_data:/consul/data \
  -v ./consul.hcl:/consul/config/consul.hcl \
  hashicorp/consul:latest \
  agent -server -bootstrap-expect=1 -client=0.0.0.0
</code></pre>
<p>Создать <code>root token</code>, который будет использоваться для управления системой <code>ACL</code> и для создания политик доступа и других токенов доступа:</p>
<pre><code class="language-bash">docker exec -it consul consul acl bootstrap
</code></pre>
<p>Создать новую политику доступа:</p>
<pre><code class="language-bash">docker exec -it consul consul acl policy create -name "default" -rules 'node_prefix "" { policy = "write" } service_prefix "" { policy = "write" } key_prefix "" { policy = "write" }' -token "382834da-28b6-c72c-7ffb-11acf9bf20bc"
</code></pre>
<p>Создать новый токен доступа:</p>
<pre><code class="language-bash">docker exec -it consul consul acl token create -policy-name "default" -token "382834da-28b6-c72c-7ffb-11acf9bf20bc"
</code></pre>
<p><code>curl http://localhost:8500/v1/health/service/consul?pretty</code> <br />
<code>curl --request PUT --data "ssh-rsa AAAA" http://localhost:8500/v1/kv/ssh/key</code> записать секрет KV Store Consul <br />
<code>curl -s http://localhost:8500/v1/kv/ssh/key | jq -r .[].Value | base64 --decode</code> извлечь содержимое секрета</p>
<h1 id="pussh"><a class="header" href="#pussh">pussh</a></h1>
<p><a href="https://github.com/bearstech/pussh">Pussh</a> — инструмент для параллельного выполнения команд через SSH на нескольких хостах одновременно, выводя результаты с указанием имени каждого хоста. Был внутренним инструментом Bearstech (хостинг-провайдер в Париже, Франция) примерно с 2008 года.</p>
<pre><code class="language-bash">sudo curl -s https://raw.githubusercontent.com/bearstech/pussh/refs/heads/master/pussh -o /usr/bin/pussh
sudo chmod +x /usr/bin/pussh

bash pussh -h root@192.168.3.102,root@192.168.3.103 uname -a

echo -e "root@192.168.3.102\nroot@192.168.3.103" &gt; host.list
pussh -f host.list uname -a
</code></pre>
<h1 id="sake"><a class="header" href="#sake">Sake</a></h1>
<p><a href="https://github.com/alajmo/sake">Sake</a> - это командный раннер для локальных и удаленных хостов. Вы определяете серверы и задачи в файле <code>sake.yaml</code>, а затем запускаете задачи на серверах.</p>
<pre><code class="language-bash">curl -sfL https://raw.githubusercontent.com/alajmo/sake/main/install.sh | sh
sake init # инициализировать sake.yml файл
sake list servers # вывести список машин
sake list tags  # список тегов (группы серверов)
sake list tasks # список задач
sake run ping --all # запустить задачу на все хосты
sake exec --all "uname -a &amp;&amp; uptime" # запустить команду на всех хостах
</code></pre>
<p>Пример конфигурации:</p>
<pre><code class="language-yaml">servers:
  localhost:
    host: 0.0.0.0
    local: true
  obsd:
    host: root@192.168.3.102:22
    tags: [bsd]
  fbsd:
    host: root@192.168.3.103:22
    tags: [bsd]
    work_dir: /tmp

env:
  DATE: $(date -u +"%Y-%m-%dT%H:%M:%S%Z")

specs:
  info:
    output: table
    ignore_errors: true
    omit_empty_rows: true
    omit_empty_columns: true
    any_fatal_errors: false
    ignore_unreachable: true
    strategy: free

tasks:
  ping:
    desc: Pong
    spec: info
    cmd: echo "pong"

  uname:
    name: OS
    desc: Print OS
    spec: info
    cmd: |
      os=$(uname -s)
      release=$(uname -r)
      echo "$os $release"

  uptime:
    name: Uptime
    desc: Print uptime
    spec: info
    cmd: uptime

  info:
    desc: Get system overview
    spec: info
    tasks:
      - task: ping
      - name: date
        cmd: echo $DATE
      - name: pwd
        cmd: pwd
      - task: uname
      - task: uptime
</code></pre>
<p><code>sake run info --tags bsd</code> запустить набор из 5 заданий из группы info</p>
<h1 id="puppet"><a class="header" href="#puppet">Puppet</a></h1>
<h2 id="bolt"><a class="header" href="#bolt">Bolt</a></h2>
<p><a href="https://github.com/puppetlabs/bolt">Bolt</a> - это инструмент оркестровки, который выполняет заданную команду или группу команд на локальной рабочей станции, а также напрямую подключается к удаленным целям с помощью SSH или WinRM, что не требует установки агентов.</p>
<p>Docs: https://www.puppet.com/docs/bolt/latest/getting_started_with_bolt.html</p>
<pre><code class="language-bash">wget https://apt.puppet.com/puppet-tools-release-bullseye.deb
sudo dpkg -i puppet-tools-release-bullseye.deb
sudo apt-get update
sudo apt-get install puppet-bolt
</code></pre>
<p><code>nano inventory.yaml</code></p>
<pre><code class="language-yaml">groups:
- name: bsd
  targets:
    - uri: 192.168.3.102:22
      name: openbsd
    - uri: 192.168.3.103:22
      name: freebsd
  config:
    transport: ssh
    ssh:
      user: root
      # password: root
      host-key-check: false
</code></pre>
<p><code>bolt command run uptime --inventory inventory.yaml --targets bsd</code> выполнить команду uptime на группе хостов bsd, заданной в файле inventory</p>
<p><code>echo name: lazyjournal &gt; bolt-project.yaml</code> создать файл проекта</p>
<p><code>mkdir plans &amp;&amp; nano test.yaml</code> создать директорию и файл с планом работ</p>
<pre><code class="language-yaml">parameters:
  targets:
    type: TargetSpec

steps:
  - name: clone
    command: rm -rf lazyjournal &amp;&amp; git clone https://github.com/Lifailon/lazyjournal
    targets: $targets

  - name: test
    command: cd lazyjournal &amp;&amp; go test -v -cover --run TestMainInterface
    targets: $targets

  - name: remove
    command: rm -rf lazyjournal
    targets: $targets
</code></pre>
<p><code>bolt plan show</code> вывести список всех планов</p>
<p><code>bolt plan run lazyjournal::test --inventory inventory.yaml --targets bsd -v</code> запустить план</p>
<h1 id="ansible"><a class="header" href="#ansible">Ansible</a></h1>
<p><code>apt -y update &amp;&amp; apt -y upgrade</code> <br />
<code>apt -y install ansible</code> v2.10.8 <br />
<code>apt -y install ansible-core</code> v2.12.0 <br />
<code>apt -y install sshpass</code></p>
<p><code>ansible-galaxy collection install ansible.windows</code> установить коллекцию модулей <br />
<code>ansible-galaxy collection install community.windows</code> <br />
<code>ansible-galaxy collection list | grep windows</code> <br />
<code>ansible-config dump | grep DEFAULT_MODULE_PATH</code> путь хранения модулей</p>
<p><code>apt-get -y install python-dev libkrb5-dev krb5-user</code> пакеты для Kerberos аутентификации <br />
<code>apt install python3-pip</code> <br />
<code>pip3 install requests-kerberos</code> <br />
<code>nano /etc/krb5.conf</code> настроить [realms] и [domain_realm] <br />
<code>kinit -C support4@domail.local</code> <br />
<code>klist</code></p>
<p><code>ansible --version</code> <br />
<code>config file = None</code> <br />
<code>nano /etc/ansible/ansible.cfg</code> файл конфигурации</p>
<pre><code class="language-yaml">[defaults]
inventory = /etc/ansible/hosts
# uncomment this to disable SSH key host checking
# Отключить проверку ключа ssh (для подключения используя пароль)
host_key_checking = False
</code></pre>
<h2 id="hosts"><a class="header" href="#hosts">Hosts</a></h2>
<p><code>nano /etc/ansible/hosts</code></p>
<pre><code class="language-yaml">[us]
pi-hole-01 ansible_host=192.168.3.101
zabbix-01 ansible_host=192.168.3.102
grafana-01 ansible_host=192.168.3.103
netbox-01 ansible_host=192.168.3.104

[all:vars]
ansible_ssh_port=2121
ansible_user=lifailon
ansible_password=123098
path_user=/home/lifailon
ansible_python_interpreter=/usr/bin/python3

[ws]
huawei-book-01 ansible_host=192.168.3.99
plex-01 ansible_host=192.168.3.100

[ws:vars]
ansible_port=5985
#ansible_port=5986
ansible_user=Lifailon
#ansible_user=support4@DOMAIN.LOCAL
ansible_password=123098
ansible_connection=winrm
ansible_winrm_scheme=http
ansible_winrm_transport=basic
#ansible_winrm_transport=kerberos
ansible_winrm_server_cert_validation=ignore
validate_certs=false

[win_ssh]
huawei-book-01 ansible_host=192.168.3.99
plex-01 ansible_host=192.168.3.100

[win_ssh:vars]
ansible_python_interpreter=C:\Users\Lifailon\AppData\Local\Programs\Python\Python311\` добавить переменную среды интерпритатора Python в Windows
ansible_connection=ssh
#ansible_shell_type=cmd
ansible_shell_type=powershell
</code></pre>
<p><code>ansible-inventory --list</code> проверить конфигурацию (читает в формате JSON) или YAML (-y) с просмотром все применяемых переменных</p>
<h2 id="windows-modules"><a class="header" href="#windows-modules">Windows Modules</a></h2>
<p><code>ansible us -m ping</code> <br />
<code>ansible win_ssh -m ping</code> <br />
<code>ansible us -m shell -a "uptime &amp;&amp; df -h | grep lv"</code> <br />
<code>ansible us -m setup | grep -iP "mem|proc"</code> информация о железе <br />
<code>ansible us -m apt -a "name=mc" -b</code> повысить привилегии sudo (-b) <br />
<code>ansible us -m service -a "name=ssh state=restarted enabled=yes" -b</code> перезапустить службу <br />
<code>echo "echo test" &gt; test.sh</code> <br />
<code>ansible us -m copy -a "src=test.sh dest=/root mode=777" -b</code> <br />
<code>ansible us -a "ls /root" -b</code> <br />
<code>ansible us -a "cat /root/test.sh" -b</code></p>
<p><code>ansible-doc -l | grep win_</code> <a href="https://docs.ansible.com/ansible/latest/collections/ansible/windows/">список всех модулей Windows</a> <br />
<code>ansible ws -m win_ping</code> windows модуль <br />
<code>ansible ws -m win_ping -u WinRM-Writer</code> указать логин <br />
<code>ansible ws -m setup</code> собрать подробную информацию о системе <br />
<code>ansible ws -m win_whoami</code> информация о правах доступах, группах доступа <br />
<code>ansible ws -m win_shell -a '$PSVersionTable'</code> <br />
<code>ansible ws -m win_shell -a 'Get-Service | where name -match "ssh|winrm"'</code> <br />
<code>ansible ws -m win_service -a "name=sshd state=stopped"</code> <br />
<code>ansible ws -m win_service -a "name=sshd state=started"</code></p>
<ul>
<li>win_shell (vars/debug)</li>
</ul>
<p><code>nano /etc/ansible/PowerShell-Vars.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
 ` Указать коллекцию модулей
  collections:
  - ansible.windows
 ` Задать переменные
  vars:
    SearchName: PermitRoot
  tasks:
  - name: Get port ssh
    win_shell: |
      Get-Content "C:\Programdata\ssh\sshd_config" | Select-String "{{SearchName}}"
   ` Передать вывод в переменную
    register: command_output
  - name: Output port ssh
   ` Вывести переменную на экран
    debug:
      var: command_output.stdout_lines
</code></pre>
<p><code>ansible-playbook /etc/ansible/PowerShell-Vars.yml</code> <br />
<code>ansible-playbook /etc/ansible/PowerShell-Vars.yml --extra-vars "SearchName='LogLevel|Syslog'"</code> передать переменную</p>
<ul>
<li>win_powershell</li>
</ul>
<p><code>nano /etc/ansible/powershell-param.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Run PowerShell script with parameters
    ansible.windows.win_powershell:
      parameters:
        Path: C:\Temp
        Force: true
      script: |
        [CmdletBinding()]
        param (
          [String]$Path,
          [Switch]$Force
        )
        New-Item -Path $Path -ItemType Directory -Force:$Force
</code></pre>
<p><code>ansible-playbook /etc/ansible/powershell-param.yml</code></p>
<ul>
<li>win_chocolatey</li>
</ul>
<p><code>nano /etc/ansible/setup-adobe-acrobat.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Install Acrobat Reader
    win_chocolatey:
      name: adobereader
      state: present
</code></pre>
<p><code>ansible-playbook /etc/ansible/setup-adobe-acrobat.yml</code></p>
<p><code>nano /etc/ansible/setup-openssh.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: install the Win32-OpenSSH service
    win_chocolatey:
      name: openssh
      package_params: /SSHServerFeature
      state: present
</code></pre>
<p><code>ansible-playbook /etc/ansible/setup-openssh.yml</code></p>
<ul>
<li>win_regedit</li>
</ul>
<p><code>nano /etc/ansible/win-set-shell-ssh-ps7.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Set the default shell to PowerShell 7 for Windows OpenSSH
    win_regedit:
      path: HKLM:\SOFTWARE\OpenSSH
      name: DefaultShell
     ` data: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
      data: 'C:\Program Files\PowerShell\7\pwsh.exe'
      type: string
      state: present
</code></pre>
<p><code>ansible-playbook /etc/ansible/win-set-shell-ssh-ps7.yml</code></p>
<ul>
<li>win_service</li>
</ul>
<p><code>nano /etc/ansible/win-service.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Start service
    win_service:
      name: sshd
      state: started
#     state: stopped
#     state: restarted
#     start_mode: auto
</code></pre>
<p><code>ansible-playbook /etc/ansible/win-service.yml</code></p>
<ul>
<li>win_service_info</li>
</ul>
<p><code>nano /etc/ansible/get-service.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Get info for a single service
    win_service_info:
      name: sshd
    register: service_info
  - name: Print returned information
    ansible.builtin.debug:
      var: service_info.services
</code></pre>
<p><code>ansible-playbook /etc/ansible/get-service.yml</code></p>
<ul>
<li>fetch/slurp</li>
</ul>
<p><code>nano /etc/ansible/copy-from-win-to-local.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Retrieve remote file on a Windows host
#   Скопировать файл из Windows-системы
    ansible.builtin.fetch:
#   Прочитать файл (передать в память в формате Base64)
#   ansible.builtin.slurp:
      src: C:\Telegraf\telegraf.conf
      dest: /root/telegraf.conf
      flat: yes
    register: telegraf_conf
  - name: Print returned information
    ansible.builtin.debug:
      msg: "{{ telegraf_conf['content'] | b64decode }}"
</code></pre>
<p><code>ansible-playbook /etc/ansible/copy-from-win-to-local.yml</code></p>
<ul>
<li>win_copy</li>
</ul>
<p><code>echo "Get-Service | where name -eq vss | Start-Service" &gt; /home/lifailon/Start-Service-VSS.ps1</code> <br />
<code>nano /etc/ansible/copy-file-to-win.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Copy file to win hosts
    win_copy:
      src: /home/lifailon/Start-Service-VSS.ps1
      dest: C:\Users\Lifailon\Desktop\Start-Service-VSS.ps1
</code></pre>
<p><code>ansible-playbook /etc/ansible/copy-file-to-win.yml</code></p>
<p><code>curl -OL https://github.com/PowerShell/PowerShell/releases/download/v7.3.6/PowerShell-7.3.6-win-x64.msi</code> <br />
<code>nano /etc/ansible/copy-file-to-win.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Copy file to win hosts
    win_copy:
      src: /home/lifailon/PowerShell-7.3.6-win-x64.msi
      dest: C:\Install\PowerShell-7.3.6.msi
</code></pre>
<p><code>ansible-playbook /etc/ansible/copy-file-to-win.yml</code></p>
<ul>
<li>win_command</li>
</ul>
<p><code>nano /etc/ansible/run-script-ps1.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Run PowerShell Script
    win_command: powershell -ExecutionPolicy ByPass -File C:\Users\Lifailon\Desktop\Start-Service-VSS.ps1
</code></pre>
<p><code>ansible-playbook /etc/ansible/run-script-ps1.yml</code></p>
<ul>
<li>win_package</li>
</ul>
<p><code>nano /etc/ansible/setup-msi-package.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Install MSI Package
    win_package:
#     path: C:\Install\7z-23.01.msi
      path: C:\Install\PowerShell-7.3.6.msi
      arguments:
        - /quiet
        - /passive
        - /norestart
</code></pre>
<p><code>ansible-playbook /etc/ansible/setup-msi-package.yml</code></p>
<ul>
<li>win_firewall_rule</li>
</ul>
<p><code>nano /etc/ansible/win-fw-open.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Open RDP port
    win_firewall_rule:
      name: Open RDP port
      localport: 3389
      action: allow
      direction: in
      protocol: tcp
      state: present
      enabled: yes
</code></pre>
<p><code>ansible-playbook /etc/ansible/win-fw-open.yml</code></p>
<ul>
<li>win_group</li>
</ul>
<p><code>nano /etc/ansible/win-creat-group.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Create a new group
    win_group:
      name: deploy
      description: Deploy Group
      state: present
</code></pre>
<p><code>ansible-playbook /etc/ansible/win-creat-group.yml</code></p>
<ul>
<li>win_group_membership</li>
</ul>
<p><code>nano /etc/ansible/add-user-to-group.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Add a local and domain user to a local group
    win_group_membership:
      name: deploy
      members:
        - WinRM-Writer
      state: present
</code></pre>
<p><code>ansible-playbook /etc/ansible/add-user-to-group.yml</code></p>
<ul>
<li>win_user</li>
</ul>
<p><code>nano /etc/ansible/creat-win-user.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Creat user
    win_user:
      name: test
      password: 123098
      state: present
      groups:
        - deploy
</code></pre>
<p><code>ansible-playbook /etc/ansible/creat-win-user.yml</code></p>
<p><code>nano /etc/ansible/delete-win-user.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Delete user
    ansible.windows.win_user:
      name: test
      state: absent
</code></pre>
<p><code>ansible-playbook /etc/ansible/delete-win-user.yml</code></p>
<ul>
<li>win_feature</li>
</ul>
<p><code>nano /etc/ansible/install-feature.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Install Windows Feature
      win_feature:
        name: SNMP-Service
        state: present
</code></pre>
<p><code>ansible-playbook /etc/ansible/install-feature.yml</code></p>
<ul>
<li>win_reboot</li>
</ul>
<p><code>nano /etc/ansible/win-reboot.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Reboot a slow machine that might have lots of updates to apply
    win_reboot:
      reboot_timeout: 3600
</code></pre>
<p><code>ansible-playbook /etc/ansible/win-reboot.yml</code></p>
<ul>
<li>win_find</li>
</ul>
<p><code>nano /etc/ansible/win-ls.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Find files in multiple paths
    ansible.windows.win_find:
      paths:
      - D:\Install\OpenSource
      patterns: ['*.rar','*.zip','*.msi']
     ` Файл созданный менее 7 дней назад
      age: -7d
     ` Размер файла больше 10MB
      size: 10485760
     ` Рекурсивный поиск (в дочерних директориях)
      recurse: true
    register: command_output
  - name: Output
    debug:
      var: command_output
</code></pre>
<p><code>ansible-playbook /etc/ansible/win-ls.yml</code></p>
<ul>
<li>win_uri</li>
</ul>
<p><code>nano /etc/ansible/rest-get.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: REST GET request to endpoint github
    ansible.windows.win_uri:
      url: https://api.github.com/repos/Lifailon/pSyslog/releases/latest
    register: http_output
  - name: Output
    debug:
      var: http_output
</code></pre>
<p><code>ansible-playbook /etc/ansible/rest-get.yml</code></p>
<ul>
<li>win_updates</li>
</ul>
<p><code>nano /etc/ansible/win-update.yml</code></p>
<pre><code class="language-yaml">- hosts: ws
  tasks:
  - name: Install only particular updates based on the KB numbers
    ansible.windows.win_updates:
      category_names:
      - SecurityUpdates
      - CriticalUpdates
      - UpdateRollups
      - Drivers
     ` Фильтрация
     ` accept_list:
     ` - KB2267602
     ` Поиск обновлений
     ` state: searched
     ` Загрузить обновления
     ` state: downloaded
     ` Установить обновления
      state: installed
      log_path: C:\Ansible-Windows-Upadte-Log.txt
      reboot: false
    register: wu_output
  - name: Output
    debug:
      var: wu_output
</code></pre>
<p><code>ansible-playbook /etc/ansible/win-update.yml</code></p>
<ul>
<li>win_chocolatey</li>
</ul>
<p><a href="https://chocolatey.org/install">Install</a> <br />
<a href="https://community.chocolatey.org/api/v2/package/chocolatey">API</a> <br />
<a href="https://docs.chocolatey.org/en-us/guides/organizations/organizational-deployment-guide">Deployment</a></p>
<pre><code class="language-yaml">- name: Ensure Chocolatey installed from internal repo
  win_chocolatey:
    name: chocolatey
    state: present
	# source: URL-адрес внутреннего репозитория
    source: https://community.chocolatey.org/api/v2/ChocolateyInstall.ps1
</code></pre>
<h1 id="jinja"><a class="header" href="#jinja">Jinja</a></h1>
<p>Локальное использование:</p>
<p><code>pip install jinja2 --break-system-packages</code></p>
<p><code>inventory.j2</code> шаблон для генерации</p>
<pre><code>[dev]
{% for host in hosts -%}
{{ host }} ansible_host={{ host }}
{% endfor %}
</code></pre>
<p><code>env.json</code> файл с переменными</p>
<pre><code class="language-json">{
  "hosts": ["192.168.3.101", "192.168.3.102", "192.168.3.103"]
}
</code></pre>
<p><code>render.py</code> скрипт для генерации файла inventory</p>
<pre><code class="language-Python">from jinja2 import Environment, FileSystemLoader
import json
# Загружаем переменные из JSON
with open('env.json') as f:
    data = json.load(f)
# Настройка шаблонизатора
env = Environment(loader=FileSystemLoader('.'))
template = env.get_template('inventory.j2')
output = template.render(data)
# Сохраняем результат в файл
with open('inventory.generated', 'w') as f:
    f.write(output)
</code></pre>
<p><code>python render.py</code></p>
<p>Использование в Ansible для обновления файла <code>hosts</code>:</p>
<p><code>inventory.ini</code></p>
<pre><code>[dev]
dev1 ansible_host=192.168.3.101
dev2 ansible_host=192.168.3.102
dev3 ansible_host=192.168.3.103
</code></pre>
<p><code>templates/hosts.j2</code></p>
<pre><code>127.0.0.1 localhost
{% for host in groups['all'] -%}
{{ hostvars[host]['ansible_host'] }} {{ host }}
{% endfor %}
</code></pre>
<p><code>playbook.yml</code></p>
<pre><code class="language-yaml">- name: Update hosts file
  hosts: all
  become: true
  tasks:
    - name: Generate hosts file
      template:
        src: hosts.j2
        dest: /etc/hosts
        owner: root
        group: root
        mode: '0644'
</code></pre>
<p><code>ansible-playbook -i inventory.ini playbook.yml --check --diff</code> отобразит изменения без их реального применения <br />
<code>ansible-playbook -i inventory.ini playbook.yml -K</code> позволяет передать пароль для root</p>
<h1 id="dsc"><a class="header" href="#dsc">DSC</a></h1>
<p><code>Import-Module PSDesiredStateConfiguration</code> <br />
<code>Get-Command -Module PSDesiredStateConfiguration</code> <br />
<code>(Get-Module PSDesiredStateConfiguration).ExportedCommands</code> <br />
<code>Get-DscLocalConfigurationManager</code></p>
<p><code>Get-DscResource</code> <br />
<code>Get-DscResource -Name File -Syntax</code> <a href="https://learn.microsoft.com/ru-ru/powershell/dsc/reference/resources/windows/fileresource?view=dsc-1.1">синтаксис</a></p>
<p><code>Ensure = Present</code> настройка должна быть включена (каталог должен присутствовать, процесс должен быть запущен, если нет – создать, запустить) <br />
<code>Ensure = Absent</code> настройка должна быть выключена (каталога быть не должно, процесс не должен быть запущен, если нет – удалить, остановить)</p>
<pre><code class="language-PowerShell">Configuration TestConfiguraion
{
    Ctrl+Space
}

Configuration DSConfigurationProxy 
{
    Node vproxy-01 
    {
        File CreateDir
        {
            Ensure = "Present"
            Type = "Directory"
            DestinationPath = "C:\Temp"
        }
        Service StopW32time
        {
            Name = "w32time"
            State = "Stopped"` Running
        }
    WindowsProcess RunCalc
        {
            Ensure = "Present"
            Path = "C:\WINDOWS\system32\calc.exe"
            Arguments = ""
        }
        Registry RegSettings
        {
            Ensure = "Present"
            Key = "HKEY_LOCAL_MACHINE\SOFTWARE\MySoft"
            ValueName = "TestName"
            ValueData = "TestValue"
            ValueType = "String"
        }
#		WindowsFeature IIS
#       {
#            Ensure = "Present"
#            Name = "Web-Server"
#       }
    }
}
</code></pre>
<p><code>$Path = (DSConfigurationProxy).DirectoryName</code> <br />
<code>Test-DscConfiguration -Path $Path | select *</code> ResourcesInDesiredState - уже настроено, ResourcesNotInDesiredState - не настроено (не соответствует) <br />
<code>Start-DscConfiguration -Path $Path</code> <br />
<code>Get-Job</code> <br />
<code>$srv = "vproxy-01"</code> <br />
<code>Get-Service -ComputerName $srv | ? name -match w32time # Start-Service</code> <br />
<code>icm $srv {Get-Process | ? ProcessName -match calc} | ft # Stop-Process -Force</code> <br />
<code>icm $srv {ls C:\ | ? name -match Temp} | ft</code> rm`</p>
<pre><code class="language-PowerShell">Configuration InstallPowerShellCore {
    Import-DscResource -ModuleName PSDesiredStateConfiguration
    Node localhost {
        Script InstallPowerShellCore {
            GetScript = {
                return @{
                    GetScript = $GetScript
                }
            }
            SetScript = {
        [string]$url = $(Invoke-RestMethod https://api.github.com/repos/PowerShell/PowerShell/releases/latest).assets.browser_download_url -match "win-x64.zip"
                $downloadPath = "$home\Downloads\PowerShell.zip"
                $installPath = "$env:ProgramFiles\PowerShell\7"
                Invoke-WebRequest -Uri $url -OutFile $downloadPath
                Expand-Archive -Path $downloadPath -DestinationPath $installPath -Force
            }
            TestScript = {
                return Test-Path "$env:ProgramFiles\PowerShell\7\pwsh.exe"
            }
        }
    }
}
</code></pre>
<p><code>$Path = (InstallPowerShellCore).DirectoryName</code> <br />
<code>Test-DscConfiguration -Path $Path</code> <br />
<code>Start-DscConfiguration -Path $path -Wait -Verbose</code> <br />
<code>Get-Job</code></p>
<h1 id="psappdeploytoolkit"><a class="header" href="#psappdeploytoolkit">PSAppDeployToolkit</a></h1>
<h2 id="install-deploytoolkit"><a class="header" href="#install-deploytoolkit">Install-DeployToolkit</a></h2>
<pre><code class="language-PowerShell">$githubRepository = "psappdeploytoolkit/psappdeploytoolkit"
$filenamePatternMatch = "PSAppDeployToolkit*.zip"
$psadtReleaseUri = "https://api.github.com/repos/$githubRepository/releases/latest"
$psadtDownloadUri = ((Invoke-RestMethod -Method GET -Uri $psadtReleaseUri).assets | Where-Object name -like $filenamePatternMatch ).browser_download_url
$zipExtractionPath = Join-Path $env:USERPROFILE "Downloads" "PSAppDeployToolkit"
$zipTempDownloadPath = Join-Path -Path $([System.IO.Path]::GetTempPath()) -ChildPath $(Split-Path -Path $psadtDownloadUri -Leaf)
## Download to a temporary folder
Invoke-WebRequest -Uri $psadtDownloadUri -Out $zipTempDownloadPath
## Remove any Zone.Identifier alternate data streams to unblock the file (if required)
Unblock-File -Path $zipTempDownloadPath
New-Item -Type Directory $zipExtractionPath
Expand-Archive -Path $zipTempDownloadPath -OutputPath $zipExtractionPath -Force
Write-Host ("File: {0} extracted to Path: {1}" -f $psadtDownloadUri, $zipExtractionPath) -ForegroundColor Yellow
Remove-Item $zipTempDownloadPath
</code></pre>
<h2 id="deploy-notepad-plus-plus"><a class="header" href="#deploy-notepad-plus-plus">Deploy-Notepad-Plus-Plus</a></h2>
<p><code>$url_notepad = "https://github.com/notepad-plus-plus/notepad-plus-plus/releases/download/v8.6.6/npp.8.6.6.Installer.x64.exe"</code> <br />
<code>Invoke-RestMethod $url_notepad -OutFile "$home\Downloads\PSAppDeployToolkit\Toolkit\Files\npp.8.6.6.Installer.x64.exe"</code></p>
<pre><code class="language-PowerShell">'# Подключаем модуль PSAppDeployToolkit
Import-Module "$PSScriptRoot\AppDeployToolkit\AppDeployToolkitMain.ps1"
# Название приложения
$AppName = "Notepad++"
# Версия приложения
$AppVersion = "8.6.6"
# Путь к установщику Notepad++
$InstallerPath = "$PSScriptRoot\Files\npp.$AppVersion.Installer.x64.exe"
# Проверка существования установщика
If (-not (Test-Path $InstallerPath)) {
    Write-Host "Установщик Notepad++ не найден: $InstallerPath"
    Exit-Script -ExitCode 1
}
# Настройки установки Notepad++
$InstallerArguments = "/S /D=$ProgramFiles\Notepad++"
Function Install-Application {
    # Выводим сообщение о начале установки
    Show-InstallationWelcome -CloseApps "iexplore" -CheckDiskSpace -PersistPrompt
    # Запускаем установку
    Execute-Process -Path $InstallerPath -Parameters $InstallerArguments -WindowStyle Hidden -IgnoreExitCodes "3010"
    # Выводим сообщение об успешной установке
    Show-InstallationPrompt -Message "Установка $AppName завершена." -ButtonRightText "Закрыть" -Icon Information -NoWait
    # Завершаем процесс установки
    Exit-Script -ExitCode $AppDependentExitCode
}
Install-Application' | Out-File "$home\Downloads\PSAppDeployToolkit\Toolkit\Deploy-Application.ps1" -Encoding unicode
</code></pre>
<p><code>powershell -File "$home\Downloads\PSAppDeployToolkit\Toolkit\Deploy-Application.ps1"</code></p>
<h2 id="uninstall-notepad-plus-plus"><a class="header" href="#uninstall-notepad-plus-plus">Uninstall-Notepad-Plus-Plus</a></h2>
<pre><code class="language-PowerShell">'Import-Module "$PSScriptRoot\AppDeployToolkit\AppDeployToolkitMain.ps1"
$AppName = "Notepad++"
$UninstallerPath = "C:\Program Files\Notepad++\uninstall.exe"
If (-not (Test-Path $UninstallerPath)) {
    Write-Host "Деинсталлятор Notepad++ не найден: $UninstallerPath"
    Exit-Script -ExitCode 1
}
Function Uninstall-Application {
    Show-InstallationWelcome -CloseApps "iexplore" -CheckDiskSpace -PersistPrompt
    Execute-Process -Path $UninstallerPath -Parameters "/S" -WindowStyle Hidden -IgnoreExitCodes "3010"
    Show-InstallationPrompt -Message "Программа $AppName удалена." -ButtonRightText "Закрыть" -Icon Information -NoWait
    Exit-Script -ExitCode $AppDependentExitCode
}
Uninstall-Application' | Out-File "$home\Downloads\PSAppDeployToolkit\Toolkit\Deploy-Application.ps1" -Encoding unicode
</code></pre>
<p><code>powershell -File "$home\Downloads\PSAppDeployToolkit\Toolkit\Deploy-Application.ps1"</code></p>
<h2 id="deploy-winscp"><a class="header" href="#deploy-winscp">Deploy-WinSCP</a></h2>
<pre><code class="language-PowerShell">$PSAppDeployToolkit = "$home\Downloads\PSAppDeployToolkit\"
$version = "6.3.3"
$url_winscp = "https://cdn.winscp.net/files/WinSCP-$version.msi?secure=P2HLWGKaMDigpDQw-H9BgA==,1716466173"
$WinSCP_Template = Get-Content "$PSAppDeployToolkit\Examples\WinSCP\Deploy-Application.ps1" # читаем пример конфигурации для WinSCP
$WinSCP_Template_Latest = $WinSCP_Template -replace "6.3.2","$version" # обновляем версию на актуальную
$WinSCP_Template_Latest &gt; "$PSAppDeployToolkit\Toolkit\Deploy-Application.ps1" # заменяем скрипт развертывания 
Invoke-RestMethod $url_winscp -OutFile "$PSAppDeployToolkit\Toolkit\Files\WinSCP-$version.msi" # загружаем msi-пакет
powershell -File "$PSAppDeployToolkit\Toolkit\Deploy-Application.ps1" # запускаем установку
</code></pre>
<h1 id="atlassian"><a class="header" href="#atlassian">Atlassian</a></h1>
<h2 id="bitbucket"><a class="header" href="#bitbucket">Bitbucket</a></h2>
<pre><code class="language-PowerShell">$url = "https://github.com/AtlassianPS/BitbucketPS/archive/refs/heads/master.zip"
Invoke-RestMethod $url -OutFile $home\Downloads\BitbucketPS.zip
Expand-Archive -Path "$home\Downloads\BitbucketPS.zip" -OutputPath "$home\Downloads"
Copy-Item -Path "$home\Downloads\BitbucketPS-master\*" -Destination "$($env:PSModulePath.Split(";")[0])\PSBitBucket" -Recurse
Remove-Item "$home\Downloads\Bitbucket*" -Recurse -Force
</code></pre>
<p><code>Import-Module PSBitBucket</code> <br />
<code>Get-Command -Module PSBitBucket</code> <br />
<code>Set-BitBucketConfigServer -Url $url -User username -Password password</code> установить конфигурацию сервера BitBucket <br />
<code>Get-BitBucketConfigServer</code> получить текущую конфигурацию сервера BitBucket <br />
<code>Get-Repositories</code> получить список всех репозиториев для текущей конфигурации сервера BitBucket <br />
<code>Get-ProjectKey</code> получить ключ проекта BitBucket <br />
<code>Get-BranchList -Repository pSyslog</code> список всех веток в репозитории <br />
<code>Get-Branch -Repository pSyslog -Branch main</code> получить информацию о конкретной ветке репозитория <br />
<code>Get-CommitMessage -Repository pSyslog -CommitHash $hash</code> получить сообщение коммита по его хэшу <br />
<code>Get-Commits -Repository pSyslog -Limit 10</code> список последних 10 коммитов в репозитории <br />
<code>Get-CommitsForBranch -Repository pSyslog -Branch main</code> список коммитов для конкретной ветки в репозитории</p>
<h2 id="jira"><a class="header" href="#jira">Jira</a></h2>
<p><code>Install-Module JiraPS -Scope CurrentUser -Repository PSGallery -AllowClobber -Force</code> <br />
<code>Get-Command -Module JiraPS</code> <br />
<code>Get-JiraServerInfo</code> информация о сервере <br />
<code>Add-JiraFilterPermission</code> добавить разрешения для фильтра <br />
<code>Add-JiraGroupMember</code> добавить участника в группу <br />
<code>Add-JiraIssueAttachment</code> добавить вложения к задаче <br />
<code>Add-JiraIssueComment</code> добавить комментария к задаче <br />
<code>Add-JiraIssueLink</code> добавить ссылки на задачу <br />
<code>Add-JiraIssueWatcher</code> добавить наблюдателя к задаче <br />
<code>Add-JiraIssueWorklog</code> добавить рабочего журнала к задаче <br />
<code>Find-JiraFilter</code> поиск фильтра <br />
<code>Format-Jira</code> форматирование данных Jira <br />
<code>Get-JiraComponent</code> получение компонента проекта <br />
<code>Get-JiraConfigServer</code> получение конфигурации сервера Jira <br />
<code>Get-JiraField</code> получение поля Jira <br />
<code>Get-JiraFilter</code> получение фильтра <br />
<code>Get-JiraFilterPermission</code> получение разрешения фильтра <br />
<code>Get-JiraGroup</code> получение группы <br />
<code>Get-JiraGroupMember</code> получение участников группы <br />
<code>Get-JiraIssue</code> получение задачи <br />
<code>Get-JiraIssueAttachment</code> получение вложения задачи <br />
<code>Get-JiraIssueAttachmentFile</code> получение файла вложения задачи <br />
<code>Get-JiraIssueComment</code> получение комментария задачи <br />
<code>Get-JiraIssueCreateMetadata</code> получение метаданных создания задачи <br />
<code>Get-JiraIssueEditMetadata</code> получение метаданных редактирования задачи <br />
<code>Get-JiraIssueLink</code> получение ссылки задачи <br />
<code>Get-JiraIssueLinkType</code> получение типа ссылки задачи <br />
<code>Get-JiraIssueType</code> получение типа задачи <br />
<code>Get-JiraIssueWatcher</code> получение наблюдателя задачи <br />
<code>Get-JiraIssueWorklog</code> получение рабочего журнала задачи <br />
<code>Get-JiraPriority</code> получение приоритета задачи <br />
<code>Get-JiraProject</code> получение проекта <br />
<code>Get-JiraRemoteLink</code> получение удаленной ссылки <br />
<code>Get-JiraServerInformation</code> получение информации о сервере Jira <br />
<code>Get-JiraSession</code> получение сессии <br />
<code>Get-JiraUser</code> получение пользователя <br />
<code>Get-JiraVersion</code> получение версии проекта <br />
<code>Invoke-JiraIssueTransition</code> выполнение перехода задачи <br />
<code>Invoke-JiraMethod</code> выполнение метода Jira <br />
<code>Move-JiraVersion</code> перемещение версии проекта <br />
<code>New-JiraFilter</code> создание нового фильтра <br />
<code>New-JiraGroup</code> создание новой группы <br />
<code>New-JiraIssue</code> создание новой задачи <br />
<code>New-JiraSession</code> создание новой сессии <br />
<code>New-JiraUser</code> создание нового пользователя <br />
<code>New-JiraVersion</code> создание новой версии проекта <br />
<code>Remove-JiraFilter</code> удаление фильтра <br />
<code>Remove-JiraFilterPermission</code> удаление разрешения фильтра <br />
<code>Remove-JiraGroup</code> удаление группы <br />
<code>Remove-JiraGroupMember</code> удаление участника группы <br />
<code>Remove-JiraIssue</code> удаление задачи <br />
<code>Remove-JiraIssueAttachment</code> удаление вложения задачи <br />
<code>Remove-JiraIssueLink</code> удаление ссылки задачи <br />
<code>Remove-JiraIssueWatcher</code> удаление наблюдателя задачи <br />
<code>Remove-JiraRemoteLink</code> удаление удаленной ссылки <br />
<code>Remove-JiraSession</code> удаление сессии <br />
<code>Remove-JiraUser</code> удаление пользователя <br />
<code>Remove-JiraVersion</code> удаление версии проекта <br />
<code>Set-JiraConfigServer</code> установка конфигурации сервера Jira <br />
<code>Set-JiraFilter</code> установка фильтра <br />
<code>Set-JiraIssue</code> установка задачи <br />
<code>Set-JiraIssueLabel</code> установка метки задачи <br />
<code>Set-JiraUser</code> установка пользователя <br />
<code>Set-JiraVersion</code> установка версии проекта</p>
<h2 id="confluence"><a class="header" href="#confluence">Confluence</a></h2>
<p><code>Install-Module ConfluencePS -Scope CurrentUser -Repository PSGallery -AllowClobber -Force</code> <br />
<code>Get-Command -Module ConfluencePS</code> <br />
<code>Add-ConfluenceAttachment</code> добавить вложения к странице <br />
<code>Add-ConfluenceLabel</code> добавить метки к странице <br />
<code>ConvertTo-ConfluenceStorageFormat</code> конвертация содержимого в формат хранения Confluence <br />
<code>ConvertTo-ConfluenceTable</code> конвертация данных в таблицу Confluence <br />
<code>Get-ConfluenceAttachment</code> получение вложения страницы <br />
<code>Get-ConfluenceAttachmentFile</code> получение файла вложения страницы <br />
<code>Get-ConfluenceChildPage</code> получение дочерних страниц <br />
<code>Get-ConfluenceLabel</code> получение меток страницы <br />
<code>Get-ConfluencePage</code> получение информации о странице <br />
<code>Get-ConfluenceSpace</code> получение информации о пространстве <br />
<code>Invoke-ConfluenceMethod</code> выполнение метода Confluence <br />
<code>New-ConfluencePage</code> создание новой страницы <br />
<code>New-ConfluenceSpace</code> создание нового пространства <br />
<code>Remove-ConfluenceAttachment</code> удаление вложения страницы <br />
<code>Remove-ConfluenceLabel</code> удаление метки со страницы <br />
<code>Remove-ConfluencePage</code> удаление страницы <br />
<code>Remove-ConfluenceSpace</code> удаление пространства <br />
<code>Set-ConfluenceAttachment</code> установка вложения страницы <br />
<code>Set-ConfluenceInfo</code> установка информации о странице <br />
<code>Set-ConfluenceLabel</code> установка метки страницы <br />
<code>Set-ConfluencePage</code> установка страницы</p>
<h1 id="prometheus"><a class="header" href="#prometheus">Prometheus</a></h1>
<p>Пример создания экспортера для получения метрик температуры всех дисков из CrystalDiskInfo и отправки в <a href="https://github.com/prometheus/prometheus">Prometheus</a> через <a href="https://github.com/prometheus/pushgateway">PushGateway</a>.</p>
<ol>
<li>Запускаем <code>pushgateway</code> в контейнере:</li>
</ol>
<p><code>docker run -d --name pushgateway --restart unless-stopped -p 19091:9091 prom/pushgateway</code></p>
<ol start="2">
<li>Запускаем скрипт в консоли:</li>
</ol>
<pre><code class="language-PowerShell">$instance = [System.Net.Dns]::GetHostName()
$pushgatewayUrl = "http://192.168.3.100:19091/metrics/job/disk_temperature"
# Изменить адрес шлюза на имя контейнера при запуске через compose
# $pushgatewayUrl = "http://pushgateway:9091/metrics/job/disk_temperature"
$path = "C:/Program Files/CrystalDiskInfo/Smart"
# Изменить путь при запуске в контейнере Docker через WSL
# $path = "/mnt/c/Program Files/CrystalDiskInfo/Smart"
# Необходимо строго использовать синтаксис PowerShell (избегая псевдонимы ls)
$diskArray = $(Get-ChildItem $path).Name
while ($true) {
    $metrics = "# TYPE disk_temperature gauge`n"
    foreach ($diskName in $diskArray) {
        $lastTemp = $(@("Date,Value")+$(Get-Content "$path/$diskName/Temperature.csv") | ConvertFrom-Csv)[-1].Value
        $diskLabel = $diskName -replace "[^a-zA-Z0-9]", "_"
        $metrics += "disk_temperature{disk=`"$diskLabel`",instance=`"$instance`"} $lastTemp`n"
    }
    $metrics
    Invoke-RestMethod -Uri $pushgatewayUrl -Method POST -Body $metrics
    Start-Sleep 10
}
</code></pre>
<ol start="3">
<li>Проверяем наличие метрик на конечной точке шлюза:</li>
</ol>
<pre><code class="language-PowerShell">$(Invoke-RestMethod http://192.168.3.100:9091/metrics).Split("`n") | Select-String "disk_temperature"
</code></pre>
<ol start="4">
<li>Добавляем конфигурацию в <code>prometheus.yml</code>:</li>
</ol>
<pre><code class="language-yaml">scrape_configs:
  - job_name: cdi-exporter
    scrape_interval: 10s
    scrape_timeout: 2s
    metrics_path: /metrics
    static_configs:
      - targets:
        - '192.168.3.100:19091'
</code></pre>
<p><code>docker-compose kill -s SIGHUP prometheus</code> применяем изменения</p>
<ol start="5">
<li>Собираем контейнер в среде <code>WSL</code> с монтированием системного диска Windows:</li>
</ol>
<pre><code class="language-dockerfile">Write-Output '
FROM mcr.microsoft.com/powershell:latest
WORKDIR /cdi-exporter
COPY cdi-exporter.ps1 ./cdi-exporter.ps1
CMD ["pwsh", "-File", "cdi-exporter.ps1"]
' | Out-File -FilePath dockerfile
</code></pre>
<p><code>docker build -t cdi-exporter .</code> <br />
<code>docker run -d -v /mnt/c:/mnt/c --name cdi-exporter cdi-exporter</code></p>
<ol start="6">
<li>Собираем стек из шлюза и скрипта в <code>compose</code>:</li>
</ol>
<pre><code class="language-yaml">Write-Output '
services:
  cdi-exporter:
    build:
      context: .
      dockerfile: dockerfile
    container_name: cdi-exporter
    volumes:
      - /mnt/c:/mnt/c
    restart: unless-stopped

  pushgateway:
    image: prom/pushgateway
    container_name: pushgateway
    ports:
      - "19091:9091"
    restart: unless-stopped
' | Out-File -FilePath docker-compose.yml
</code></pre>
<p><code>docker-compose up -d</code></p>
<ol start="7">
<li>Настраиваем <code>Dashboard</code> в <code>Grafana</code>:</li>
</ol>
<p>Переменные для фильтрации запроса: <br />
hostName: <code>label_values(exported_instance)</code> <br />
diskName: <code>label_values(disk)</code> <br />
Метрика температуры: <code>disk_temperature{exported_instance="$hostName", disk=~"$diskName"}</code></p>
<h1 id="zabbix"><a class="header" href="#zabbix">Zabbix</a></h1>
<h2 id="zabbix-agent-1"><a class="header" href="#zabbix-agent-1">Zabbix Agent</a></h2>
<p><strong>Zabbix Agent Deploy:</strong></p>
<pre><code class="language-PowerShell">$url = "https://cdn.zabbix.com/zabbix/binaries/stable/6.4/6.4.5/zabbix_agent2-6.4.5-windows-amd64-static.zip"
$path = "$home\Downloads\zabbix-agent2-6.4.5.zip"
$WebClient = New-Object System.Net.WebClient
$WebClient.DownloadFile($url, $path) # скачать файл
Expand-Archive $path -DestinationPath "C:\zabbix-agent2-6.4.5\" # разархивировать
Remove-Item $path # удалить архив
New-NetFirewallRule -DisplayName "Zabbix-Agent" -Profile Any -Direction Inbound -Action Allow -Protocol TCP -LocalPort 10050,10051 # открыть порты в FW

$Zabbix_Server = "192.168.3.102"
$conf = "C:\zabbix-agent2-6.4.5\conf\zabbix_agent2.conf"
$cat = cat $conf
$rep = $cat -replace "Server=.+","Server=$Zabbix_Server"
$rep | Select-String Server=
$rep &gt; $conf

$exe = "C:\zabbix-agent2-6.4.5\bin\zabbix_agent2.exe"
.$exe --config $conf --install # установить службу
Get-Service *Zabbix*Agent* | Start-Service # запустить службу
#.$exe --config $conf --uninstall # удалить службу
</code></pre>
<p><strong>zabbix_agent2.conf</strong></p>
<pre><code class="language-conf"># Агент может работать в пассивном (сервер забирает сам информацию) и активном режиме (агент сам отправляет):
Server=192.168.3.102
ServerActive=192.168.3.102
# Требуется указать hostname для ServerActive:
Hostname=huawei-book-01
# Если не указано, используется для генерации имени хоста (игнорируется, если имя хоста определено):
# HostnameItem=system.hostname
# Как часто обновляется список активных проверок, в секундах (Range: 60-3600):
RefreshActiveChecks=120
# IP-адрес источника для исходящих соединений:
# SourceIP=
# Агент будет слушать на этом порту соединения с сервером (Range: 1024-32767):
# ListenPort=10050
# Список IP-адресов, которые агент должен прослушивать через запятую
# ListenIP=0.0.0.0
# Агент будет прослушивать этот порт для запросов статуса HTTP (Range: 1024-32767):
# StatusPort=
ControlSocket=\\.\pipe\agent.sock
# Куда вести журнал (file/syslog/console):
LogType=file
LogFile=C:\zabbix-agent2-6.4.5\zabbix_agent2.log
# Размер лога от 0-1024 MB (0 - отключить автоматическую ротацию логов)
LogFileSize=100
# Уровень логирования. 4 - для отладки (выдает много информации)
DebugLevel=4
</code></pre>
<h2 id="zabbix-sender"><a class="header" href="#zabbix-sender">Zabbix Sender</a></h2>
<p>Используется для отправки данных на сервер</p>
<p>Создать host - задать произвольное имя (powershell-host) и добавить в группу на сервере</p>
<p>Создать Items вручную:</p>
<p><code>Name</code>: Service Count <br />
<code>Type</code>: Zabbix trapper <br />
<code>Key</code>: service.count <br />
<code>Type of Information</code>: Numeric</p>
<pre><code class="language-PowerShell">$path = "C:\zabbix-agent2-6.4.5\bin"
$scount = (Get-Service).Count
.$path\zabbix_sender.exe -z 192.168.3.102 -s "powershell-host" -k service.count -o $scount # отправить данные на сервер
</code></pre>
<h2 id="zabbix-get"><a class="header" href="#zabbix-get">Zabbix Get</a></h2>
<p>Используется для получения данных с агента (как их запрашивает сервер)</p>
<p><code>apt install zabbix-get</code> <br />
<code>nano /etc/zabbix/zabbix_agentd.conf</code> <br />
<code>Server=127.0.0.1,192.168.3.102,192.168.3.99</code> добавить сервера для получения данных через zabbix_get с агента (как их запрашивает сервер)</p>
<p><code>.$path\zabbix_get -s 192.168.3.101 -p 10050 -k agent.version</code> проверить версию агента <br />
<code>.$path\zabbix_get -s 192.168.3.101 -p 10050 -k agent.ping</code> 1 - ok <br />
<code>.$path\zabbix_get -s 192.168.3.101 -p 10050 -k net.if.discovery</code> список сетевых интерфейсов <br />
<code>.$path\zabbix_get -s 192.168.3.101 -p 10050 -k net.if.in["ens33"]</code> <br />
<code>.$path\zabbix_get -s 192.168.3.101 -p 10050 -k net.if.out["ens33"]</code></p>
<h2 id="userparameter"><a class="header" href="#userparameter">UserParameter</a></h2>
<p>Пользовательские параметры</p>
<p><code>UserParameter=process.count,powershell -Command "(Get-Process).Count"</code> <br />
<code>UserParameter=process.vm[*],powershell -Command "(Get-Process $1).ws"</code></p>
<p>Получение данных:</p>
<p><code>C:\zabbix-agent2-6.4.5\bin\zabbix_get.exe -s 127.0.0.1 -p 10050 -k process.count</code> <br />
<code>C:\zabbix-agent2-6.4.5\bin\zabbix_get.exe -s 127.0.0.1 -p 10050 -k process.vm[zabbix_agent2] </code><br />
<code>C:\zabbix-agent2-6.4.5\bin\zabbix_get.exe -s 127.0.0.1 -p 10050 -k process.vm[powershell]</code></p>
<p>Создать новые Items на сервере:</p>
<p>key: <code>process.count</code> <br />
key: <code>process.vm[zabbix_agent2]</code></p>
<h2 id="include-plugins"><a class="header" href="#include-plugins">Include Plugins</a></h2>
<ul>
<li>Добавить параметр Include для включения конфигурационных файлов подключаемых плагинов</li>
</ul>
<p><code>'Include=.\zabbix_agent2.d\plugins.d\*.conf' &gt;&gt; C:\zabbix-agent2-6.4.5\conf\zabbix_agent2.conf</code></p>
<ul>
<li>Создать конфигурационный файл с пользовательскими параметрами в каталоге, путь к которому указан в zabbix_agentd.conf</li>
</ul>
<p><code>'UserParameter=Get-Query-Param[*],powershell.exe -noprofile -executionpolicy bypass -File C:\zabbix-agent2-6.4.5\conf\zabbix_agent2.d\scripts\User-Sessions\Get-Query-Param.ps1 $1' &gt; C:\zabbix-agent2-6.4.5\conf\zabbix_agent2.d\plugins.d\User-Sessions.conf</code></p>
<ul>
<li>Поместить скрипт Get-Query-Param.ps1 в каталог, путь к которому указан в User-Sessions.conf. Скрипт содержим пользовательские параметры, которые он принимает от Zabbix сервера для передачи их в функции скрипта.</li>
</ul>
<pre><code class="language-PowerShell">Param([string]$select)
if ($select -eq "ACTIVEUSER") {
    (Get-Query | where status -match "Active").User
}
if ($select -eq "INACTIVEUSER") {
    (Get-Query | where status -match "Disconnect").User
}
if ($select -eq "ACTIVECOUNT") {
    (Get-Query | where status -match "Active").Status.Count
}
if ($select -eq "INACTIVECOUNT") {
    (Get-Query | where status -match "Disconnect").Status.Count
}
</code></pre>
<ul>
<li>Проверить работу скрипта:</li>
</ul>
<p><code>$path = "C:\zabbix-agent2-6.4.5\conf\zabbix_agent2.d\scripts\User-Sessions"</code> <br />
<code>.$path\Get-Query-Param.ps1 ACTIVEUSER</code> <br />
<code>.$path\Get-Query-Param.ps1 INACTIVEUSER</code> <br />
<code>.$path\Get-Query-Param.ps1 ACTIVECOUNT</code> <br />
<code>.$path\Get-Query-Param.ps1 INACTIVECOUNT</code></p>
<ul>
<li>Создать Items с ключами:</li>
</ul>
<p><code>Get-Query-Param[ACTIVEUSER]</code> Type: Text <br />
<code>Get-Query-Param[INACTIVEUSER]</code> Type: Text <br />
<code>Get-Query-Param[ACTIVECOUNT]</code> Type: Int <br />
<code>Get-Query-Param[INACTIVECOUNT]</code> Type: Int</p>
<ul>
<li>Макросы:</li>
</ul>
<p><code>{$ACTIVEMAX} = 16</code> <br />
<code>{$ACTIVEMIN} = 0</code></p>
<ul>
<li>Триггеры:</li>
</ul>
<p><code>last(/Windows-User-Sessions/Get-Query-Param[ACTIVECOUNT])&gt;{$ACTIVEMAX}</code> <br />
<code>min(/Windows-User-Sessions/Get-Query-Param[ACTIVECOUNT],24h)={$ACTIVEMIN}</code></p>
<h2 id="zabbix-api"><a class="header" href="#zabbix-api">Zabbix API</a></h2>
<p><a href="https://www.zabbix.com/documentation/current/en/manual/api/reference">Documentation</a></p>
<p><code>$ip = "192.168.3.102"</code> <br />
<code>$url = "http://$ip/zabbix/api_jsonrpc.php"</code></p>
<p>Получение токена доступа:</p>
<pre><code class="language-PowerShell">$data = @{
    "jsonrpc"="2.0";
    "method"="user.login";
    "params"=@{
        "username"="Admin"; # в версии до 6.4 параметр "user"
        "password"="zabbix";
    };
    "id"=1;
}
$token = (Invoke-RestMethod -Method POST -Uri $url -Body ($data | ConvertTo-Json) -ContentType "application/json").Result
</code></pre>
<p><code>$token = "2eefd25fdf1590ebcdb7978b5bcea1fff755c65b255da8cbd723181b639bb789"</code> сгенерировать токен в UI (http://192.168.3.102/zabbix/zabbix.php?action=token.list)</p>
<ul>
<li>user.get method</li>
</ul>
<pre><code class="language-PowerShell">$data = @{
    "jsonrpc"="2.0";
    "method"="user.get";
    "params"=@{
    };
    "auth"=$token;
    "id"=1;
}
$users = (Invoke-RestMethod -Method POST -Uri $url -Body ($data | ConvertTo-Json) -ContentType "application/json").Result
</code></pre>
<ul>
<li>problem.get method</li>
</ul>
<pre><code class="language-PowerShell">$data = @{
    "jsonrpc"="2.0";
    "method"="problem.get";
    "params"=@{
    };
    "auth"=$token;
    "id"=1;
}
(Invoke-RestMethod -Method POST -Uri $url -Body ($data | ConvertTo-Json) -ContentType "application/json").Result
</code></pre>
<ul>
<li>host.get method</li>
</ul>
<p>Получить список всех хостов (имя и id)</p>
<p><a href="https://www.zabbix.com/documentation/current/en/manual/api/reference/host">Endpoint host documentation</a></p>
<p><strong>host.create</strong> — создание новых хостов <br />
<strong>host.delete</strong> — удаление хостов <br />
<strong>host.get</strong> — получить список хостов <br />
<strong>host.massadd</strong> - добавление (привязка) объектов на хосты <br />
<strong>host.massremove</strong> - удаление объектов <br />
<strong>host.massupdate</strong> - замена или обновление объектов <br />
<strong>host.update</strong> - обновление хостов</p>
<pre><code class="language-PowerShell">$data = @{
    "jsonrpc"="2.0";
    "method"="host.get";
    "params"=@{
        "output"=@( # отфильтровать вывод
            "hostid";
            "host";
        );
    };
    "id"=2;
    "auth"=$token;
}
$hosts = (Invoke-RestMethod -Method POST -Uri $url -Body ($data | ConvertTo-Json) -ContentType "application/json").Result
$host_id = $hosts[3].hostid # забрать id хоста по индексу
</code></pre>
<ul>
<li>item.get</li>
</ul>
<p>Получить id элементов данных по наименованию ключа для конкретного хоста</p>
<pre><code class="language-PowerShell">$data = @{
    "jsonrpc"="2.0";
    "method"="item.get";
    "params"=@{
        "hostids"=@($host_id); # отфильтровать по хосту
    };
    "auth"=$token;
    "id"=1;
}
$items = (Invoke-RestMethod -Method POST -Uri $url -Body ($data | ConvertTo-Json) -ContentType "application/json").Result
$items_id = ($items | where key_ -match system.uptime).itemid # забрать id элемента данных
</code></pre>
<ul>
<li>history.get</li>
</ul>
<p>Получить всю историю элемента данных по его id</p>
<pre><code class="language-PowerShell">$data = @{
    "jsonrpc"="2.0";
    "method"="history.get";
    "params"=@{
        "hostids"=@($host_id);  # фильтрация по хосту
        "itemids"=@($items_id); # фильтрация по элементу данных
    };
    "auth"=$token;
    "id"=1;
}
$items_data_uptime = (Invoke-RestMethod -Method POST -Uri $url -Body ($data | ConvertTo-Json) -ContentType "application/json").Result # получить все данные по ключу у конкретного хоста
</code></pre>
<p>Ковенртация секунд в <code>TimeSpan</code>:</p>
<p><code>$sec = $items_data_uptime.value</code></p>
<pre><code class="language-PowerShell">function ConvertSecondsTo-TimeSpan {
    param (
        $insec
    )
    $TimeSpan = [TimeSpan]::fromseconds($insec)
    "{0:dd' day 'hh\:mm\:ss}" -f $TimeSpan
}
</code></pre>
<p><code>$UpTime = ConvertSecondsTo-TimeSpan $sec[-1]</code></p>
<p>Конвертация из времени <code>Unix</code>:</p>
<p><code>$time = $items_data_uptime.clock</code></p>
<pre><code class="language-PowerShell">function ConvertFrom-UnixTime {
    param (
        $intime
    )
    $EpochTime = [DateTime]"1/1/1970"
    $TimeZone = Get-TimeZone
    $UTCTime = $EpochTime.AddSeconds($intime)
    $UTCTime.AddMinutes($TimeZone.BaseUtcOffset.TotalMinutes)
}
</code></pre>
<p><code>$GetDataTime = ConvertFrom-UnixTime $time[-1]</code></p>
<p><code>($hosts | where hostid -eq $host_id).host</code> получить имя хоста <br />
<code>$UpTime</code> последнее полученное значение времени работы хоста <br />
<code>$GetDataTime</code> время последнего полученного значения</p>
<h1 id="load-testing"><a class="header" href="#load-testing">Load Testing</a></h1>
<h2 id="apache-benchmark"><a class="header" href="#apache-benchmark">Apache Benchmark</a></h2>
<pre><code class="language-PowerShell">$path = "$HOME\Downloads\apache"
New-Item $path -Type Directory
cd $path
curl -L -o apache.zip "https://www.apachelounge.com/download/VS17/binaries/httpd-2.4.63-250207-win64-VS17.zip"
Expand-Archive -Path apache.zip
Copy-Item .\Apache24\bin\ $HOME\Documents\apache\ -Recurse
cd .. &amp;&amp; Remove-Item "$HOME\Downloads\apache" -Recurse
</code></pre>
<p><code>$ab = "$HOME\Documents\apache\ab.exe"</code> <br />
<code>. $ab -n 10000 -c 100 http://192.168.3.100:8444/api/provider/list</code></p>
<pre><code>Количество одновременных запросов:  100
Время проведения тестов:            52,402 секунды
Выполненные запросы:                10000
Неудачные запросы:                  0
Передано всего:                     6830000 байтов
Передано HTML:                      3290000 байт
RPS (Requests Per Second):          190,83 [#/sec] (среднее)
Время одного запроса:               524.017 [MS] (среднее)
Время одного запроса:               5.240 [MS] (среднее, во всех одновременных запросах)
Скорость передачи:                  127,28 [Kbytes/Sec]
</code></pre>
<h2 id="locust"><a class="header" href="#locust">Locust</a></h2>
<p><a href="https://github.com/locustio/locust">Locust</a> - это инструмент нагрузочного тестирования для <code>HTTP</code> и других протоколов на <code>Python</code>.</p>
<p><code>pip3 install locust</code></p>
<pre><code class="language-Python">echo '
import os
from locust import HttpUser, task, between
class TorApiUser(HttpUser):
    # Каждый виртуальный пользователь будет ждать от 2 до 5 секунд перед выполнением следующего @task
    wait_time = between(2, 5)
    # Определяем заголовки запросов
    headers = {
        "User-Agent": "Locust"
    }
    # Получаем параметры из переменных окружения или использовать значение по умолчанию
    QUERY = os.getenv("QUERY", "test")
    # GET запросы (вес приоритета задачи для частоты ее выполнения, чем выше, тем чаще выполнение)
    @task(1)
    def test_status(self):
        self.client.get("/api/provider/list", headers=self.headers)
    @task(2)
    def test_search(self):
        # Словарь параметров, который автоматически конвертируется в строку запроса (?key=value&amp;key2=value2)
        searchParams = {
            "query": {self.QUERY},
            "category": 0,
            "page": 0
        }
        self.client.get("/api/search/title/rutracker", headers=self.headers, params=searchParams)
    # POST запрос с телом запроса
    # @task(3)
    # def test_post_auth(self):
    #     self.client.post("/api/auth", json={"username": "admin", "password": "password"})
' &gt; locustfile.py
</code></pre>
<p><code>locust -f locustfile.py --host http://192.168.3.100:8444</code> <br />
<code>$env:QUERY = "The+Rookie"</code> определяем переменную окружения для параметра запросов <br />
<code>locust -f locustfile.py --host http://192.168.3.100:8444 -u 10 -r 2 -t 30s</code> количество виртуальных пользователей (VU), частота появления новых пользователей в секунду (10 пользователей будут созданы за 5 секунд) и длительность 30 секунд <br />
<code>locust -f locustfile.py --host http://192.168.3.100:8444 -u 10 -r 2 -t 30s --headless --csv locustresult</code> запуск без веб-интерфейса с выгрузкой результатов в csv файлы</p>
<p>Запуск Web-интерфейса в контейнере Docker:</p>
<p><code>mkdir locust &amp;&amp; cd locust</code></p>
<pre><code class="language-dockerfile">FROM alpine:latest
RUN apk add --no-cache python3 py3-pip gcc musl-dev linux-headers python3-dev
RUN python3 -m venv /venv
RUN /venv/bin/pip install --no-cache-dir locust
ENV PATH="/venv/bin:$PATH"
COPY locustfile.py .
EXPOSE 8089
CMD ["locust", "-f", "/locustfile.py"]
</code></pre>
<p><code>sudo docker build -t locust-alpine-web . &amp;&amp; sudo docker run -d --name locust -p 8089:8089 --restart=unless-stopped locust-alpine-web</code></p>
<h1 id="graylog"><a class="header" href="#graylog">Graylog</a></h1>
<p><a href="https://hub.docker.com/r/itzg/graylog">Graylog Docker Image</a></p>
<ul>
<li>Установка MongoDB:</li>
</ul>
<pre><code class="language-bash">docker run --name mongo -d mongo:3
</code></pre>
<ul>
<li>Используем прокси для установки Elassticsearch:</li>
</ul>
<pre><code class="language-bash">docker run --name elasticsearch \
    -e "http.host=0.0.0.0" -e "xpack.security.enabled=false" \
    -d dockerhub.timeweb.cloud/library/elasticsearch:5.5.1
</code></pre>
<ul>
<li>Указать статический IP адрес для подключения к API</li>
</ul>
<pre><code class="language-bash">docker run --name Graylog \
    --link mongo \
    --link elasticsearch \
    -p 9000:9000 -p 12201:12201 -p 514:514 -p 5044:5044 \
    -e GRAYLOG_WEB_ENDPOINT_URI="http://192.168.3.101:9000/api" \
    -d graylog/graylog:2.3.2-1
</code></pre>
<ul>
<li>Настройка syslog на клиенте Linux:</li>
</ul>
<p><code>nano /etc/rsyslog.d/graylog.conf</code></p>
<pre><code class="language-bash">*.* @@192.168.3.101:514;RSYSLOG_SyslogProtocol23Format
</code></pre>
<p><code>systemctl restart rsyslog</code></p>
<ul>
<li>Создать входящий поток (inputs) для Syslog на порту 514 по протоколу TCP:</li>
</ul>
<p>http://192.168.3.101:9000/system/inputs</p>
<ul>
<li>Фильтр для логов Kinozal-Bot:</li>
</ul>
<p><code>facility:"system daemon" AND application_name:bash AND message:\[ AND message:\]</code></p>
<ul>
<li>Настройка Winlogbeat на клиенте Windows</li>
</ul>
<p>Установка агента:</p>
<pre><code class="language-PowerShell">irm https://artifacts.elastic.co/downloads/beats/winlogbeat/winlogbeat-8.15.0-windows-x86_64.zip -OutFile $home\Documents\winlogbeat-8.15.0.zip
Expand-Archive $home\Documents\winlogbeat-8.15.0.zip
cd $home\Documents\winlogbeat-8.15.0-windows-x86_64
</code></pre>
<p>Добавить отправку в Logstash:</p>
<p><code>code winlogbeat.yml</code></p>
<pre><code class="language-bash">output.logstash:
  hosts: ["192.168.3.101:5044"]
</code></pre>
<p>И закомментировать отправку данных в Elasticsearch (output.elasticsearch)</p>
<p><code>.\winlogbeat.exe -c winlogbeat.yml</code> запустить агент с правами администратора в консоли</p>
<pre><code class="language-bash">.\install-service-winlogbeat.ps1 # установить службу
Get-Service winlogbeat | Start-Service
</code></pre>
<ul>
<li>Настроить Inputs для приема Beats на порту 5044</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
